# ICX icx_uc_events.v1.00p.txt icx_uc_derived.v1.00p.txt

# aliases
aliases = {
     "M2MAddrMask0": "M2M{i}_PCI_PMON_ADDRMASK0",
     "UBoxFilter": "U_MSR_PMON_BOX_FILTER",
     "M2MAddrMatch0": "M2M{i}_PCI_PMON_ADDRMATCH1",
     "M2MAddrMask1": "M2M{i}_PCI_PMON_ADDRMASK1",
     "CHAFilter": "C{i}_MSR_PMON_BOX_FILTER",
     "M2MOpcMask": "M2M{i}_PCI_PMON_OPCMASK",
     "PCUFilter": "PCU_MSR_PMON_BOX_FILTER",
}

events = {

# PCIE3:
     "PCIE3.CORR_ERR": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Misc Events",
	  "Counters": "0-3",
	  "Desc": "Number of Correctable Errors",
	  "EvSel": 31,
	  "ExtSel": "",
     },
     "PCIE3.LINK_CYCLES": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Link Cycle Events",
	  "Counters": "0-3",
	  "Desc": "Cycles a Link is in a power state or busy/idle",
	  "EvSel": 24,
	  "ExtSel": "",
     },
     "PCIE3.LINK_CYCLES.L0_BUSY.PORT0": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Link Cycle Events",
	  "Counters": "0-3",
	  "Desc": "Cycles a Link is in a power state or busy/idle",
	  "EvSel": 24,
	  "ExtSel": "",
	  "PortMask": "bxxxxxxx1",
	  "Umask": "bxxxxxxx1",
     },
     "PCIE3.LINK_CYCLES.L0_BUSY.PORT2": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Link Cycle Events",
	  "Counters": "0-3",
	  "Desc": "Cycles a Link is in a power state or busy/idle",
	  "EvSel": 24,
	  "ExtSel": "",
	  "PortMask": "bxxxxx1xx",
	  "Umask": "bxxxxxxx1",
     },
     "PCIE3.LINK_CYCLES.L0_IDLE.PORT3": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Link Cycle Events",
	  "Counters": "0-3",
	  "Desc": "Cycles a Link is in a power state or busy/idle",
	  "EvSel": 24,
	  "ExtSel": "",
	  "PortMask": "bxxxx1xxx",
	  "Umask": "bxxxxx1xx",
     },
     "PCIE3.LINK_CYCLES.L1.PORT1": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Link Cycle Events",
	  "Counters": "0-3",
	  "Desc": "Cycles a Link is in a power state or busy/idle",
	  "EvSel": 24,
	  "ExtSel": "",
	  "PortMask": "bxxxxxx1x",
	  "Umask": "bxxxxxx1x",
     },
     "PCIE3.LINK_CYCLES.L0_IDLE.PORT1": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Link Cycle Events",
	  "Counters": "0-3",
	  "Desc": "Cycles a Link is in a power state or busy/idle",
	  "EvSel": 24,
	  "ExtSel": "",
	  "PortMask": "bxxxxxx1x",
	  "Umask": "bxxxxx1xx",
     },
     "PCIE3.LINK_CYCLES.L0_IDLE.PORT0": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Link Cycle Events",
	  "Counters": "0-3",
	  "Desc": "Cycles a Link is in a power state or busy/idle",
	  "EvSel": 24,
	  "ExtSel": "",
	  "PortMask": "bxxxxxxx1",
	  "Umask": "bxxxxx1xx",
     },
     "PCIE3.LINK_CYCLES.L1.PORT0": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Link Cycle Events",
	  "Counters": "0-3",
	  "Desc": "Cycles a Link is in a power state or busy/idle",
	  "EvSel": 24,
	  "ExtSel": "",
	  "PortMask": "bxxxxxxx1",
	  "Umask": "bxxxxxx1x",
     },
     "PCIE3.LINK_CYCLES.L0_IDLE.PORT2": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Link Cycle Events",
	  "Counters": "0-3",
	  "Desc": "Cycles a Link is in a power state or busy/idle",
	  "EvSel": 24,
	  "ExtSel": "",
	  "PortMask": "bxxxxx1xx",
	  "Umask": "bxxxxx1xx",
     },
     "PCIE3.LINK_CYCLES.L1.PORT3": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Link Cycle Events",
	  "Counters": "0-3",
	  "Desc": "Cycles a Link is in a power state or busy/idle",
	  "EvSel": 24,
	  "ExtSel": "",
	  "PortMask": "bxxxx1xxx",
	  "Umask": "bxxxxxx1x",
     },
     "PCIE3.LINK_CYCLES.L1.PORT2": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Link Cycle Events",
	  "Counters": "0-3",
	  "Desc": "Cycles a Link is in a power state or busy/idle",
	  "EvSel": 24,
	  "ExtSel": "",
	  "PortMask": "bxxxxx1xx",
	  "Umask": "bxxxxxx1x",
     },
     "PCIE3.LINK_CYCLES.L0_BUSY.PORT1": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Link Cycle Events",
	  "Counters": "0-3",
	  "Desc": "Cycles a Link is in a power state or busy/idle",
	  "EvSel": 24,
	  "ExtSel": "",
	  "PortMask": "bxxxxxx1x",
	  "Umask": "bxxxxxxx1",
     },
     "PCIE3.LINK_CYCLES.L0_BUSY.PORT3": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Link Cycle Events",
	  "Counters": "0-3",
	  "Desc": "Cycles a Link is in a power state or busy/idle",
	  "EvSel": 24,
	  "ExtSel": "",
	  "PortMask": "bxxxx1xxx",
	  "Umask": "bxxxxxxx1",
     },
     "PCIE3.LINK_RETRIES": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Misc Events",
	  "Counters": "0-3",
	  "Desc": "Number of Link Retries",
	  "EvSel": 30,
	  "ExtSel": "",
     },
     "PCIE3.UTIL_IN": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Utilization Events",
	  "Counters": "0-3",
	  "Defn": "Number of Cycles the Inbound Link is Utilized.   Utilized is whenever the IP was not idle",
	  "Desc": "Cycles of Inbound Link Utilization",
	  "EvSel": 22,
	  "ExtSel": "",
     },
     "PCIE3.UTIL_IN.PORT0": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Utilization Events",
	  "Counters": "0-3",
	  "Defn": "Number of Cycles the Inbound Link is Utilized.   Utilized is whenever the IP was not idle",
	  "Desc": "Cycles of Inbound Link Utilization",
	  "EvSel": 22,
	  "ExtSel": "",
	  "PortMask": "bxxxxxxx1",
	  "Umask": "bxxxxxxxx",
     },
     "PCIE3.UTIL_IN.PORT1": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Utilization Events",
	  "Counters": "0-3",
	  "Defn": "Number of Cycles the Inbound Link is Utilized.   Utilized is whenever the IP was not idle",
	  "Desc": "Cycles of Inbound Link Utilization",
	  "EvSel": 22,
	  "ExtSel": "",
	  "PortMask": "bxxxxxx1x",
	  "Umask": "bxxxxxxxx",
     },
     "PCIE3.UTIL_IN.PORT2": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Utilization Events",
	  "Counters": "0-3",
	  "Defn": "Number of Cycles the Inbound Link is Utilized.   Utilized is whenever the IP was not idle",
	  "Desc": "Cycles of Inbound Link Utilization",
	  "EvSel": 22,
	  "ExtSel": "",
	  "PortMask": "bxxxxx1xx",
	  "Umask": "bxxxxxxxx",
     },
     "PCIE3.UTIL_IN.PORT3": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Utilization Events",
	  "Counters": "0-3",
	  "Defn": "Number of Cycles the Inbound Link is Utilized.   Utilized is whenever the IP was not idle",
	  "Desc": "Cycles of Inbound Link Utilization",
	  "EvSel": 22,
	  "ExtSel": "",
	  "PortMask": "bxxxx1xxx",
	  "Umask": "bxxxxxxxx",
     },
     "PCIE3.UTIL_OUT": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Utilization Events",
	  "Counters": "0-3",
	  "Defn": "Number of Cycles the Outbound Link is Utilized.   Utilized is whenever the IP was not idle",
	  "Desc": "Cycles of Outbound Link Utilization",
	  "EvSel": 23,
	  "ExtSel": "",
     },
     "PCIE3.UTIL_OUT.PORT0": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Utilization Events",
	  "Counters": "0-3",
	  "Defn": "Number of Cycles the Outbound Link is Utilized.   Utilized is whenever the IP was not idle",
	  "Desc": "Cycles of Outbound Link Utilization",
	  "EvSel": 23,
	  "ExtSel": "",
	  "PortMask": "bxxxxxxx1",
	  "Umask": "bxxxxxxxx",
     },
     "PCIE3.UTIL_OUT.PORT1": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Utilization Events",
	  "Counters": "0-3",
	  "Defn": "Number of Cycles the Outbound Link is Utilized.   Utilized is whenever the IP was not idle",
	  "Desc": "Cycles of Outbound Link Utilization",
	  "EvSel": 23,
	  "ExtSel": "",
	  "PortMask": "bxxxxxx1x",
	  "Umask": "bxxxxxxxx",
     },
     "PCIE3.UTIL_OUT.PORT2": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Utilization Events",
	  "Counters": "0-3",
	  "Defn": "Number of Cycles the Outbound Link is Utilized.   Utilized is whenever the IP was not idle",
	  "Desc": "Cycles of Outbound Link Utilization",
	  "EvSel": 23,
	  "ExtSel": "",
	  "PortMask": "bxxxxx1xx",
	  "Umask": "bxxxxxxxx",
     },
     "PCIE3.UTIL_OUT.PORT3": {
	  "Box": "PCIE3",
	  "Category": "PCIE3 Utilization Events",
	  "Counters": "0-3",
	  "Defn": "Number of Cycles the Outbound Link is Utilized.   Utilized is whenever the IP was not idle",
	  "Desc": "Cycles of Outbound Link Utilization",
	  "EvSel": 23,
	  "ExtSel": "",
	  "PortMask": "bxxxx1xxx",
	  "Umask": "bxxxxxxxx",
     },

# UPI_LL:
     "UPI_LL.CLOCKTICKS": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL CFCLK Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of clocks in the UPI LL.  This clock runs at 1/8th the \"GT/s\" speed of the UPI link.  For example, a 8GT/s link will have qfclk or 1GHz.  Current products do not support dynamic link speeds, so this frequency is fixed.",
	  "Desc": "Number of kfclks",
	  "EvSel": 1,
	  "ExtSel": "",
     },
     "UPI_LL.DIRECT_ATTEMPTS": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL DIRECT2CORE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of DRS packets that we attempted to do direct2core/direct2UPI on.  There are 4 mutually exlusive filters.  Filter [0] can be used to get successful spawns, while [1:3] provide the different failure cases.  Note that this does not count packets that are not candidates for Direct2Core.  The only candidates for Direct2Core are DRS packets destined for Cbos.",
	  "Desc": "Direct packet attempts",
	  "EvSel": 18,
	  "ExtSel": "",
     },
     "UPI_LL.DIRECT_ATTEMPTS.D2C": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL DIRECT2CORE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of DRS packets that we attempted to do direct2core/direct2UPI on.  There are 4 mutually exlusive filters.  Filter [0] can be used to get successful spawns, while [1:3] provide the different failure cases.  Note that this does not count packets that are not candidates for Direct2Core.  The only candidates for Direct2Core are DRS packets destined for Cbos.",
	  "Desc": "Direct packet attempts",
	  "EvSel": 18,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "UPI_LL.DIRECT_ATTEMPTS.D2K": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL DIRECT2CORE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of DRS packets that we attempted to do direct2core/direct2UPI on.  There are 4 mutually exlusive filters.  Filter [0] can be used to get successful spawns, while [1:3] provide the different failure cases.  Note that this does not count packets that are not candidates for Direct2Core.  The only candidates for Direct2Core are DRS packets destined for Cbos.",
	  "Desc": "Direct packet attempts",
	  "EvSel": 18,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "UPI_LL.FLOWQ_NO_VNA_CRD": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 24,
	  "ExtSel": "",
     },
     "UPI_LL.FLOWQ_NO_VNA_CRD.AK_VNA_EQ0": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "UPI_LL.FLOWQ_NO_VNA_CRD.AK_VNA_EQ2": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "UPI_LL.FLOWQ_NO_VNA_CRD.AD_VNA_EQ1": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "UPI_LL.FLOWQ_NO_VNA_CRD.AD_VNA_EQ2": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "UPI_LL.FLOWQ_NO_VNA_CRD.AD_VNA_EQ0": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "UPI_LL.FLOWQ_NO_VNA_CRD.AK_VNA_EQ3": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "UPI_LL.FLOWQ_NO_VNA_CRD.AK_VNA_EQ1": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "UPI_LL.FLOWQ_NO_VNA_CRD.BL_VNA_EQ0": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "UPI_LL.L1_POWER_CYCLES": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER Events",
	  "Counters": "0-3",
	  "Defn": "Number of UPI qfclk cycles spent in L1 power mode.  L1 is a mode that totally shuts down a UPI link.  Use edge detect to count the number of instances when the UPI link entered L1.  Link power states are per link and per direction, so for example the Tx direction could be in one state while Rx was in another. Because L1 totally shuts down the link, it takes a good amount of time to exit this mode.",
	  "Desc": "Cycles in L1",
	  "EvSel": 33,
	  "ExtSel": "",
     },
     "UPI_LL.M3_BYP_BLOCKED": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 20,
	  "ExtSel": "",
     },
     "UPI_LL.M3_BYP_BLOCKED.FLOWQ_AK_VNA_LE3": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 20,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "UPI_LL.M3_BYP_BLOCKED.FLOWQ_AD_VNA_LE2": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 20,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "UPI_LL.M3_BYP_BLOCKED.FLOWQ_BL_VNA_EQ0": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 20,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "UPI_LL.M3_BYP_BLOCKED.GV_BLOCK": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 20,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "UPI_LL.M3_BYP_BLOCKED.BGF_CRD": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 20,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "UPI_LL.M3_CRD_RETURN_BLOCKED": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 22,
	  "ExtSel": "",
     },
     "UPI_LL.M3_RXQ_BLOCKED": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 21,
	  "ExtSel": "",
     },
     "UPI_LL.M3_RXQ_BLOCKED.FLOWQ_BL_VNA_EQ0": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 21,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "UPI_LL.M3_RXQ_BLOCKED.FLOWQ_AK_VNA_LE3": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 21,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "UPI_LL.M3_RXQ_BLOCKED.FLOWQ_AD_VNA_LE2": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 21,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "UPI_LL.M3_RXQ_BLOCKED.BGF_CRD": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 21,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "UPI_LL.M3_RXQ_BLOCKED.FLOWQ_BL_VNA_BTW_0_THRESH": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 21,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "UPI_LL.M3_RXQ_BLOCKED.GV_BLOCK": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 21,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "UPI_LL.M3_RXQ_BLOCKED.FLOWQ_AD_VNA_BTW_2_THRESH": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL LL to M3 Events",
	  "Counters": "0-3",
	  "EvSel": 21,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "UPI_LL.PHY_INIT_CYCLES": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER Events",
	  "Counters": "0-3",
	  "Desc": "Cycles where phy is not in L0, L0c, L0p, L1",
	  "EvSel": 32,
	  "ExtSel": "",
     },
     "UPI_LL.POWER_L1_NACK": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times a link sends/receives a LinkReqNAck.  When the UPI links would like to change power state, the Tx side initiates a request to the Rx side requesting to change states.  This requests can either be accepted or denied.  If the Rx side replies with an Ack, the power mode will change.  If it replies with NAck, no change will take place.  This can be filtered based on Rx and Tx.  An Rx LinkReqNAck refers to receiving an NAck (meaning this agent's Tx originally requested the power change).  A Tx LinkReqNAck refers to sending this command (meaning the peer agent's Tx originally requested the power change and this agent accepted it).",
	  "Desc": "L1 Req Nack",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Notes": "L1 only",
     },
     "UPI_LL.POWER_L1_REQ": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times a link sends/receives a LinkReqAck.  When the UPI links would like to change power state, the Tx side initiates a request to the Rx side requesting to change states.  This requests can either be accepted or denied.  If the Rx side replies with an Ack, the power mode will change.  If it replies with NAck, no change will take place.  This can be filtered based on Rx and Tx.  An Rx LinkReqAck refers to receiving an Ack (meaning this agent's Tx originally requested the power change).  A Tx LinkReqAck refers to sending this command (meaning the peer agent's Tx originally requested the power change and this agent accepted it).",
	  "Desc": "L1 Req (same as L1 Ack).",
	  "EvSel": 34,
	  "ExtSel": "",
	  "Notes": "L1 only",
     },
     "UPI_LL.REQ_SLOT2_FROM_M3": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL VNA_CREDIT_RETURN Events",
	  "Counters": "0-3",
	  "EvSel": 70,
	  "ExtSel": "",
     },
     "UPI_LL.REQ_SLOT2_FROM_M3.ACK": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL VNA_CREDIT_RETURN Events",
	  "Counters": "0-3",
	  "EvSel": 70,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "UPI_LL.REQ_SLOT2_FROM_M3.VN0": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL VNA_CREDIT_RETURN Events",
	  "Counters": "0-3",
	  "EvSel": 70,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "UPI_LL.REQ_SLOT2_FROM_M3.VN1": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL VNA_CREDIT_RETURN Events",
	  "Counters": "0-3",
	  "EvSel": 70,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "UPI_LL.REQ_SLOT2_FROM_M3.VNA": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL VNA_CREDIT_RETURN Events",
	  "Counters": "0-3",
	  "EvSel": 70,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "UPI_LL.RxL0P_POWER_CYCLES": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER_RX Events",
	  "Counters": "0-3",
	  "Defn": "Number of UPI qfclk cycles spent in L0p power mode.  L0p is a mode where we disable 1/2 of the UPI lanes, decreasing our bandwidth in order to save power.  It increases snoop and data transfer latencies and decreases overall bandwidth.  This mode can be very useful in NUMA optimized workloads that largely only utilize UPI for snoops and their responses.  Use edge detect to count the number of instances when the UPI link entered L0p.  Link power states are per link and per direction, so for example the Tx direction could be in one state while Rx was in another.",
	  "Desc": "Cycles in L0p",
	  "EvSel": 37,
	  "ExtSel": "",
	  "Notes": "Using .edge_det to count transitions does not function if L1_POWER_CYCLES > 0.",
     },
     "UPI_LL.RxL0_POWER_CYCLES": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER_RX Events",
	  "Counters": "0-3",
	  "Defn": "Number of UPI qfclk cycles spent in L0 power mode in the Link Layer.  L0 is the default mode which provides the highest performance with the most power.  Use edge detect to count the number of instances that the link entered L0.  Link power states are per link and per direction, so for example the Tx direction could be in one state while Rx was in another.  The phy layer  sometimes leaves L0 for training, which will not be captured by this event.",
	  "Desc": "Cycles in L0",
	  "EvSel": 36,
	  "ExtSel": "",
     },
     "UPI_LL.RxL_BASIC_HDR_MATCH": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Receive path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Receive path of a UPI Port",
	  "EvSel": 5,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
     },
     "UPI_LL.RxL_BASIC_HDR_MATCH.RSP_NODATA_OPC": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Receive path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Receive path of a UPI Port",
	  "EvSel": 5,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bXXXX1010",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.RxL_BASIC_HDR_MATCH.RSP_DATA_OPC": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Receive path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Receive path of a UPI Port",
	  "EvSel": 5,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bXXXX1100",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.RxL_BASIC_HDR_MATCH.WB": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Receive path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Receive path of a UPI Port",
	  "EvSel": 5,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1101",
	  "UmaskExt": 0x0,
     },
     "UPI_LL.RxL_BASIC_HDR_MATCH.RSP_DATA": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Receive path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Receive path of a UPI Port",
	  "EvSel": 5,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1100",
	  "UmaskExt": 0x0,
     },
     "UPI_LL.RxL_BASIC_HDR_MATCH.NCB_OPC": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Receive path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Receive path of a UPI Port",
	  "EvSel": 5,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1110",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.RxL_BASIC_HDR_MATCH.RSP_NODATA": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Receive path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Receive path of a UPI Port",
	  "EvSel": 5,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1010",
	  "UmaskExt": 0x0,
     },
     "UPI_LL.RxL_BASIC_HDR_MATCH.SNP_OPC": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Receive path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Receive path of a UPI Port",
	  "EvSel": 5,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bXXXX1001",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.RxL_BASIC_HDR_MATCH.REQ": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Receive path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Receive path of a UPI Port",
	  "EvSel": 5,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1000",
	  "UmaskExt": 0x0,
     },
     "UPI_LL.RxL_BASIC_HDR_MATCH.NCS": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Receive path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Receive path of a UPI Port",
	  "EvSel": 5,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1111",
	  "UmaskExt": 0x0,
     },
     "UPI_LL.RxL_BASIC_HDR_MATCH.WB_OPC": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Receive path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Receive path of a UPI Port",
	  "EvSel": 5,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1101",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.RxL_BASIC_HDR_MATCH.RSPCNFLT": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Receive path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Receive path of a UPI Port",
	  "EvSel": 5,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "b10101010",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.RxL_BASIC_HDR_MATCH.NCB": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Receive path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Receive path of a UPI Port",
	  "EvSel": 5,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1110",
	  "UmaskExt": 0x0,
     },
     "UPI_LL.RxL_BASIC_HDR_MATCH.RSPI": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Receive path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Receive path of a UPI Port",
	  "EvSel": 5,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "b00101010",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.RxL_BASIC_HDR_MATCH.NCS_OPC": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Receive path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Receive path of a UPI Port",
	  "EvSel": 5,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1111",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.RxL_BASIC_HDR_MATCH.REQ_OPC": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Receive path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Receive path of a UPI Port",
	  "EvSel": 5,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bXXXX1000",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.RxL_BASIC_HDR_MATCH.SNP": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Receive path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Receive path of a UPI Port",
	  "EvSel": 5,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1001",
	  "UmaskExt": 0x0,
     },
     "UPI_LL.RxL_BYPASSED": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times that an incoming flit was able to bypass the flit buffer and pass directly across the BGF and into the Egress.  This is a latency optimization, and should generally be the common case.  If this value is less than the number of flits transfered, it implies that there was queueing getting onto the ring, and thus the transactions saw higher latency.",
	  "Desc": "RxQ Flit Buffer Bypassed",
	  "EvSel": 49,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
     },
     "UPI_LL.RxL_BYPASSED.SLOT2": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times that an incoming flit was able to bypass the flit buffer and pass directly across the BGF and into the Egress.  This is a latency optimization, and should generally be the common case.  If this value is less than the number of flits transfered, it implies that there was queueing getting onto the ring, and thus the transactions saw higher latency.",
	  "Desc": "RxQ Flit Buffer Bypassed",
	  "EvSel": 49,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxx1xx",
     },
     "UPI_LL.RxL_BYPASSED.SLOT1": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times that an incoming flit was able to bypass the flit buffer and pass directly across the BGF and into the Egress.  This is a latency optimization, and should generally be the common case.  If this value is less than the number of flits transfered, it implies that there was queueing getting onto the ring, and thus the transactions saw higher latency.",
	  "Desc": "RxQ Flit Buffer Bypassed",
	  "EvSel": 49,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxxx1x",
     },
     "UPI_LL.RxL_BYPASSED.SLOT0": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times that an incoming flit was able to bypass the flit buffer and pass directly across the BGF and into the Egress.  This is a latency optimization, and should generally be the common case.  If this value is less than the number of flits transfered, it implies that there was queueing getting onto the ring, and thus the transactions saw higher latency.",
	  "Desc": "RxQ Flit Buffer Bypassed",
	  "EvSel": 49,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxxxx1",
     },
     "UPI_LL.RxL_CRC_ERRORS": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL CRC_ERRORS_RX Events",
	  "Counters": "0-3",
	  "Defn": "Number of CRC errors detected in the UPI Agent.  Each UPI flit incorporates 8 bits of CRC for error detection.  This counts the number of flits where the CRC was able to detect an error.  After an error has been detected, the UPI agent will send a request to the transmitting socket to resend the flit (as well as any flits that came after it).",
	  "Desc": "CRC Errors Detected",
	  "EvSel": 11,
	  "ExtSel": "",
     },
     "UPI_LL.RxL_CRC_LLR_REQ_TRANSMIT": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL CRC_ERRORS_RX Events",
	  "Counters": "0-3",
	  "Defn": "Number of LLR Requests were transmitted.  This should generally be <= the number of CRC errors detected.  If multiple errors are detected before the Rx side receives a LLC_REQ_ACK from the Tx side, there is no need to send more LLR_REQ_NACKs.",
	  "Desc": "LLR Requests Sent",
	  "EvSel": 8,
	  "ExtSel": "",
	  "Notes": "We detected an error in Rx, and so we transmit to enter LLR mode.  If we get an error and we ahave not yet recv'd the LLR_ACK, we will not send another request (unless we timeout when we will send another).",
     },
     "UPI_LL.RxL_CREDITS_CONSUMED_VN0": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RX_CREDITS_CONSUMED Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times that an RxQ VN0 credit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.",
	  "Desc": "VN0 Credit Consumed",
	  "EvSel": 57,
	  "ExtSel": "",
     },
     "UPI_LL.RxL_CREDITS_CONSUMED_VN1": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RX_CREDITS_CONSUMED Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times that an RxQ VN1 credit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.",
	  "Desc": "VN1 Credit Consumed",
	  "EvSel": 58,
	  "ExtSel": "",
     },
     "UPI_LL.RxL_CREDITS_CONSUMED_VNA": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RX_CREDITS_CONSUMED Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times that an RxQ VNA credit was consumed (i.e. message uses a VNA credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.",
	  "Desc": "VNA Credit Consumed",
	  "EvSel": 56,
	  "ExtSel": "",
     },
     "UPI_LL.RxL_FLITS": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Received",
	  "EvSel": 3,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "When Umask is set to all 1's then  all Flits should be counted as 3 since a full flit is counted for each valid slot. By counting all legal flit time we exclude  impact of L0p, L0c, and the 5/6 ratio in L0.   Slot 0 Dual is counted in slot 0 and slot 1 (as a protocol header)",
     },
     "UPI_LL.RxL_FLITS.SLOT1": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Received",
	  "EvSel": 3,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "When Umask is set to all 1's then  all Flits should be counted as 3 since a full flit is counted for each valid slot. By counting all legal flit time we exclude  impact of L0p, L0c, and the 5/6 ratio in L0.   Slot 0 Dual is counted in slot 0 and slot 1 (as a protocol header)",
	  "Umask": "bxxxxxx1x",
     },
     "UPI_LL.RxL_FLITS.NON_DATA": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Received",
	  "EvSel": 3,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "When Umask is set to all 1's then  all Flits should be counted as 3 since a full flit is counted for each valid slot. By counting all legal flit time we exclude  impact of L0p, L0c, and the 5/6 ratio in L0.   Slot 0 Dual is counted in slot 0 and slot 1 (as a protocol header)",
	  "Umask": "b10010111",
     },
     "UPI_LL.RxL_FLITS.DATA": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Received",
	  "EvSel": 3,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "When Umask is set to all 1's then  all Flits should be counted as 3 since a full flit is counted for each valid slot. By counting all legal flit time we exclude  impact of L0p, L0c, and the 5/6 ratio in L0.   Slot 0 Dual is counted in slot 0 and slot 1 (as a protocol header)",
	  "Umask": "bxxxx1xxx",
     },
     "UPI_LL.RxL_FLITS.LLCTRL": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Received",
	  "EvSel": 3,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "When Umask is set to all 1's then  all Flits should be counted as 3 since a full flit is counted for each valid slot. By counting all legal flit time we exclude  impact of L0p, L0c, and the 5/6 ratio in L0.   Slot 0 Dual is counted in slot 0 and slot 1 (as a protocol header)",
	  "Umask": "bx1xxxxxx",
     },
     "UPI_LL.RxL_FLITS.ALL_DATA": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Received",
	  "EvSel": 3,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "When Umask is set to all 1's then  all Flits should be counted as 3 since a full flit is counted for each valid slot. By counting all legal flit time we exclude  impact of L0p, L0c, and the 5/6 ratio in L0.   Slot 0 Dual is counted in slot 0 and slot 1 (as a protocol header)",
	  "Umask": "b00001111",
     },
     "UPI_LL.RxL_FLITS.SLOT2": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Received",
	  "EvSel": 3,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "When Umask is set to all 1's then  all Flits should be counted as 3 since a full flit is counted for each valid slot. By counting all legal flit time we exclude  impact of L0p, L0c, and the 5/6 ratio in L0.   Slot 0 Dual is counted in slot 0 and slot 1 (as a protocol header)",
	  "Umask": "bxxxxx1xx",
     },
     "UPI_LL.RxL_FLITS.PROTHDR": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Received",
	  "EvSel": 3,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "When Umask is set to all 1's then  all Flits should be counted as 3 since a full flit is counted for each valid slot. By counting all legal flit time we exclude  impact of L0p, L0c, and the 5/6 ratio in L0.   Slot 0 Dual is counted in slot 0 and slot 1 (as a protocol header)",
	  "Umask": "b1xxxxxxx",
     },
     "UPI_LL.RxL_FLITS.ALL_NULL": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Received",
	  "EvSel": 3,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "When Umask is set to all 1's then  all Flits should be counted as 3 since a full flit is counted for each valid slot. By counting all legal flit time we exclude  impact of L0p, L0c, and the 5/6 ratio in L0.   Slot 0 Dual is counted in slot 0 and slot 1 (as a protocol header)",
	  "Umask": "b00100111",
     },
     "UPI_LL.RxL_FLITS.IDLE": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Received",
	  "EvSel": 3,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "When Umask is set to all 1's then  all Flits should be counted as 3 since a full flit is counted for each valid slot. By counting all legal flit time we exclude  impact of L0p, L0c, and the 5/6 ratio in L0.   Slot 0 Dual is counted in slot 0 and slot 1 (as a protocol header)",
	  "Umask": "b01000111",
     },
     "UPI_LL.RxL_FLITS.NULL": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Received",
	  "EvSel": 3,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "When Umask is set to all 1's then  all Flits should be counted as 3 since a full flit is counted for each valid slot. By counting all legal flit time we exclude  impact of L0p, L0c, and the 5/6 ratio in L0.   Slot 0 Dual is counted in slot 0 and slot 1 (as a protocol header)",
	  "Umask": "bxx1xxxxx",
     },
     "UPI_LL.RxL_FLITS.SLOT0": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Received",
	  "EvSel": 3,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "When Umask is set to all 1's then  all Flits should be counted as 3 since a full flit is counted for each valid slot. By counting all legal flit time we exclude  impact of L0p, L0c, and the 5/6 ratio in L0.   Slot 0 Dual is counted in slot 0 and slot 1 (as a protocol header)",
	  "Umask": "bxxxxxxx1",
     },
     "UPI_LL.RxL_FLITS.LLCRD": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Received",
	  "EvSel": 3,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "When Umask is set to all 1's then  all Flits should be counted as 3 since a full flit is counted for each valid slot. By counting all legal flit time we exclude  impact of L0p, L0c, and the 5/6 ratio in L0.   Slot 0 Dual is counted in slot 0 and slot 1 (as a protocol header)",
	  "Umask": "bxxx1xxxx",
     },
     "UPI_LL.RxL_INSERTS": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of allocations into the UPI Rx Flit Buffer.  Generally, when data is transmitted across UPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.",
	  "Desc": "RxQ Flit Buffer Allocations",
	  "EvSel": 48,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
     },
     "UPI_LL.RxL_INSERTS.SLOT1": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of allocations into the UPI Rx Flit Buffer.  Generally, when data is transmitted across UPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.",
	  "Desc": "RxQ Flit Buffer Allocations",
	  "EvSel": 48,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxxx1x",
     },
     "UPI_LL.RxL_INSERTS.SLOT0": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of allocations into the UPI Rx Flit Buffer.  Generally, when data is transmitted across UPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.",
	  "Desc": "RxQ Flit Buffer Allocations",
	  "EvSel": 48,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxxxx1",
     },
     "UPI_LL.RxL_INSERTS.SLOT2": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of allocations into the UPI Rx Flit Buffer.  Generally, when data is transmitted across UPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.",
	  "Desc": "RxQ Flit Buffer Allocations",
	  "EvSel": 48,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxx1xx",
     },
     "UPI_LL.RxL_OCCUPANCY": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "Defn": "Accumulates the number of elements in the UPI RxQ in each cycle.  Generally, when data is transmitted across UPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.",
	  "Desc": "RxQ Occupancy - All Packets",
	  "EvSel": 50,
	  "ExtSel": "",
	  "MaxIncCyc": 128,
     },
     "UPI_LL.RxL_OCCUPANCY.SLOT2": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "Defn": "Accumulates the number of elements in the UPI RxQ in each cycle.  Generally, when data is transmitted across UPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.",
	  "Desc": "RxQ Occupancy - All Packets",
	  "EvSel": 50,
	  "ExtSel": "",
	  "MaxIncCyc": 128,
	  "Umask": "bxxxxx1xx",
     },
     "UPI_LL.RxL_OCCUPANCY.SLOT1": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "Defn": "Accumulates the number of elements in the UPI RxQ in each cycle.  Generally, when data is transmitted across UPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.",
	  "Desc": "RxQ Occupancy - All Packets",
	  "EvSel": 50,
	  "ExtSel": "",
	  "MaxIncCyc": 128,
	  "Umask": "bxxxxxx1x",
     },
     "UPI_LL.RxL_OCCUPANCY.SLOT0": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "Defn": "Accumulates the number of elements in the UPI RxQ in each cycle.  Generally, when data is transmitted across UPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.",
	  "Desc": "RxQ Occupancy - All Packets",
	  "EvSel": 50,
	  "ExtSel": "",
	  "MaxIncCyc": 128,
	  "Umask": "bxxxxxxx1",
     },
     "UPI_LL.RxL_SLOT_BYPASS": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "EvSel": 51,
	  "ExtSel": "",
     },
     "UPI_LL.RxL_SLOT_BYPASS.S2_RXQ1": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "UPI_LL.RxL_SLOT_BYPASS.S0_RXQ1": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "UPI_LL.RxL_SLOT_BYPASS.S1_RXQ2": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "UPI_LL.RxL_SLOT_BYPASS.S2_RXQ0": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "UPI_LL.RxL_SLOT_BYPASS.S1_RXQ0": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "UPI_LL.RxL_SLOT_BYPASS.S0_RXQ2": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL RXQ Events",
	  "Counters": "0-3",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "UPI_LL.TxL0P_CLK_ACTIVE": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER_TX Events",
	  "Counters": "0-3",
	  "EvSel": 42,
	  "ExtSel": "",
     },
     "UPI_LL.TxL0P_CLK_ACTIVE.SPARE": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER_TX Events",
	  "Counters": "0-3",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "UPI_LL.TxL0P_CLK_ACTIVE.TXQ": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER_TX Events",
	  "Counters": "0-3",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "UPI_LL.TxL0P_CLK_ACTIVE.CFG_CTL": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER_TX Events",
	  "Counters": "0-3",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "UPI_LL.TxL0P_CLK_ACTIVE.RXQ_CRED": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER_TX Events",
	  "Counters": "0-3",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "UPI_LL.TxL0P_CLK_ACTIVE.RXQ": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER_TX Events",
	  "Counters": "0-3",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "UPI_LL.TxL0P_CLK_ACTIVE.RXQ_BYPASS": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER_TX Events",
	  "Counters": "0-3",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "UPI_LL.TxL0P_CLK_ACTIVE.RETRY": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER_TX Events",
	  "Counters": "0-3",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "UPI_LL.TxL0P_CLK_ACTIVE.DFX": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER_TX Events",
	  "Counters": "0-3",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "UPI_LL.TxL0P_POWER_CYCLES": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER_TX Events",
	  "Counters": "0-3",
	  "Defn": "Number of UPI qfclk cycles spent in L0p power mode.  L0p is a mode where we disable 1/2 of the UPI lanes, decreasing our bandwidth in order to save power.  It increases snoop and data transfer latencies and decreases overall bandwidth.  This mode can be very useful in NUMA optimized workloads that largely only utilize UPI for snoops and their responses.  Use edge detect to count the number of instances when the UPI link entered L0p.  Link power states are per link and per direction, so for example the Tx direction could be in one state while Rx was in another.",
	  "Desc": "Cycles in L0p",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Notes": "Using .edge_det to count transitions does not function if L1_POWER_CYCLES > 0.",
     },
     "UPI_LL.TxL0P_POWER_CYCLES_LL_ENTER": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER_TX Events",
	  "Counters": "0-3",
	  "EvSel": 40,
	  "ExtSel": "",
     },
     "UPI_LL.TxL0P_POWER_CYCLES_M3_EXIT": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER_TX Events",
	  "Counters": "0-3",
	  "EvSel": 41,
	  "ExtSel": "",
     },
     "UPI_LL.TxL0_POWER_CYCLES": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER_TX Events",
	  "Counters": "0-3",
	  "Defn": "Number of UPI qfclk cycles spent in L0 power mode in the Link Layer.  L0 is the default mode which provides the highest performance with the most power.  Use edge detect to count the number of instances that the link entered L0.  Link power states are per link and per direction, so for example the Tx direction could be in one state while Rx was in another.  The phy layer  sometimes leaves L0 for training, which will not be captured by this event.",
	  "Desc": "Cycles in L0",
	  "EvSel": 38,
	  "ExtSel": "",
	  "Notes": "Includes L0p cycles.  To get just L0, subtract TxL0P_POWER_CYCLES",
     },
     "UPI_LL.TxL_BASIC_HDR_MATCH": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Transmit path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Transmit path of a UPI Port",
	  "EvSel": 4,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
     },
     "UPI_LL.TxL_BASIC_HDR_MATCH.RSP_DATA_OPC": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Transmit path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Transmit path of a UPI Port",
	  "EvSel": 4,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bXXXX1100",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.TxL_BASIC_HDR_MATCH.WB": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Transmit path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Transmit path of a UPI Port",
	  "EvSel": 4,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1101",
	  "UmaskExt": 0x0,
     },
     "UPI_LL.TxL_BASIC_HDR_MATCH.RSP_NODATA_OPC": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Transmit path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Transmit path of a UPI Port",
	  "EvSel": 4,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bXXXX1010",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.TxL_BASIC_HDR_MATCH.WB_OPC": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Transmit path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Transmit path of a UPI Port",
	  "EvSel": 4,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1101",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.TxL_BASIC_HDR_MATCH.RSPCNFLT": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Transmit path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Transmit path of a UPI Port",
	  "EvSel": 4,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "b10101010",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.TxL_BASIC_HDR_MATCH.NCB": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Transmit path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Transmit path of a UPI Port",
	  "EvSel": 4,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1110",
	  "UmaskExt": 0x0,
     },
     "UPI_LL.TxL_BASIC_HDR_MATCH.RSPI": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Transmit path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Transmit path of a UPI Port",
	  "EvSel": 4,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "b00101010",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.TxL_BASIC_HDR_MATCH.NCS_OPC": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Transmit path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Transmit path of a UPI Port",
	  "EvSel": 4,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1111",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.TxL_BASIC_HDR_MATCH.REQ_OPC": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Transmit path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Transmit path of a UPI Port",
	  "EvSel": 4,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bXXXX1000",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.TxL_BASIC_HDR_MATCH.SNP": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Transmit path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Transmit path of a UPI Port",
	  "EvSel": 4,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1001",
	  "UmaskExt": 0x0,
     },
     "UPI_LL.TxL_BASIC_HDR_MATCH.RSP_DATA": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Transmit path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Transmit path of a UPI Port",
	  "EvSel": 4,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1100",
	  "UmaskExt": 0x0,
     },
     "UPI_LL.TxL_BASIC_HDR_MATCH.NCB_OPC": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Transmit path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Transmit path of a UPI Port",
	  "EvSel": 4,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1110",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.TxL_BASIC_HDR_MATCH.REQ": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Transmit path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Transmit path of a UPI Port",
	  "EvSel": 4,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1000",
	  "UmaskExt": 0x0,
     },
     "UPI_LL.TxL_BASIC_HDR_MATCH.SNP_OPC": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Transmit path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Transmit path of a UPI Port",
	  "EvSel": 4,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bXXXX1001",
	  "UmaskExt": 0x1,
     },
     "UPI_LL.TxL_BASIC_HDR_MATCH.RSP_NODATA": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Transmit path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Transmit path of a UPI Port",
	  "EvSel": 4,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1010",
	  "UmaskExt": 0x0,
     },
     "UPI_LL.TxL_BASIC_HDR_MATCH.NCS": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Counters": "0-3",
	  "Defn": """Matches on Transmit path of a UPI port.
Match based on UMask specific bits:
Z: Message Class (3-bit)
Y: Message Class Enable
W: Opcode (4-bit)
V: Opcode Enable
U: Local Enable
T: Remote Enable
S: Data Hdr Enable
R: Non-Data Hdr Enable
Q: Dual Slot Hdr Enable
P: Single Slot Hdr Enable
Link Layer control types are excluded (LL CTRL, slot NULL, LLCRD) even under specific opcode match_en cases.
Note: If Message Class is disabled, we expect opcode to also be disabled.""",
	  "Desc": "Matches on Transmit path of a UPI Port",
	  "EvSel": 4,
	  "Filter": "CtrCtrl[55:32]",
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "This event is subject to finer grain filtering.   See doc for more information.  Components (message class, opcode, local, remote, datahdr, ndatahdr, dual slot header, single slot header and pe) ANDed per Slot.   Then slots are ORed.",
	  "Umask": "bxxxx1111",
	  "UmaskExt": 0x0,
     },
     "UPI_LL.TxL_BYPASSED": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL TXQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times that an incoming flit was able to bypass the Tx flit buffer and pass directly out the UPI Link. Generally, when data is transmitted across UPI, it will bypass the TxQ and pass directly to the link.  However, the TxQ will be used with L0p and when LLR occurs, increasing latency to transfer out to the link.",
	  "Desc": "Tx Flit Buffer Bypassed",
	  "EvSel": 65,
	  "ExtSel": "",
     },
     "UPI_LL.TxL_FLITS": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Sent",
	  "EvSel": 2,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "You can OR any of 5 MSB together and apply against any combination of slots and they will be added together, but a slot MUST be selected.",
     },
     "UPI_LL.TxL_FLITS.IDLE": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Sent",
	  "EvSel": 2,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "You can OR any of 5 MSB together and apply against any combination of slots and they will be added together, but a slot MUST be selected.",
	  "Umask": "b01000111",
     },
     "UPI_LL.TxL_FLITS.SLOT0": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Sent",
	  "EvSel": 2,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "You can OR any of 5 MSB together and apply against any combination of slots and they will be added together, but a slot MUST be selected.",
	  "Umask": "bxxxxxxx1",
     },
     "UPI_LL.TxL_FLITS.NULL": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Sent",
	  "EvSel": 2,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "You can OR any of 5 MSB together and apply against any combination of slots and they will be added together, but a slot MUST be selected.",
	  "Umask": "bxx1xxxxx",
     },
     "UPI_LL.TxL_FLITS.LLCRD": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Sent",
	  "EvSel": 2,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "You can OR any of 5 MSB together and apply against any combination of slots and they will be added together, but a slot MUST be selected.",
	  "Umask": "bxxx1xxxx",
     },
     "UPI_LL.TxL_FLITS.SLOT2": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Sent",
	  "EvSel": 2,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "You can OR any of 5 MSB together and apply against any combination of slots and they will be added together, but a slot MUST be selected.",
	  "Umask": "bxxxxx1xx",
     },
     "UPI_LL.TxL_FLITS.ALL_DATA": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Sent",
	  "EvSel": 2,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "You can OR any of 5 MSB together and apply against any combination of slots and they will be added together, but a slot MUST be selected.",
	  "Umask": "b00001111",
     },
     "UPI_LL.TxL_FLITS.PROTHDR": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Sent",
	  "EvSel": 2,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "You can OR any of 5 MSB together and apply against any combination of slots and they will be added together, but a slot MUST be selected.",
	  "Umask": "b1xxxxxxx",
     },
     "UPI_LL.TxL_FLITS.ALL_NULL": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Sent",
	  "EvSel": 2,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "You can OR any of 5 MSB together and apply against any combination of slots and they will be added together, but a slot MUST be selected.",
	  "Umask": "b00100111",
     },
     "UPI_LL.TxL_FLITS.NON_DATA": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Sent",
	  "EvSel": 2,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "You can OR any of 5 MSB together and apply against any combination of slots and they will be added together, but a slot MUST be selected.",
	  "Umask": "b10010111",
     },
     "UPI_LL.TxL_FLITS.LLCTRL": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Sent",
	  "EvSel": 2,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "You can OR any of 5 MSB together and apply against any combination of slots and they will be added together, but a slot MUST be selected.",
	  "Umask": "bx1xxxxxx",
     },
     "UPI_LL.TxL_FLITS.DATA": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Sent",
	  "EvSel": 2,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "You can OR any of 5 MSB together and apply against any combination of slots and they will be added together, but a slot MUST be selected.",
	  "Umask": "bxxxx1xxx",
     },
     "UPI_LL.TxL_FLITS.SLOT1": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL Flit Events",
	  "Counters": "0-3",
	  "Defn": "Shows legal flit time (hides impact of L0p and L0c).",
	  "Desc": "Valid Flits Sent",
	  "EvSel": 2,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "You can OR any of 5 MSB together and apply against any combination of slots and they will be added together, but a slot MUST be selected.",
	  "Umask": "bxxxxxx1x",
     },
     "UPI_LL.TxL_INSERTS": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL TXQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of allocations into the UPI Tx Flit Buffer.  Generally, when data is transmitted across UPI, it will bypass the TxQ and pass directly to the link.  However, the TxQ will be used with L0p and when LLR occurs, increasing latency to transfer out to the link.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.",
	  "Desc": "Tx Flit Buffer Allocations",
	  "EvSel": 64,
	  "ExtSel": "",
     },
     "UPI_LL.TxL_OCCUPANCY": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL TXQ Events",
	  "Counters": "0-3",
	  "Defn": "Accumulates the number of flits in the TxQ.  Generally, when data is transmitted across UPI, it will bypass the TxQ and pass directly to the link.  However, the TxQ will be used with L0p and when LLR occurs, increasing latency to transfer out to the link. This can be used with the cycles not empty event to track average occupancy, or the allocations event to track average lifetime in the TxQ.",
	  "Desc": "Tx Flit Buffer Occupancy",
	  "EvSel": 66,
	  "ExtSel": "",
	  "MaxIncCyc": 32,
     },
     "UPI_LL.VNA_CREDIT_RETURN_BLOCKED_VN01": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL VNA_CREDIT_RETURN Events",
	  "Counters": "0-3",
	  "EvSel": 69,
	  "ExtSel": "",
     },
     "UPI_LL.VNA_CREDIT_RETURN_OCCUPANCY": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL VNA_CREDIT_RETURN Events",
	  "Counters": "0-3",
	  "Defn": "Number of VNA credits in the Rx side that are waitng to be returned back across the link.",
	  "Desc": "VNA Credits Pending Return - Occupancy",
	  "EvSel": 68,
	  "ExtSel": "",
	  "MaxIncCyc": 128,
     },

# CHA:
     "CHA.AG0_AD_CRD_ACQUIRED0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
     },
     "CHA.AG0_AD_CRD_ACQUIRED0.TGR4": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.AG0_AD_CRD_ACQUIRED0.TGR5": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.AG0_AD_CRD_ACQUIRED0.TGR3": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.AG0_AD_CRD_ACQUIRED0.TGR7": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.AG0_AD_CRD_ACQUIRED0.TGR6": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.AG0_AD_CRD_ACQUIRED0.TGR1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.AG0_AD_CRD_ACQUIRED0.TGR0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.AG0_AD_CRD_ACQUIRED0.TGR2": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.AG0_AD_CRD_ACQUIRED1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 129,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
     },
     "CHA.AG0_AD_CRD_ACQUIRED1.TGR8": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 129,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.AG0_AD_CRD_ACQUIRED1.TGR10": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 129,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.AG0_AD_CRD_ACQUIRED1.TGR9": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 129,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.AG0_AD_CRD_OCCUPANCY0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
     },
     "CHA.AG0_AD_CRD_OCCUPANCY0.TGR0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000001",
     },
     "CHA.AG0_AD_CRD_OCCUPANCY0.TGR1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000010",
     },
     "CHA.AG0_AD_CRD_OCCUPANCY0.TGR2": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000100",
     },
     "CHA.AG0_AD_CRD_OCCUPANCY0.TGR4": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00010000",
     },
     "CHA.AG0_AD_CRD_OCCUPANCY0.TGR5": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00100000",
     },
     "CHA.AG0_AD_CRD_OCCUPANCY0.TGR6": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b01000000",
     },
     "CHA.AG0_AD_CRD_OCCUPANCY0.TGR7": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b10000000",
     },
     "CHA.AG0_AD_CRD_OCCUPANCY0.TGR3": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00001000",
     },
     "CHA.AG0_AD_CRD_OCCUPANCY1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 131,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
     },
     "CHA.AG0_AD_CRD_OCCUPANCY1.TGR8": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 131,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000001",
     },
     "CHA.AG0_AD_CRD_OCCUPANCY1.TGR10": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 131,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000100",
     },
     "CHA.AG0_AD_CRD_OCCUPANCY1.TGR9": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 131,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000010",
     },
     "CHA.AG0_BL_CRD_ACQUIRED0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
     },
     "CHA.AG0_BL_CRD_ACQUIRED0.TGR1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.AG0_BL_CRD_ACQUIRED0.TGR0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.AG0_BL_CRD_ACQUIRED0.TGR2": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.AG0_BL_CRD_ACQUIRED0.TGR4": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.AG0_BL_CRD_ACQUIRED0.TGR5": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.AG0_BL_CRD_ACQUIRED0.TGR3": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.AG0_BL_CRD_ACQUIRED0.TGR7": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.AG0_BL_CRD_ACQUIRED0.TGR6": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.AG0_BL_CRD_ACQUIRED1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 137,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "CHA.AG0_BL_CRD_ACQUIRED1.TGR9": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 137,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.AG0_BL_CRD_ACQUIRED1.TGR10": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 137,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.AG0_BL_CRD_ACQUIRED1.TGR8": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 137,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.AG0_BL_CRD_OCCUPANCY0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
     },
     "CHA.AG0_BL_CRD_OCCUPANCY0.TGR4": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "CHA.AG0_BL_CRD_OCCUPANCY0.TGR5": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00100000",
     },
     "CHA.AG0_BL_CRD_OCCUPANCY0.TGR3": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "CHA.AG0_BL_CRD_OCCUPANCY0.TGR7": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "CHA.AG0_BL_CRD_OCCUPANCY0.TGR6": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "CHA.AG0_BL_CRD_OCCUPANCY0.TGR1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "CHA.AG0_BL_CRD_OCCUPANCY0.TGR0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "CHA.AG0_BL_CRD_OCCUPANCY0.TGR2": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "CHA.AG0_BL_CRD_OCCUPANCY1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 139,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "CHA.AG0_BL_CRD_OCCUPANCY1.TGR10": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 139,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000100",
     },
     "CHA.AG0_BL_CRD_OCCUPANCY1.TGR9": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 139,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000010",
     },
     "CHA.AG0_BL_CRD_OCCUPANCY1.TGR8": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 139,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000001",
     },
     "CHA.AG1_AD_CRD_ACQUIRED0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
     },
     "CHA.AG1_AD_CRD_ACQUIRED0.TGR4": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.AG1_AD_CRD_ACQUIRED0.TGR5": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.AG1_AD_CRD_ACQUIRED0.TGR7": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.AG1_AD_CRD_ACQUIRED0.TGR3": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.AG1_AD_CRD_ACQUIRED0.TGR6": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.AG1_AD_CRD_ACQUIRED0.TGR1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.AG1_AD_CRD_ACQUIRED0.TGR0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.AG1_AD_CRD_ACQUIRED0.TGR2": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.AG1_AD_CRD_ACQUIRED1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 133,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
     },
     "CHA.AG1_AD_CRD_ACQUIRED1.TGR8": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 133,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.AG1_AD_CRD_ACQUIRED1.TGR9": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 133,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.AG1_AD_CRD_ACQUIRED1.TGR10": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 133,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.AG1_AD_CRD_OCCUPANCY0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
     },
     "CHA.AG1_AD_CRD_OCCUPANCY0.TGR5": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00100000",
     },
     "CHA.AG1_AD_CRD_OCCUPANCY0.TGR4": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00010000",
     },
     "CHA.AG1_AD_CRD_OCCUPANCY0.TGR7": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b10000000",
     },
     "CHA.AG1_AD_CRD_OCCUPANCY0.TGR3": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00001000",
     },
     "CHA.AG1_AD_CRD_OCCUPANCY0.TGR6": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b01000000",
     },
     "CHA.AG1_AD_CRD_OCCUPANCY0.TGR1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000010",
     },
     "CHA.AG1_AD_CRD_OCCUPANCY0.TGR0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000001",
     },
     "CHA.AG1_AD_CRD_OCCUPANCY0.TGR2": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000100",
     },
     "CHA.AG1_AD_CRD_OCCUPANCY1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 135,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
     },
     "CHA.AG1_AD_CRD_OCCUPANCY1.TGR9": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 135,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000010",
     },
     "CHA.AG1_AD_CRD_OCCUPANCY1.TGR10": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 135,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000100",
     },
     "CHA.AG1_AD_CRD_OCCUPANCY1.TGR8": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 135,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000001",
     },
     "CHA.AG1_BL_CRD_ACQUIRED0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
     },
     "CHA.AG1_BL_CRD_ACQUIRED0.TGR6": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.AG1_BL_CRD_ACQUIRED0.TGR3": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.AG1_BL_CRD_ACQUIRED0.TGR7": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.AG1_BL_CRD_ACQUIRED0.TGR5": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.AG1_BL_CRD_ACQUIRED0.TGR4": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.AG1_BL_CRD_ACQUIRED0.TGR2": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.AG1_BL_CRD_ACQUIRED0.TGR0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.AG1_BL_CRD_ACQUIRED0.TGR1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.AG1_BL_CRD_ACQUIRED1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 141,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "CHA.AG1_BL_CRD_ACQUIRED1.TGR10": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 141,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.AG1_BL_CRD_ACQUIRED1.TGR9": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 141,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.AG1_BL_CRD_ACQUIRED1.TGR8": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 141,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.AG1_BL_CRD_OCCUPANCY0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
     },
     "CHA.AG1_BL_CRD_OCCUPANCY0.TGR1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "CHA.AG1_BL_CRD_OCCUPANCY0.TGR0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "CHA.AG1_BL_CRD_OCCUPANCY0.TGR2": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "CHA.AG1_BL_CRD_OCCUPANCY0.TGR4": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "CHA.AG1_BL_CRD_OCCUPANCY0.TGR5": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00100000",
     },
     "CHA.AG1_BL_CRD_OCCUPANCY0.TGR7": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "CHA.AG1_BL_CRD_OCCUPANCY0.TGR3": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "CHA.AG1_BL_CRD_OCCUPANCY0.TGR6": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "CHA.AG1_BL_CRD_OCCUPANCY1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 143,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "CHA.AG1_BL_CRD_OCCUPANCY1.TGR9": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 143,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000010",
     },
     "CHA.AG1_BL_CRD_OCCUPANCY1.TGR10": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 143,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000100",
     },
     "CHA.AG1_BL_CRD_OCCUPANCY1.TGR8": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 143,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000001",
     },
     "CHA.BYPASS_CHA_IMC": {
	  "Box": "CHA",
	  "Category": "CHA HA BYPASS Events",
	  "Defn": "Counts the number of times when the CHA was able to bypass HA pipe on the way to iMC.  This is a latency optimization for situations when there is light loadings on the memory subsystem.  This can be filtered by when the bypass was taken and when it was not.",
	  "Desc": "CHA to iMC Bypass",
	  "EvSel": 87,
	  "ExtSel": "",
     },
     "CHA.BYPASS_CHA_IMC.INTERMEDIATE": {
	  "Box": "CHA",
	  "Category": "CHA HA BYPASS Events",
	  "Defn": "Counts the number of times when the CHA was able to bypass HA pipe on the way to iMC.  This is a latency optimization for situations when there is light loadings on the memory subsystem.  This can be filtered by when the bypass was taken and when it was not.",
	  "Desc": "CHA to iMC Bypass",
	  "EvSel": 87,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.BYPASS_CHA_IMC.TAKEN": {
	  "Box": "CHA",
	  "Category": "CHA HA BYPASS Events",
	  "Defn": "Counts the number of times when the CHA was able to bypass HA pipe on the way to iMC.  This is a latency optimization for situations when there is light loadings on the memory subsystem.  This can be filtered by when the bypass was taken and when it was not.",
	  "Desc": "CHA to iMC Bypass",
	  "EvSel": 87,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.BYPASS_CHA_IMC.NOT_TAKEN": {
	  "Box": "CHA",
	  "Category": "CHA HA BYPASS Events",
	  "Defn": "Counts the number of times when the CHA was able to bypass HA pipe on the way to iMC.  This is a latency optimization for situations when there is light loadings on the memory subsystem.  This can be filtered by when the bypass was taken and when it was not.",
	  "Desc": "CHA to iMC Bypass",
	  "EvSel": 87,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.CLOCKTICKS": {
	  "Box": "CHA",
	  "Category": "CHA UCLK Events",
	  "Counters": "0-3",
	  "Desc": "Clockticks of the uncore caching and home agent (CHA)",
	  "EvSel": 0,
	  "ExtSel": "",
     },
     "CHA.CMS_CLOCKTICKS": {
	  "Box": "CHA",
	  "Category": "CHA Misc Events",
	  "Desc": "CMS Clockticks",
	  "EvSel": 192,
	  "ExtSel": "",
     },
     "CHA.CORE_SNP": {
	  "Box": "CHA",
	  "Category": "CHA ISMQ Events",
	  "Defn": "Counts the number of transactions that trigger a configurable number of cross snoops.  Cores are snooped if the transaction looks up the cache and determines that it is necessary based on the operation type and what CoreValid bits are set.  For example, if 2 CV bits are set on a data read, the cores must have the data in S state so it is not necessary to snoop them.  However, if only 1 CV bit is set the core my have modified the data.  If the transaction was an RFO, it would need to invalidate the lines.  This event can be filtered based on who triggered the initial snoop(s).",
	  "Desc": "Core Cross Snoops Issued",
	  "EvSel": 51,
	  "ExtSel": "",
     },
     "CHA.CORE_SNP.EVICT_GTONE": {
	  "Box": "CHA",
	  "Category": "CHA ISMQ Events",
	  "Defn": "Counts the number of transactions that trigger a configurable number of cross snoops.  Cores are snooped if the transaction looks up the cache and determines that it is necessary based on the operation type and what CoreValid bits are set.  For example, if 2 CV bits are set on a data read, the cores must have the data in S state so it is not necessary to snoop them.  However, if only 1 CV bit is set the core my have modified the data.  If the transaction was an RFO, it would need to invalidate the lines.  This event can be filtered based on who triggered the initial snoop(s).",
	  "Desc": "Core Cross Snoops Issued",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "b10000010",
     },
     "CHA.CORE_SNP.ANY_GTONE": {
	  "Box": "CHA",
	  "Category": "CHA ISMQ Events",
	  "Defn": "Counts the number of transactions that trigger a configurable number of cross snoops.  Cores are snooped if the transaction looks up the cache and determines that it is necessary based on the operation type and what CoreValid bits are set.  For example, if 2 CV bits are set on a data read, the cores must have the data in S state so it is not necessary to snoop them.  However, if only 1 CV bit is set the core my have modified the data.  If the transaction was an RFO, it would need to invalidate the lines.  This event can be filtered based on who triggered the initial snoop(s).",
	  "Desc": "Core Cross Snoops Issued",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "b11110010",
     },
     "CHA.CORE_SNP.ANY_ONE": {
	  "Box": "CHA",
	  "Category": "CHA ISMQ Events",
	  "Defn": "Counts the number of transactions that trigger a configurable number of cross snoops.  Cores are snooped if the transaction looks up the cache and determines that it is necessary based on the operation type and what CoreValid bits are set.  For example, if 2 CV bits are set on a data read, the cores must have the data in S state so it is not necessary to snoop them.  However, if only 1 CV bit is set the core my have modified the data.  If the transaction was an RFO, it would need to invalidate the lines.  This event can be filtered based on who triggered the initial snoop(s).",
	  "Desc": "Core Cross Snoops Issued",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "b11110001",
     },
     "CHA.CORE_SNP.CORE_GTONE": {
	  "Box": "CHA",
	  "Category": "CHA ISMQ Events",
	  "Defn": "Counts the number of transactions that trigger a configurable number of cross snoops.  Cores are snooped if the transaction looks up the cache and determines that it is necessary based on the operation type and what CoreValid bits are set.  For example, if 2 CV bits are set on a data read, the cores must have the data in S state so it is not necessary to snoop them.  However, if only 1 CV bit is set the core my have modified the data.  If the transaction was an RFO, it would need to invalidate the lines.  This event can be filtered based on who triggered the initial snoop(s).",
	  "Desc": "Core Cross Snoops Issued",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "b01000010",
     },
     "CHA.CORE_SNP.EXT_GTONE": {
	  "Box": "CHA",
	  "Category": "CHA ISMQ Events",
	  "Defn": "Counts the number of transactions that trigger a configurable number of cross snoops.  Cores are snooped if the transaction looks up the cache and determines that it is necessary based on the operation type and what CoreValid bits are set.  For example, if 2 CV bits are set on a data read, the cores must have the data in S state so it is not necessary to snoop them.  However, if only 1 CV bit is set the core my have modified the data.  If the transaction was an RFO, it would need to invalidate the lines.  This event can be filtered based on who triggered the initial snoop(s).",
	  "Desc": "Core Cross Snoops Issued",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "b00100010",
     },
     "CHA.CORE_SNP.REMOTE_GTONE": {
	  "Box": "CHA",
	  "Category": "CHA ISMQ Events",
	  "Defn": "Counts the number of transactions that trigger a configurable number of cross snoops.  Cores are snooped if the transaction looks up the cache and determines that it is necessary based on the operation type and what CoreValid bits are set.  For example, if 2 CV bits are set on a data read, the cores must have the data in S state so it is not necessary to snoop them.  However, if only 1 CV bit is set the core my have modified the data.  If the transaction was an RFO, it would need to invalidate the lines.  This event can be filtered based on who triggered the initial snoop(s).",
	  "Desc": "Core Cross Snoops Issued",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "b00100010",
     },
     "CHA.CORE_SNP.EXT_ONE": {
	  "Box": "CHA",
	  "Category": "CHA ISMQ Events",
	  "Defn": "Counts the number of transactions that trigger a configurable number of cross snoops.  Cores are snooped if the transaction looks up the cache and determines that it is necessary based on the operation type and what CoreValid bits are set.  For example, if 2 CV bits are set on a data read, the cores must have the data in S state so it is not necessary to snoop them.  However, if only 1 CV bit is set the core my have modified the data.  If the transaction was an RFO, it would need to invalidate the lines.  This event can be filtered based on who triggered the initial snoop(s).",
	  "Desc": "Core Cross Snoops Issued",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "b00100001",
     },
     "CHA.CORE_SNP.EVICT_ONE": {
	  "Box": "CHA",
	  "Category": "CHA ISMQ Events",
	  "Defn": "Counts the number of transactions that trigger a configurable number of cross snoops.  Cores are snooped if the transaction looks up the cache and determines that it is necessary based on the operation type and what CoreValid bits are set.  For example, if 2 CV bits are set on a data read, the cores must have the data in S state so it is not necessary to snoop them.  However, if only 1 CV bit is set the core my have modified the data.  If the transaction was an RFO, it would need to invalidate the lines.  This event can be filtered based on who triggered the initial snoop(s).",
	  "Desc": "Core Cross Snoops Issued",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "b10000001",
     },
     "CHA.CORE_SNP.CORE_ONE": {
	  "Box": "CHA",
	  "Category": "CHA ISMQ Events",
	  "Defn": "Counts the number of transactions that trigger a configurable number of cross snoops.  Cores are snooped if the transaction looks up the cache and determines that it is necessary based on the operation type and what CoreValid bits are set.  For example, if 2 CV bits are set on a data read, the cores must have the data in S state so it is not necessary to snoop them.  However, if only 1 CV bit is set the core my have modified the data.  If the transaction was an RFO, it would need to invalidate the lines.  This event can be filtered based on who triggered the initial snoop(s).",
	  "Desc": "Core Cross Snoops Issued",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "b01000001",
     },
     "CHA.CORE_SNP.REMOTE_ONE": {
	  "Box": "CHA",
	  "Category": "CHA ISMQ Events",
	  "Defn": "Counts the number of transactions that trigger a configurable number of cross snoops.  Cores are snooped if the transaction looks up the cache and determines that it is necessary based on the operation type and what CoreValid bits are set.  For example, if 2 CV bits are set on a data read, the cores must have the data in S state so it is not necessary to snoop them.  However, if only 1 CV bit is set the core my have modified the data.  If the transaction was an RFO, it would need to invalidate the lines.  This event can be filtered based on who triggered the initial snoop(s).",
	  "Desc": "Core Cross Snoops Issued",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "CHA.COUNTER0_OCCUPANCY": {
	  "Box": "CHA",
	  "Category": "CHA OCCUPANCY Events",
	  "Counters": "0-3",
	  "Defn": "Since occupancy counts can only be captured in the Cbo's 0 counter, this event allows a user to capture occupancy related information by filtering the Cb0 occupancy count captured in Counter 0.   The filtering available is found in the control register - threshold, invert and edge detect.   E.g. setting threshold to 1 can effectively monitor how many cycles the monitored queue has an entry.",
	  "Desc": "Counter 0 Occupancy",
	  "EvSel": 31,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
     },
     "CHA.DIRECT_GO": {
	  "Box": "CHA",
	  "Category": "CHA DIRECT GO Events",
	  "Desc": "Direct GO",
	  "EvSel": 110,
	  "ExtSel": "",
     },
     "CHA.DIRECT_GO.HA_TOR_DEALLOC": {
	  "Box": "CHA",
	  "Category": "CHA DIRECT GO Events",
	  "Desc": "Direct GO",
	  "EvSel": 110,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.DIRECT_GO.HA_SUPPRESS_DRD": {
	  "Box": "CHA",
	  "Category": "CHA DIRECT GO Events",
	  "Desc": "Direct GO",
	  "EvSel": 110,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.DIRECT_GO.HA_SUPPRESS_NO_D2C": {
	  "Box": "CHA",
	  "Category": "CHA DIRECT GO Events",
	  "Desc": "Direct GO",
	  "EvSel": 110,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.DIRECT_GO_OPC": {
	  "Box": "CHA",
	  "Category": "CHA DIRECT GO Events",
	  "Desc": "Direct GO",
	  "EvSel": 109,
	  "ExtSel": "",
     },
     "CHA.DIRECT_GO_OPC.FAST_GO": {
	  "Box": "CHA",
	  "Category": "CHA DIRECT GO Events",
	  "Desc": "Direct GO",
	  "EvSel": 109,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.DIRECT_GO_OPC.PULL": {
	  "Box": "CHA",
	  "Category": "CHA DIRECT GO Events",
	  "Desc": "Direct GO",
	  "EvSel": 109,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.DIRECT_GO_OPC.EXTCMP": {
	  "Box": "CHA",
	  "Category": "CHA DIRECT GO Events",
	  "Desc": "Direct GO",
	  "EvSel": 109,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.DIRECT_GO_OPC.IDLE_DUE_SUPPRESS": {
	  "Box": "CHA",
	  "Category": "CHA DIRECT GO Events",
	  "Desc": "Direct GO",
	  "EvSel": 109,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.DIRECT_GO_OPC.GO": {
	  "Box": "CHA",
	  "Category": "CHA DIRECT GO Events",
	  "Desc": "Direct GO",
	  "EvSel": 109,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.DIRECT_GO_OPC.FAST_GO_PULL": {
	  "Box": "CHA",
	  "Category": "CHA DIRECT GO Events",
	  "Desc": "Direct GO",
	  "EvSel": 109,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.DIRECT_GO_OPC.NOP": {
	  "Box": "CHA",
	  "Category": "CHA DIRECT GO Events",
	  "Desc": "Direct GO",
	  "EvSel": 109,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.DIRECT_GO_OPC.GO_PULL": {
	  "Box": "CHA",
	  "Category": "CHA DIRECT GO Events",
	  "Desc": "Direct GO",
	  "EvSel": 109,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.DIR_LOOKUP": {
	  "Box": "CHA",
	  "Category": "CHA HA DIRECTORY Events",
	  "Defn": "Counts the number of transactions that looked up the directory.  Can be filtered by requests that had to snoop and those that did not have to.",
	  "Desc": "Multi-socket cacheline directory state lookups",
	  "EvSel": 83,
	  "ExtSel": "",
	  "Notes": "Only valid for parts that implement the Directory",
     },
     "CHA.DIR_LOOKUP.NO_SNP": {
	  "Box": "CHA",
	  "Category": "CHA HA DIRECTORY Events",
	  "Defn": "Counts the number of transactions that looked up the directory.  Can be filtered by requests that had to snoop and those that did not have to.",
	  "Desc": "Multi-socket cacheline directory state lookups",
	  "EvSel": 83,
	  "ExtSel": "",
	  "Notes": "Only valid for parts that implement the Directory",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.DIR_LOOKUP.SNP": {
	  "Box": "CHA",
	  "Category": "CHA HA DIRECTORY Events",
	  "Defn": "Counts the number of transactions that looked up the directory.  Can be filtered by requests that had to snoop and those that did not have to.",
	  "Desc": "Multi-socket cacheline directory state lookups",
	  "EvSel": 83,
	  "ExtSel": "",
	  "Notes": "Only valid for parts that implement the Directory",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.DIR_UPDATE": {
	  "Box": "CHA",
	  "Category": "CHA HA DIRECTORY Events",
	  "Defn": "Counts the number of directory updates that were required.  These result in writes to the memory controller.  This can be filtered by directory sets and directory clears.",
	  "Desc": "Multi-socket cacheline directory state updates",
	  "EvSel": 84,
	  "ExtSel": "",
	  "Notes": "Only valid for parts that implement the Directory",
     },
     "CHA.DIR_UPDATE.HA": {
	  "Box": "CHA",
	  "Category": "CHA HA DIRECTORY Events",
	  "Defn": "Counts the number of directory updates that were required.  These result in writes to the memory controller.  This can be filtered by directory sets and directory clears.",
	  "Desc": "Multi-socket cacheline directory state updates",
	  "EvSel": 84,
	  "ExtSel": "",
	  "Notes": "Only valid for parts that implement the Directory",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.DIR_UPDATE.TOR": {
	  "Box": "CHA",
	  "Category": "CHA HA DIRECTORY Events",
	  "Defn": "Counts the number of directory updates that were required.  These result in writes to the memory controller.  This can be filtered by directory sets and directory clears.",
	  "Desc": "Multi-socket cacheline directory state updates",
	  "EvSel": 84,
	  "ExtSel": "",
	  "Notes": "Only valid for parts that implement the Directory",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.DISTRESS_ASSERTED": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
     },
     "CHA.DISTRESS_ASSERTED.PMM_NONLOCAL": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.DISTRESS_ASSERTED.VERT": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "CHA.DISTRESS_ASSERTED.DPT_NONLOCAL": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.DISTRESS_ASSERTED.HORZ": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "CHA.DISTRESS_ASSERTED.DPT_STALL_NOCRD": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.DISTRESS_ASSERTED.DPT_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.DISTRESS_ASSERTED.PMM_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.DISTRESS_ASSERTED.DPT_STALL_IV": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.EGRESS_ORDERING": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts number of cycles IV was blocked in the TGR Egress due to SNP/GO Ordering requirements",
	  "Desc": "Egress Blocking due to Ordering requirements",
	  "EvSel": 186,
	  "ExtSel": "",
     },
     "CHA.EGRESS_ORDERING.IV_SNOOPGO_DN": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts number of cycles IV was blocked in the TGR Egress due to SNP/GO Ordering requirements",
	  "Desc": "Egress Blocking due to Ordering requirements",
	  "EvSel": 186,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.EGRESS_ORDERING.IV_SNOOPGO_UP": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts number of cycles IV was blocked in the TGR Egress due to SNP/GO Ordering requirements",
	  "Desc": "Egress Blocking due to Ordering requirements",
	  "EvSel": 186,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.HITME_HIT": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Events",
	  "Desc": "Counts Number of Hits in HitMe Cache",
	  "EvSel": 95,
	  "ExtSel": "",
     },
     "CHA.HITME_HIT.WBMTOE": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Events",
	  "Desc": "Counts Number of Hits in HitMe Cache",
	  "EvSel": 95,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.HITME_HIT.WBMTOI_OR_S": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Events",
	  "Desc": "Counts Number of Hits in HitMe Cache",
	  "EvSel": 95,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.HITME_HIT.SHARED_OWNREQ": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Events",
	  "Desc": "Counts Number of Hits in HitMe Cache",
	  "EvSel": 95,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.HITME_HIT.EX_RDS": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Events",
	  "Desc": "Counts Number of Hits in HitMe Cache",
	  "EvSel": 95,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.HITME_LOOKUP": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Events",
	  "Desc": "Counts Number of times HitMe Cache is accessed",
	  "EvSel": 94,
	  "ExtSel": "",
     },
     "CHA.HITME_LOOKUP.WRITE": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Events",
	  "Desc": "Counts Number of times HitMe Cache is accessed",
	  "EvSel": 94,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.HITME_LOOKUP.READ": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Events",
	  "Desc": "Counts Number of times HitMe Cache is accessed",
	  "EvSel": 94,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.HITME_MISS": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Events",
	  "Desc": "Counts Number of Misses in HitMe Cache",
	  "EvSel": 96,
	  "ExtSel": "",
     },
     "CHA.HITME_MISS.NOTSHARED_RDINVOWN": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Events",
	  "Desc": "Counts Number of Misses in HitMe Cache",
	  "EvSel": 96,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.HITME_MISS.SHARED_RDINVOWN": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Events",
	  "Desc": "Counts Number of Misses in HitMe Cache",
	  "EvSel": 96,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.HITME_MISS.READ_OR_INV": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Events",
	  "Desc": "Counts Number of Misses in HitMe Cache",
	  "EvSel": 96,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.HITME_UPDATE": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Pipe Events",
	  "Desc": "Counts the number of Allocate/Update to HitMe Cache",
	  "EvSel": 97,
	  "ExtSel": "",
     },
     "CHA.HITME_UPDATE.RDINVOWN": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Pipe Events",
	  "Desc": "Counts the number of Allocate/Update to HitMe Cache",
	  "EvSel": 97,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.HITME_UPDATE.SHARED": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Pipe Events",
	  "Desc": "Counts the number of Allocate/Update to HitMe Cache",
	  "EvSel": 97,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.HITME_UPDATE.DEALLOCATE": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Pipe Events",
	  "Desc": "Counts the number of Allocate/Update to HitMe Cache",
	  "EvSel": 97,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.HITME_UPDATE.DEALLOCATE_RSPFWDI_LOC": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Pipe Events",
	  "Desc": "Counts the number of Allocate/Update to HitMe Cache",
	  "EvSel": 97,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.HITME_UPDATE.RSPFWDI_REM": {
	  "Box": "CHA",
	  "Category": "CHA HA HitME Pipe Events",
	  "Desc": "Counts the number of Allocate/Update to HitMe Cache",
	  "EvSel": 97,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.HORZ_RING_AD_IN_USE": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
     },
     "CHA.HORZ_RING_AD_IN_USE.RIGHT_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.HORZ_RING_AD_IN_USE.LEFT_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.HORZ_RING_AD_IN_USE.LEFT_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.HORZ_RING_AD_IN_USE.RIGHT_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.HORZ_RING_AKC_IN_USE": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
     },
     "CHA.HORZ_RING_AKC_IN_USE.LEFT_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.HORZ_RING_AKC_IN_USE.LEFT_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.HORZ_RING_AKC_IN_USE.RIGHT_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.HORZ_RING_AKC_IN_USE.RIGHT_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.HORZ_RING_AK_IN_USE": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
     },
     "CHA.HORZ_RING_AK_IN_USE.RIGHT_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.HORZ_RING_AK_IN_USE.RIGHT_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.HORZ_RING_AK_IN_USE.LEFT_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.HORZ_RING_AK_IN_USE.LEFT_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.HORZ_RING_BL_IN_USE": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
     },
     "CHA.HORZ_RING_BL_IN_USE.RIGHT_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.HORZ_RING_BL_IN_USE.LEFT_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.HORZ_RING_BL_IN_USE.LEFT_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.HORZ_RING_BL_IN_USE.RIGHT_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.HORZ_RING_IV_IN_USE": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Horizontal IV Ring in Use",
	  "EvSel": 185,
	  "ExtSel": "",
     },
     "CHA.HORZ_RING_IV_IN_USE.LEFT": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Horizontal IV Ring in Use",
	  "EvSel": 185,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.HORZ_RING_IV_IN_USE.RIGHT": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Horizontal IV Ring in Use",
	  "EvSel": 185,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.IMC_READS_COUNT": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Count of the number of reads issued to any of the memory controller channels.  This can be filtered by the priority of the reads.",
	  "Desc": "HA to iMC Reads Issued",
	  "EvSel": 89,
	  "ExtSel": "",
	  "Notes": "To match the number of reads seen at the IMC, it's necessary to account for any bypasses.   IMC_READS_COUNT.* + BYPASS_CHA_IMC.TAKEN == CAS_COUNT.RD",
     },
     "CHA.IMC_READS_COUNT.PRIORITY": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Count of the number of reads issued to any of the memory controller channels.  This can be filtered by the priority of the reads.",
	  "Desc": "HA to iMC Reads Issued",
	  "EvSel": 89,
	  "ExtSel": "",
	  "Notes": "To match the number of reads seen at the IMC, it's necessary to account for any bypasses.   IMC_READS_COUNT.* + BYPASS_CHA_IMC.TAKEN == CAS_COUNT.RD",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.IMC_READS_COUNT.NORMAL": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Count of the number of reads issued to any of the memory controller channels.  This can be filtered by the priority of the reads.",
	  "Desc": "HA to iMC Reads Issued",
	  "EvSel": 89,
	  "ExtSel": "",
	  "Notes": "To match the number of reads seen at the IMC, it's necessary to account for any bypasses.   IMC_READS_COUNT.* + BYPASS_CHA_IMC.TAKEN == CAS_COUNT.RD",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.IMC_WRITES_COUNT": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the total number of full line writes issued from the HA into the memory controller.",
	  "Desc": "CHA to iMC Full Line Writes Issued",
	  "EvSel": 91,
	  "ExtSel": "",
	  "Notes": "Directory bits are stored in memory.   Remote socket RFOs will result in a directory update which, in turn, will cause a write command.",
     },
     "CHA.IMC_WRITES_COUNT.FULL_PRIORITY": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the total number of full line writes issued from the HA into the memory controller.",
	  "Desc": "CHA to iMC Full Line Writes Issued",
	  "EvSel": 91,
	  "ExtSel": "",
	  "Notes": "Directory bits are stored in memory.   Remote socket RFOs will result in a directory update which, in turn, will cause a write command.",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.IMC_WRITES_COUNT.PARTIAL_PRIORITY": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the total number of full line writes issued from the HA into the memory controller.",
	  "Desc": "CHA to iMC Full Line Writes Issued",
	  "EvSel": 91,
	  "ExtSel": "",
	  "Notes": "Directory bits are stored in memory.   Remote socket RFOs will result in a directory update which, in turn, will cause a write command.",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.IMC_WRITES_COUNT.PARTIAL": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the total number of full line writes issued from the HA into the memory controller.",
	  "Desc": "CHA to iMC Full Line Writes Issued",
	  "EvSel": 91,
	  "ExtSel": "",
	  "Notes": "Directory bits are stored in memory.   Remote socket RFOs will result in a directory update which, in turn, will cause a write command.",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.IMC_WRITES_COUNT.FULL": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the total number of full line writes issued from the HA into the memory controller.",
	  "Desc": "CHA to iMC Full Line Writes Issued",
	  "EvSel": 91,
	  "ExtSel": "",
	  "Notes": "Directory bits are stored in memory.   Remote socket RFOs will result in a directory update which, in turn, will cause a write command.",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.LLC_LOOKUP": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
     },
     "CHA.LLC_LOOKUP.RFO": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x1BC8,
     },
     "CHA.LLC_LOOKUP.RFO_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x19C8,
     },
     "CHA.LLC_LOOKUP.FLUSH_INV_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x1A04,
     },
     "CHA.LLC_LOOKUP.F": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b1xxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxx",
     },
     "CHA.LLC_LOOKUP.E": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxx1xxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxx",
     },
     "CHA.LLC_LOOKUP.FLUSH_INV_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x1844,
     },
     "CHA.LLC_LOOKUP.DATA_READ_F": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxx1",
     },
     "CHA.LLC_LOOKUP.ANY_F": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxx1xxxxx",
     },
     "CHA.LLC_LOOKUP.CODE_READ_F": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxx1xxxx",
     },
     "CHA.LLC_LOOKUP.SF_E": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxxxxx1xx",
	  "UmaskExt": "bxxxxxxxxxxxxx",
     },
     "CHA.LLC_LOOKUP.MISS_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b00000001",
	  "UmaskExt": 0x1FE0,
     },
     "CHA.LLC_LOOKUP.RFO_MISS": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b00000001",
	  "UmaskExt": 0x1BC8,
     },
     "CHA.LLC_LOOKUP.READ": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x1BD9,
     },
     "CHA.LLC_LOOKUP.ALL_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x1E20,
     },
     "CHA.LLC_LOOKUP.S": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxxx1xxxx",
	  "UmaskExt": "bxxxxxxxxxxxxx",
     },
     "CHA.LLC_LOOKUP.READ_MISS_REM_HOM": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b00000001",
	  "UmaskExt": 0x13D9,
     },
     "CHA.LLC_LOOKUP.REMOTE_F": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "b1xxxxxxxxxxxx",
     },
     "CHA.LLC_LOOKUP.READ_SF_HIT": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b00001110",
	  "UmaskExt": 0x1BD9,
     },
     "CHA.LLC_LOOKUP.DATA_READ_MISS": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b00000001",
	  "UmaskExt": 0x1BC1,
     },
     "CHA.LLC_LOOKUP.LLCPREF_LOCAL_F": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxx1xxxxxxx",
     },
     "CHA.LLC_LOOKUP.FLUSH_INV": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x1A44,
     },
     "CHA.LLC_LOOKUP.REMOTE_SNOOP_F": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxx1xxxxxxxxxx",
     },
     "CHA.LLC_LOOKUP.LOCAL_F": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bx1xxxxxxxxxxx",
     },
     "CHA.LLC_LOOKUP.WRITES_AND_OTHER": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x1A42,
     },
     "CHA.LLC_LOOKUP.I": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxxxxxxx1",
	  "UmaskExt": "bxxxxxxxxxxxxx",
     },
     "CHA.LLC_LOOKUP.CODE_READ_MISS": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b00000001",
	  "UmaskExt": 0x1BD0,
     },
     "CHA.LLC_LOOKUP.READ_OR_SNOOP_REMOTE_MISS_REM_HOM": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b00000001",
	  "UmaskExt": 0x1619,
     },
     "CHA.LLC_LOOKUP.M": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bx1xxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxx",
     },
     "CHA.LLC_LOOKUP.OTHER_REQ_F": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxx1x",
     },
     "CHA.LLC_LOOKUP.SF_H": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxxxx1xxx",
	  "UmaskExt": "bxxxxxxxxxxxxx",
     },
     "CHA.LLC_LOOKUP.READ_REMOTE_LOC_HOM": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x0A19,
     },
     "CHA.LLC_LOOKUP.REMOTE_SNP": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x1C19,
     },
     "CHA.LLC_LOOKUP.SF_S": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxxxxxx1x",
	  "UmaskExt": "bxxxxxxxxxxxxx",
     },
     "CHA.LLC_LOOKUP.DATA_READ": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x1BC1,
     },
     "CHA.LLC_LOOKUP.PREF_OR_DMND_REMOTE_F": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxx1xxxxxxxxx",
     },
     "CHA.LLC_LOOKUP.FLUSH_OR_INV_F": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxx1xx",
     },
     "CHA.LLC_LOOKUP.LLCPREF_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x189D,
     },
     "CHA.LLC_LOOKUP.LOC_HOM": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x0BDF,
     },
     "CHA.LLC_LOOKUP.COREPREF_OR_DMND_LOCAL_F": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxx1xxxxxx",
     },
     "CHA.LLC_LOOKUP.READ_MISS": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b00000001",
	  "UmaskExt": 0x1BD9,
     },
     "CHA.LLC_LOOKUP.CODE_READ": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x1BD0,
     },
     "CHA.LLC_LOOKUP.READ_MISS_LOC_HOM": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b00000001",
	  "UmaskExt": 0x0BD9,
     },
     "CHA.LLC_LOOKUP.ALL": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x1FFF,
     },
     "CHA.LLC_LOOKUP.DATA_READ_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x1A01,
     },
     "CHA.LLC_LOOKUP.READ_LOCAL_REM_HOM": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x11D9,
     },
     "CHA.LLC_LOOKUP.DATA_READ_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x19C1,
     },
     "CHA.LLC_LOOKUP.REM_HOM": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x15DF,
     },
     "CHA.LLC_LOOKUP.CODE_READ_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x19D0,
     },
     "CHA.LLC_LOOKUP.READ_LOCAL_LOC_HOM": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x09D9,
     },
     "CHA.LLC_LOOKUP.CODE_READ_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x1A10,
     },
     "CHA.LLC_LOOKUP.RFO_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "b11111111",
	  "UmaskExt": 0x1A08,
     },
     "CHA.LLC_LOOKUP.RFO_F": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times the LLC was accessed - this includes code, data, prefetches and hints coming from L2.  This has numerous filters available.  Note the non-standard filtering equation.  This event will count requests that lookup the cache multiple times with multiple increments.  One must ALWAYS select a state or states (in the umask field) to match.  Otherwise, the event will count nothing.",
	  "Desc": "Cache Lookups",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Notes": "One of the bits in the umask, those corresponding to each cacheline state (e.g. bit0 = invalid (miss), bit4 = shared), etc,  must always be set for this event.   To monitor any lookup, set the field to 0xFF.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxx1xxx",
     },
     "CHA.LLC_VICTIMS": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of lines that were victimized on a fill.  This can be filtered by the state that the line was in.",
	  "Desc": "Lines Victimized",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Does not include evict cleans",
     },
     "CHA.LLC_VICTIMS.REMOTE_E": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of lines that were victimized on a fill.  This can be filtered by the state that the line was in.",
	  "Desc": "Lines Victimized",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Does not include evict cleans",
	  "Umask": "b00000010",
	  "UmaskExt": "b10000000",
     },
     "CHA.LLC_VICTIMS.LOCAL_E": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of lines that were victimized on a fill.  This can be filtered by the state that the line was in.",
	  "Desc": "Lines Victimized",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Does not include evict cleans",
	  "Umask": "b00000010",
	  "UmaskExt": "b00100000",
     },
     "CHA.LLC_VICTIMS.ALL": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of lines that were victimized on a fill.  This can be filtered by the state that the line was in.",
	  "Desc": "Lines Victimized",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Does not include evict cleans",
	  "Umask": "b00001111",
	  "UmaskExt": "b00000000",
     },
     "CHA.LLC_VICTIMS.E_STATE": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of lines that were victimized on a fill.  This can be filtered by the state that the line was in.",
	  "Desc": "Lines Victimized",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Does not include evict cleans",
	  "Umask": "bxxxxxx1x",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.LLC_VICTIMS.LOCAL_M": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of lines that were victimized on a fill.  This can be filtered by the state that the line was in.",
	  "Desc": "Lines Victimized",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Does not include evict cleans",
	  "Umask": "b00000001",
	  "UmaskExt": "b00100000",
     },
     "CHA.LLC_VICTIMS.REMOTE_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of lines that were victimized on a fill.  This can be filtered by the state that the line was in.",
	  "Desc": "Lines Victimized",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Does not include evict cleans",
	  "Umask": "b00001111",
	  "UmaskExt": "b10000000",
     },
     "CHA.LLC_VICTIMS.REMOTE_ONLY": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of lines that were victimized on a fill.  This can be filtered by the state that the line was in.",
	  "Desc": "Lines Victimized",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Does not include evict cleans",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "b1xxxxxxx",
     },
     "CHA.LLC_VICTIMS.REMOTE_M": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of lines that were victimized on a fill.  This can be filtered by the state that the line was in.",
	  "Desc": "Lines Victimized",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Does not include evict cleans",
	  "Umask": "b00000001",
	  "UmaskExt": "b10000000",
     },
     "CHA.LLC_VICTIMS.LOCAL_S": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of lines that were victimized on a fill.  This can be filtered by the state that the line was in.",
	  "Desc": "Lines Victimized",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Does not include evict cleans",
	  "Umask": "b00000100",
	  "UmaskExt": "b00100000",
     },
     "CHA.LLC_VICTIMS.LOCAL_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of lines that were victimized on a fill.  This can be filtered by the state that the line was in.",
	  "Desc": "Lines Victimized",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Does not include evict cleans",
	  "Umask": "b00001111",
	  "UmaskExt": "b00100000",
     },
     "CHA.LLC_VICTIMS.S_STATE": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of lines that were victimized on a fill.  This can be filtered by the state that the line was in.",
	  "Desc": "Lines Victimized",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Does not include evict cleans",
	  "Umask": "bxxxxx1xx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.LLC_VICTIMS.M_STATE": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of lines that were victimized on a fill.  This can be filtered by the state that the line was in.",
	  "Desc": "Lines Victimized",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Does not include evict cleans",
	  "Umask": "bxxxxxxx1",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.LLC_VICTIMS.LOCAL_ONLY": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of lines that were victimized on a fill.  This can be filtered by the state that the line was in.",
	  "Desc": "Lines Victimized",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Does not include evict cleans",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxx1xxxxx",
     },
     "CHA.LLC_VICTIMS.REMOTE_S": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of lines that were victimized on a fill.  This can be filtered by the state that the line was in.",
	  "Desc": "Lines Victimized",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Does not include evict cleans",
	  "Umask": "b00000100",
	  "UmaskExt": "b10000000",
     },
     "CHA.MISC": {
	  "Box": "CHA",
	  "Category": "CHA MISC Events",
	  "Counters": "0-3",
	  "Defn": "Miscellaneous events in the Cbo.",
	  "Desc": "Cbo Misc",
	  "EvSel": 57,
	  "ExtSel": "",
     },
     "CHA.MISC.WC_ALIASING": {
	  "Box": "CHA",
	  "Category": "CHA MISC Events",
	  "Counters": "0-3",
	  "Defn": "Miscellaneous events in the Cbo.",
	  "Desc": "Cbo Misc",
	  "EvSel": 57,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.MISC.CV0_PREF_VIC": {
	  "Box": "CHA",
	  "Category": "CHA MISC Events",
	  "Counters": "0-3",
	  "Defn": "Miscellaneous events in the Cbo.",
	  "Desc": "Cbo Misc",
	  "EvSel": 57,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.MISC.RFO_HIT_S": {
	  "Box": "CHA",
	  "Category": "CHA MISC Events",
	  "Counters": "0-3",
	  "Defn": "Miscellaneous events in the Cbo.",
	  "Desc": "Cbo Misc",
	  "EvSel": 57,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.MISC.CV0_PREF_MISS": {
	  "Box": "CHA",
	  "Category": "CHA MISC Events",
	  "Counters": "0-3",
	  "Defn": "Miscellaneous events in the Cbo.",
	  "Desc": "Cbo Misc",
	  "EvSel": 57,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.MISC.RSPI_WAS_FSE": {
	  "Box": "CHA",
	  "Category": "CHA MISC Events",
	  "Counters": "0-3",
	  "Defn": "Miscellaneous events in the Cbo.",
	  "Desc": "Cbo Misc",
	  "EvSel": 57,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.MISC_EXTERNAL": {
	  "Box": "CHA",
	  "Category": "CHA External Misc Events (eg. From MS2IDI)",
	  "Desc": "Miscellaneous Events (mostly from MS2IDI)",
	  "EvSel": 230,
	  "ExtSel": "",
	  "Notes": "ONLY relevant to the CHA's CMS",
     },
     "CHA.MISC_EXTERNAL.MBE_INST1": {
	  "Box": "CHA",
	  "Category": "CHA External Misc Events (eg. From MS2IDI)",
	  "Desc": "Miscellaneous Events (mostly from MS2IDI)",
	  "EvSel": 230,
	  "ExtSel": "",
	  "Notes": "ONLY relevant to the CHA's CMS",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.MISC_EXTERNAL.MBE_INST0": {
	  "Box": "CHA",
	  "Category": "CHA External Misc Events (eg. From MS2IDI)",
	  "Desc": "Miscellaneous Events (mostly from MS2IDI)",
	  "EvSel": 230,
	  "ExtSel": "",
	  "Notes": "ONLY relevant to the CHA's CMS",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.OSB": {
	  "Box": "CHA",
	  "Category": "CHA HA OSB Events",
	  "Defn": "Count of OSB snoop broadcasts. Counts by 1 per request causing OSB snoops to be broadcast. Does not count all the snoops generated by OSB.",
	  "Desc": "OSB Snoop Broadcast",
	  "EvSel": 85,
	  "ExtSel": "",
     },
     "CHA.OSB.RFO_HITS_SNP_BCAST": {
	  "Box": "CHA",
	  "Category": "CHA HA OSB Events",
	  "Defn": "Count of OSB snoop broadcasts. Counts by 1 per request causing OSB snoops to be broadcast. Does not count all the snoops generated by OSB.",
	  "Desc": "OSB Snoop Broadcast",
	  "EvSel": 85,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.OSB.REMOTE_READ": {
	  "Box": "CHA",
	  "Category": "CHA HA OSB Events",
	  "Defn": "Count of OSB snoop broadcasts. Counts by 1 per request causing OSB snoops to be broadcast. Does not count all the snoops generated by OSB.",
	  "Desc": "OSB Snoop Broadcast",
	  "EvSel": 85,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.OSB.REMOTE_READINVITOE": {
	  "Box": "CHA",
	  "Category": "CHA HA OSB Events",
	  "Defn": "Count of OSB snoop broadcasts. Counts by 1 per request causing OSB snoops to be broadcast. Does not count all the snoops generated by OSB.",
	  "Desc": "OSB Snoop Broadcast",
	  "EvSel": 85,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.OSB.LOCAL_READ": {
	  "Box": "CHA",
	  "Category": "CHA HA OSB Events",
	  "Defn": "Count of OSB snoop broadcasts. Counts by 1 per request causing OSB snoops to be broadcast. Does not count all the snoops generated by OSB.",
	  "Desc": "OSB Snoop Broadcast",
	  "EvSel": 85,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.OSB.OFF_PWRHEURISTIC": {
	  "Box": "CHA",
	  "Category": "CHA HA OSB Events",
	  "Defn": "Count of OSB snoop broadcasts. Counts by 1 per request causing OSB snoops to be broadcast. Does not count all the snoops generated by OSB.",
	  "Desc": "OSB Snoop Broadcast",
	  "EvSel": 85,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.OSB.LOCAL_INVITOE": {
	  "Box": "CHA",
	  "Category": "CHA HA OSB Events",
	  "Defn": "Count of OSB snoop broadcasts. Counts by 1 per request causing OSB snoops to be broadcast. Does not count all the snoops generated by OSB.",
	  "Desc": "OSB Snoop Broadcast",
	  "EvSel": 85,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.PIPE_REJECT": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
     },
     "CHA.PIPE_REJECT.RRQ_SETMATCH_VICP": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxx1xxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.SF_WAYS_RES": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxx1xxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.FSF_VICP": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx1x",
     },
     "CHA.PIPE_REJECT.ONE_FSF_VIC": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxxxxx1xx",
     },
     "CHA.PIPE_REJECT.LLC_WAYS_RES": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxx1xxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.VN_BL_NCB": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxx1xxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.VN_BL_RSP": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxx1xxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.PMM_MEMMODE_TORMATCH_MULTI": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxx1xxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.ISMQ_SETMATCH_VICP": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxx1xxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.NOTALLOWSNOOP": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxx1xxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.VN_AD_REQ": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxx1xxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.SETMATCHENTRYWSCT": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxx1xxxxxxxxx",
     },
     "CHA.PIPE_REJECT.IRQ_SETMATCH_VICP": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx1",
     },
     "CHA.PIPE_REJECT.VN_AD_RSP": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxx1xxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.GOTRACK_WAYMATCH": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.VN_BL_NCS": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxx1xxxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.AKEGRCREDIT": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxx1xxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.IDX_INPIPE": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxx1xxxxxxxx",
     },
     "CHA.PIPE_REJECT.GOTRACK_PAMATCH": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.GOTRACK_ALLOWSNP": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.VN_BL_WB": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxx1xxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.IPQ_SETMATCH_VICP": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxx1xxxxx",
     },
     "CHA.PIPE_REJECT.HACREDIT": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxx1xxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.IVEGRCREDIT": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxx1xxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.IRQ_PMM": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.ALLRSFWAYS_RES": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxx1xxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.ONE_RSP_CON": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxx1xxxxxxx",
     },
     "CHA.PIPE_REJECT.WAY_MATCH": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxx1xxxxxx",
     },
     "CHA.PIPE_REJECT.PRQ_PMM": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.PMM_MEMMODE_TOR_MATCH": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxxxx1xxx",
     },
     "CHA.PIPE_REJECT.RMW_SETMATCH": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.BLEGRCREDIT": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxx1xxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.GOTRACK_ALLWAYRSV": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.ADEGRCREDIT": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxx1xxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.TOPA_MATCH": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxx1xxxxxxxxxxxxxxxxx",
     },
     "CHA.PIPE_REJECT.TORID_MATCH_GO_P": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxxx1xxxx",
     },
     "CHA.PIPE_REJECT.PTL_INPIPE": {
	  "Box": "CHA",
	  "Category": "CHA PIPE REJECT Events",
	  "Counters": "0-3",
	  "Defn": "More Miscellaneous events in the Cbo.",
	  "Desc": "Pipe Rejects",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.PMM_MEMMODE_NM_INVITOX": {
	  "Box": "CHA",
	  "Category": "CHA HA PM MEMMODE Events",
	  "EvSel": 101,
	  "ExtSel": "",
     },
     "CHA.PMM_MEMMODE_NM_INVITOX.SETCONFLICT": {
	  "Box": "CHA",
	  "Category": "CHA HA PM MEMMODE Events",
	  "EvSel": 101,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.PMM_MEMMODE_NM_INVITOX.LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA HA PM MEMMODE Events",
	  "EvSel": 101,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.PMM_MEMMODE_NM_INVITOX.REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA HA PM MEMMODE Events",
	  "EvSel": 101,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.PMM_MEMMODE_NM_SETCONFLICTS": {
	  "Box": "CHA",
	  "Category": "CHA HA PM MEMMODE Events",
	  "Desc": "PMM Memory Mode related events",
	  "EvSel": 100,
	  "ExtSel": "",
     },
     "CHA.PMM_MEMMODE_NM_SETCONFLICTS.LLC": {
	  "Box": "CHA",
	  "Category": "CHA HA PM MEMMODE Events",
	  "Desc": "PMM Memory Mode related events",
	  "EvSel": 100,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.PMM_MEMMODE_NM_SETCONFLICTS.TOR": {
	  "Box": "CHA",
	  "Category": "CHA HA PM MEMMODE Events",
	  "Desc": "PMM Memory Mode related events",
	  "EvSel": 100,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.PMM_MEMMODE_NM_SETCONFLICTS.SF": {
	  "Box": "CHA",
	  "Category": "CHA HA PM MEMMODE Events",
	  "Desc": "PMM Memory Mode related events",
	  "EvSel": 100,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.PMM_MEMMODE_NM_SETCONFLICTS2": {
	  "Box": "CHA",
	  "Category": "CHA HA PM MEMMODE Events",
	  "EvSel": 112,
	  "ExtSel": "",
     },
     "CHA.PMM_MEMMODE_NM_SETCONFLICTS2.IODC": {
	  "Box": "CHA",
	  "Category": "CHA HA PM MEMMODE Events",
	  "EvSel": 112,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.PMM_MEMMODE_NM_SETCONFLICTS2.MEMWR": {
	  "Box": "CHA",
	  "Category": "CHA HA PM MEMMODE Events",
	  "EvSel": 112,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.PMM_MEMMODE_NM_SETCONFLICTS2.MEMWRNI": {
	  "Box": "CHA",
	  "Category": "CHA HA PM MEMMODE Events",
	  "EvSel": 112,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.PMM_QOS": {
	  "Box": "CHA",
	  "Category": "CHA HA PMM QOS Events",
	  "EvSel": 102,
	  "ExtSel": "",
     },
     "CHA.PMM_QOS.REJ_IRQ": {
	  "Box": "CHA",
	  "Category": "CHA HA PMM QOS Events",
	  "EvSel": 102,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.PMM_QOS.THROTTLE": {
	  "Box": "CHA",
	  "Category": "CHA HA PMM QOS Events",
	  "EvSel": 102,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.PMM_QOS.THROTTLE_PRQ": {
	  "Box": "CHA",
	  "Category": "CHA HA PMM QOS Events",
	  "EvSel": 102,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.PMM_QOS.SLOWTORQ_SKIP": {
	  "Box": "CHA",
	  "Category": "CHA HA PMM QOS Events",
	  "EvSel": 102,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.PMM_QOS.SLOW_INSERT": {
	  "Box": "CHA",
	  "Category": "CHA HA PMM QOS Events",
	  "EvSel": 102,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.PMM_QOS.THROTTLE_IRQ": {
	  "Box": "CHA",
	  "Category": "CHA HA PMM QOS Events",
	  "EvSel": 102,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.PMM_QOS.DDR4_FAST_INSERT": {
	  "Box": "CHA",
	  "Category": "CHA HA PMM QOS Events",
	  "EvSel": 102,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.PMM_QOS_OCCUPANCY": {
	  "Box": "CHA",
	  "Category": "CHA HA PMM QOS Events",
	  "EvSel": 103,
	  "ExtSel": "",
     },
     "CHA.PMM_QOS_OCCUPANCY.DDR_FAST_FIFO": {
	  "Box": "CHA",
	  "Category": "CHA HA PMM QOS Events",
	  "EvSel": 103,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.PMM_QOS_OCCUPANCY.DDR_SLOW_FIFO": {
	  "Box": "CHA",
	  "Category": "CHA HA PMM QOS Events",
	  "EvSel": 103,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.READ_NO_CREDITS": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending reads from the CHA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's AD Ingress queue.",
	  "Desc": "CHA iMC CHNx READ Credits Empty",
	  "EvSel": 88,
	  "ExtSel": "",
     },
     "CHA.READ_NO_CREDITS.MC4": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending reads from the CHA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's AD Ingress queue.",
	  "Desc": "CHA iMC CHNx READ Credits Empty",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.READ_NO_CREDITS.MC3": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending reads from the CHA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's AD Ingress queue.",
	  "Desc": "CHA iMC CHNx READ Credits Empty",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.READ_NO_CREDITS.MC13": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending reads from the CHA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's AD Ingress queue.",
	  "Desc": "CHA iMC CHNx READ Credits Empty",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxx1xxxxx",
     },
     "CHA.READ_NO_CREDITS.MC7": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending reads from the CHA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's AD Ingress queue.",
	  "Desc": "CHA iMC CHNx READ Credits Empty",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.READ_NO_CREDITS.MC10": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending reads from the CHA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's AD Ingress queue.",
	  "Desc": "CHA iMC CHNx READ Credits Empty",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxx1xx",
     },
     "CHA.READ_NO_CREDITS.MC8": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending reads from the CHA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's AD Ingress queue.",
	  "Desc": "CHA iMC CHNx READ Credits Empty",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxx1",
     },
     "CHA.READ_NO_CREDITS.MC5": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending reads from the CHA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's AD Ingress queue.",
	  "Desc": "CHA iMC CHNx READ Credits Empty",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.READ_NO_CREDITS.MC2": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending reads from the CHA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's AD Ingress queue.",
	  "Desc": "CHA iMC CHNx READ Credits Empty",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.READ_NO_CREDITS.MC9": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending reads from the CHA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's AD Ingress queue.",
	  "Desc": "CHA iMC CHNx READ Credits Empty",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxx1x",
     },
     "CHA.READ_NO_CREDITS.MC0": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending reads from the CHA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's AD Ingress queue.",
	  "Desc": "CHA iMC CHNx READ Credits Empty",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.READ_NO_CREDITS.MC1": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending reads from the CHA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's AD Ingress queue.",
	  "Desc": "CHA iMC CHNx READ Credits Empty",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.READ_NO_CREDITS.MC11": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending reads from the CHA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's AD Ingress queue.",
	  "Desc": "CHA iMC CHNx READ Credits Empty",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxx1xxx",
     },
     "CHA.READ_NO_CREDITS.MC12": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending reads from the CHA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's AD Ingress queue.",
	  "Desc": "CHA iMC CHNx READ Credits Empty",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxx1xxxx",
     },
     "CHA.READ_NO_CREDITS.MC6": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending reads from the CHA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's AD Ingress queue.",
	  "Desc": "CHA iMC CHNx READ Credits Empty",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.REQUESTS": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Counters": "0-3",
	  "Defn": "Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).",
	  "Desc": "HA Read and Write Requests",
	  "EvSel": 80,
	  "ExtSel": "",
     },
     "CHA.REQUESTS.INVITOE_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Counters": "0-3",
	  "Defn": "Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).",
	  "Desc": "HA Read and Write Requests",
	  "EvSel": 80,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.REQUESTS.WRITES_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Counters": "0-3",
	  "Defn": "Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).",
	  "Desc": "HA Read and Write Requests",
	  "EvSel": 80,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.REQUESTS.INVITOE_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Counters": "0-3",
	  "Defn": "Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).",
	  "Desc": "HA Read and Write Requests",
	  "EvSel": 80,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.REQUESTS.READS_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Counters": "0-3",
	  "Defn": "Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).",
	  "Desc": "HA Read and Write Requests",
	  "EvSel": 80,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.REQUESTS.WRITES": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Counters": "0-3",
	  "Defn": "Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).",
	  "Desc": "HA Read and Write Requests",
	  "EvSel": 80,
	  "ExtSel": "",
	  "Umask": "b00001100",
     },
     "CHA.REQUESTS.READS_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Counters": "0-3",
	  "Defn": "Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).",
	  "Desc": "HA Read and Write Requests",
	  "EvSel": 80,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.REQUESTS.INVITOE": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Counters": "0-3",
	  "Defn": "Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).",
	  "Desc": "HA Read and Write Requests",
	  "EvSel": 80,
	  "ExtSel": "",
	  "Umask": "b00110000",
     },
     "CHA.REQUESTS.WRITES_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Counters": "0-3",
	  "Defn": "Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).",
	  "Desc": "HA Read and Write Requests",
	  "EvSel": 80,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.REQUESTS.READS": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Counters": "0-3",
	  "Defn": "Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).",
	  "Desc": "HA Read and Write Requests",
	  "EvSel": 80,
	  "ExtSel": "",
	  "Umask": "b00000011",
     },
     "CHA.RING_BOUNCES_HORZ": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
     },
     "CHA.RING_BOUNCES_HORZ.AK": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RING_BOUNCES_HORZ.BL": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RING_BOUNCES_HORZ.IV": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RING_BOUNCES_HORZ.AD": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RING_BOUNCES_VERT": {
	  "Box": "CHA",
	  "Category": "CHA Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
     },
     "CHA.RING_BOUNCES_VERT.AD": {
	  "Box": "CHA",
	  "Category": "CHA Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RING_BOUNCES_VERT.IV": {
	  "Box": "CHA",
	  "Category": "CHA Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RING_BOUNCES_VERT.BL": {
	  "Box": "CHA",
	  "Category": "CHA Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RING_BOUNCES_VERT.AKC": {
	  "Box": "CHA",
	  "Category": "CHA Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RING_BOUNCES_VERT.AK": {
	  "Box": "CHA",
	  "Category": "CHA Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RING_SINK_STARVED_HORZ": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
     },
     "CHA.RING_SINK_STARVED_HORZ.AD": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RING_SINK_STARVED_HORZ.IV": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RING_SINK_STARVED_HORZ.BL": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RING_SINK_STARVED_HORZ.AK_AG1": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RING_SINK_STARVED_HORZ.AK": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RING_SINK_STARVED_VERT": {
	  "Box": "CHA",
	  "Category": "CHA Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
     },
     "CHA.RING_SINK_STARVED_VERT.AKC": {
	  "Box": "CHA",
	  "Category": "CHA Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RING_SINK_STARVED_VERT.AK": {
	  "Box": "CHA",
	  "Category": "CHA Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RING_SINK_STARVED_VERT.IV": {
	  "Box": "CHA",
	  "Category": "CHA Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RING_SINK_STARVED_VERT.BL": {
	  "Box": "CHA",
	  "Category": "CHA Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RING_SINK_STARVED_VERT.AD": {
	  "Box": "CHA",
	  "Category": "CHA Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RING_SRC_THRTL": {
	  "Box": "CHA",
	  "Category": "CHA Horizontal  RING Events",
	  "Desc": "Source Throttle",
	  "EvSel": 174,
	  "ExtSel": "",
     },
     "CHA.RxC_INSERTS": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts number of allocations per cycle into the specified Ingress queue.",
	  "Desc": "Ingress (from CMS) Allocations",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Notes": "IRQ_REJECTED should not be Ored with the other umasks.",
     },
     "CHA.RxC_INSERTS.RRQ": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts number of allocations per cycle into the specified Ingress queue.",
	  "Desc": "Ingress (from CMS) Allocations",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Notes": "IRQ_REJECTED should not be Ored with the other umasks.",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.RxC_INSERTS.IPQ": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts number of allocations per cycle into the specified Ingress queue.",
	  "Desc": "Ingress (from CMS) Allocations",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Notes": "IRQ_REJECTED should not be Ored with the other umasks.",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RxC_INSERTS.PRQ": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts number of allocations per cycle into the specified Ingress queue.",
	  "Desc": "Ingress (from CMS) Allocations",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Notes": "IRQ_REJECTED should not be Ored with the other umasks.",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RxC_INSERTS.PRQ_REJ": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts number of allocations per cycle into the specified Ingress queue.",
	  "Desc": "Ingress (from CMS) Allocations",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Notes": "IRQ_REJECTED should not be Ored with the other umasks.",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RxC_INSERTS.IRQ": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts number of allocations per cycle into the specified Ingress queue.",
	  "Desc": "Ingress (from CMS) Allocations",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Notes": "IRQ_REJECTED should not be Ored with the other umasks.",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_INSERTS.IRQ_REJ": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts number of allocations per cycle into the specified Ingress queue.",
	  "Desc": "Ingress (from CMS) Allocations",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Notes": "IRQ_REJECTED should not be Ored with the other umasks.",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_INSERTS.WBQ": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts number of allocations per cycle into the specified Ingress queue.",
	  "Desc": "Ingress (from CMS) Allocations",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Notes": "IRQ_REJECTED should not be Ored with the other umasks.",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.RxC_IPQ0_REJECT": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 34,
	  "ExtSel": "",
     },
     "CHA.RxC_IPQ0_REJECT.AD_REQ_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 34,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_IPQ0_REJECT.AD_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 34,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_IPQ0_REJECT.AK_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 34,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.RxC_IPQ0_REJECT.BL_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 34,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RxC_IPQ0_REJECT.BL_NCS_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 34,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RxC_IPQ0_REJECT.BL_NCB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 34,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RxC_IPQ0_REJECT.BL_WB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 34,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RxC_IPQ0_REJECT.IV_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 34,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.RxC_IPQ1_REJECT": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 35,
	  "ExtSel": "",
     },
     "CHA.RxC_IPQ1_REJECT.PA_MATCH": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.RxC_IPQ1_REJECT.ANY0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_IPQ1_REJECT.VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RxC_IPQ1_REJECT.LLC_VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RxC_IPQ1_REJECT.LLC_OR_SF_WAY": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RxC_IPQ1_REJECT.SF_VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RxC_IPQ1_REJECT.HA": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_IPQ1_REJECT.ALLOW_SNP": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IPQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.RxC_IRQ0_REJECT": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 24,
	  "ExtSel": "",
     },
     "CHA.RxC_IRQ0_REJECT.BL_WB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RxC_IRQ0_REJECT.IV_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.RxC_IRQ0_REJECT.BL_NCB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RxC_IRQ0_REJECT.AK_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.RxC_IRQ0_REJECT.BL_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RxC_IRQ0_REJECT.BL_NCS_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RxC_IRQ0_REJECT.AD_REQ_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_IRQ0_REJECT.AD_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_IRQ1_REJECT": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 25,
	  "ExtSel": "",
     },
     "CHA.RxC_IRQ1_REJECT.PA_MATCH": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.RxC_IRQ1_REJECT.ANY0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_IRQ1_REJECT.VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RxC_IRQ1_REJECT.LLC_VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RxC_IRQ1_REJECT.LLC_OR_SF_WAY": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RxC_IRQ1_REJECT.SF_VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RxC_IRQ1_REJECT.HA": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_IRQ1_REJECT.ALLOW_SNP": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "IRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.RxC_ISMQ0_REJECT": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Rejects - Set 0",
	  "EvSel": 36,
	  "ExtSel": "",
     },
     "CHA.RxC_ISMQ0_REJECT.IV_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Rejects - Set 0",
	  "EvSel": 36,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.RxC_ISMQ0_REJECT.BL_WB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Rejects - Set 0",
	  "EvSel": 36,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RxC_ISMQ0_REJECT.BL_NCB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Rejects - Set 0",
	  "EvSel": 36,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RxC_ISMQ0_REJECT.BL_NCS_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Rejects - Set 0",
	  "EvSel": 36,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RxC_ISMQ0_REJECT.AK_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Rejects - Set 0",
	  "EvSel": 36,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.RxC_ISMQ0_REJECT.BL_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Rejects - Set 0",
	  "EvSel": 36,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RxC_ISMQ0_REJECT.AD_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Rejects - Set 0",
	  "EvSel": 36,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_ISMQ0_REJECT.AD_REQ_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Rejects - Set 0",
	  "EvSel": 36,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_ISMQ0_RETRY": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Retries - Set 0",
	  "EvSel": 44,
	  "ExtSel": "",
     },
     "CHA.RxC_ISMQ0_RETRY.BL_WB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Retries - Set 0",
	  "EvSel": 44,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RxC_ISMQ0_RETRY.IV_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Retries - Set 0",
	  "EvSel": 44,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.RxC_ISMQ0_RETRY.BL_NCB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Retries - Set 0",
	  "EvSel": 44,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RxC_ISMQ0_RETRY.AK_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Retries - Set 0",
	  "EvSel": 44,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.RxC_ISMQ0_RETRY.BL_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Retries - Set 0",
	  "EvSel": 44,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RxC_ISMQ0_RETRY.BL_NCS_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Retries - Set 0",
	  "EvSel": 44,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RxC_ISMQ0_RETRY.AD_REQ_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Retries - Set 0",
	  "EvSel": 44,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_ISMQ0_RETRY.AD_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Retries - Set 0",
	  "EvSel": 44,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_ISMQ1_REJECT": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Rejects - Set 1",
	  "EvSel": 37,
	  "ExtSel": "",
     },
     "CHA.RxC_ISMQ1_REJECT.ANY0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Rejects - Set 1",
	  "EvSel": 37,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_ISMQ1_REJECT.HA": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Rejects - Set 1",
	  "EvSel": 37,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_ISMQ1_RETRY": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Retries - Set 1",
	  "EvSel": 45,
	  "ExtSel": "",
     },
     "CHA.RxC_ISMQ1_RETRY.HA": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Retries - Set 1",
	  "EvSel": 45,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_ISMQ1_RETRY.ANY0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the ISMQ had to retry.  Transaction pass through the ISMQ as responses for requests that already exist in the Cbo.  Some examples include: when data is returned or when snoop responses come back from the cores.",
	  "Desc": "ISMQ Retries - Set 1",
	  "EvSel": 45,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_OCCUPANCY": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Counters": 0,
	  "Defn": "Counts number of entries in the specified Ingress queue in each cycle.",
	  "Desc": "Ingress (from CMS) Occupancy",
	  "EvSel": 17,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "IRQ_REJECTED should not be Ored with the other umasks.",
     },
     "CHA.RxC_OCCUPANCY.IRQ": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Counters": 0,
	  "Defn": "Counts number of entries in the specified Ingress queue in each cycle.",
	  "Desc": "Ingress (from CMS) Occupancy",
	  "EvSel": 17,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "IRQ_REJECTED should not be Ored with the other umasks.",
	  "Umask": "b00000001",
     },
     "CHA.RxC_OCCUPANCY.WBQ": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Counters": 0,
	  "Defn": "Counts number of entries in the specified Ingress queue in each cycle.",
	  "Desc": "Ingress (from CMS) Occupancy",
	  "EvSel": 17,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "IRQ_REJECTED should not be Ored with the other umasks.",
	  "Umask": "b10000000",
     },
     "CHA.RxC_OCCUPANCY.RRQ": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Counters": 0,
	  "Defn": "Counts number of entries in the specified Ingress queue in each cycle.",
	  "Desc": "Ingress (from CMS) Occupancy",
	  "EvSel": 17,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "IRQ_REJECTED should not be Ored with the other umasks.",
	  "Umask": "b01000000",
     },
     "CHA.RxC_OCCUPANCY.IPQ": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Counters": 0,
	  "Defn": "Counts number of entries in the specified Ingress queue in each cycle.",
	  "Desc": "Ingress (from CMS) Occupancy",
	  "EvSel": 17,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "IRQ_REJECTED should not be Ored with the other umasks.",
	  "Umask": "b00000100",
     },
     "CHA.RxC_OTHER0_RETRY": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 0",
	  "EvSel": 46,
	  "ExtSel": "",
     },
     "CHA.RxC_OTHER0_RETRY.BL_NCB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 0",
	  "EvSel": 46,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RxC_OTHER0_RETRY.BL_WB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 0",
	  "EvSel": 46,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RxC_OTHER0_RETRY.IV_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 0",
	  "EvSel": 46,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.RxC_OTHER0_RETRY.AD_REQ_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 0",
	  "EvSel": 46,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_OTHER0_RETRY.AD_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 0",
	  "EvSel": 46,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_OTHER0_RETRY.AK_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 0",
	  "EvSel": 46,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.RxC_OTHER0_RETRY.BL_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 0",
	  "EvSel": 46,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RxC_OTHER0_RETRY.BL_NCS_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 0",
	  "EvSel": 46,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RxC_OTHER1_RETRY": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 1",
	  "EvSel": 47,
	  "ExtSel": "",
     },
     "CHA.RxC_OTHER1_RETRY.PA_MATCH": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 1",
	  "EvSel": 47,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.RxC_OTHER1_RETRY.ANY0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 1",
	  "EvSel": 47,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_OTHER1_RETRY.VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 1",
	  "EvSel": 47,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RxC_OTHER1_RETRY.LLC_VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 1",
	  "EvSel": 47,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RxC_OTHER1_RETRY.LLC_OR_SF_WAY": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 1",
	  "EvSel": 47,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RxC_OTHER1_RETRY.SF_VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 1",
	  "EvSel": 47,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RxC_OTHER1_RETRY.HA": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 1",
	  "EvSel": 47,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_OTHER1_RETRY.ALLOW_SNP": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Retry Queue Inserts of Transactions that were already in another Retry Q (sub-events encode the reason for the next reject)",
	  "Desc": "Other Retries - Set 1",
	  "EvSel": 47,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.RxC_PRQ0_REJECT": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 32,
	  "ExtSel": "",
     },
     "CHA.RxC_PRQ0_REJECT.BL_WB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RxC_PRQ0_REJECT.IV_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.RxC_PRQ0_REJECT.BL_NCB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RxC_PRQ0_REJECT.AK_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.RxC_PRQ0_REJECT.BL_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RxC_PRQ0_REJECT.BL_NCS_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RxC_PRQ0_REJECT.AD_REQ_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_PRQ0_REJECT.AD_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 0",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_PRQ1_REJECT": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 33,
	  "ExtSel": "",
     },
     "CHA.RxC_PRQ1_REJECT.ALLOW_SNP": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.RxC_PRQ1_REJECT.SF_VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RxC_PRQ1_REJECT.HA": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_PRQ1_REJECT.LLC_OR_SF_WAY": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RxC_PRQ1_REJECT.LLC_VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RxC_PRQ1_REJECT.VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RxC_PRQ1_REJECT.ANY0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_PRQ1_REJECT.PA_MATCH": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Desc": "PRQ Requests (from CMS) Rejected - Set 1",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.RxC_REQ_Q0_RETRY": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 0",
	  "EvSel": 42,
	  "ExtSel": "",
     },
     "CHA.RxC_REQ_Q0_RETRY.BL_NCB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 0",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RxC_REQ_Q0_RETRY.BL_WB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 0",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RxC_REQ_Q0_RETRY.IV_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 0",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.RxC_REQ_Q0_RETRY.AD_REQ_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 0",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_REQ_Q0_RETRY.AD_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 0",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_REQ_Q0_RETRY.AK_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 0",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.RxC_REQ_Q0_RETRY.BL_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 0",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RxC_REQ_Q0_RETRY.BL_NCS_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 0",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RxC_REQ_Q1_RETRY": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 1",
	  "EvSel": 43,
	  "ExtSel": "",
     },
     "CHA.RxC_REQ_Q1_RETRY.LLC_OR_SF_WAY": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 1",
	  "EvSel": 43,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RxC_REQ_Q1_RETRY.SF_VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 1",
	  "EvSel": 43,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RxC_REQ_Q1_RETRY.HA": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 1",
	  "EvSel": 43,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_REQ_Q1_RETRY.ALLOW_SNP": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 1",
	  "EvSel": 43,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.RxC_REQ_Q1_RETRY.PA_MATCH": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 1",
	  "EvSel": 43,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.RxC_REQ_Q1_RETRY.ANY0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 1",
	  "EvSel": 43,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_REQ_Q1_RETRY.VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 1",
	  "EvSel": 43,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RxC_REQ_Q1_RETRY.LLC_VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "\"REQUESTQ\" includes:  IRQ, PRQ, IPQ, RRQ, WBQ (everything except for ISMQ)",
	  "Desc": "Request Queue Retries - Set 1",
	  "EvSel": 43,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RxC_RRQ0_REJECT": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 0",
	  "EvSel": 38,
	  "ExtSel": "",
     },
     "CHA.RxC_RRQ0_REJECT.IV_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 0",
	  "EvSel": 38,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.RxC_RRQ0_REJECT.BL_WB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 0",
	  "EvSel": 38,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RxC_RRQ0_REJECT.BL_NCB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 0",
	  "EvSel": 38,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RxC_RRQ0_REJECT.BL_NCS_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 0",
	  "EvSel": 38,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RxC_RRQ0_REJECT.AK_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 0",
	  "EvSel": 38,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.RxC_RRQ0_REJECT.BL_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 0",
	  "EvSel": 38,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RxC_RRQ0_REJECT.AD_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 0",
	  "EvSel": 38,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_RRQ0_REJECT.AD_REQ_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 0",
	  "EvSel": 38,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_RRQ1_REJECT": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 1",
	  "EvSel": 39,
	  "ExtSel": "",
     },
     "CHA.RxC_RRQ1_REJECT.LLC_OR_SF_WAY": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 1",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RxC_RRQ1_REJECT.SF_VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 1",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RxC_RRQ1_REJECT.HA": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 1",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_RRQ1_REJECT.ALLOW_SNP": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 1",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.RxC_RRQ1_REJECT.PA_MATCH": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 1",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.RxC_RRQ1_REJECT.ANY0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 1",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_RRQ1_REJECT.VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 1",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RxC_RRQ1_REJECT.LLC_VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the RRQ (Remote Response Queue) had to retry.",
	  "Desc": "RRQ Rejects - Set 1",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RxC_WBQ0_REJECT": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 0",
	  "EvSel": 40,
	  "ExtSel": "",
     },
     "CHA.RxC_WBQ0_REJECT.AD_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 0",
	  "EvSel": 40,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_WBQ0_REJECT.AD_REQ_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 0",
	  "EvSel": 40,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_WBQ0_REJECT.BL_NCS_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 0",
	  "EvSel": 40,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RxC_WBQ0_REJECT.AK_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 0",
	  "EvSel": 40,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.RxC_WBQ0_REJECT.BL_RSP_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 0",
	  "EvSel": 40,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RxC_WBQ0_REJECT.BL_NCB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 0",
	  "EvSel": 40,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RxC_WBQ0_REJECT.IV_NON_UPI": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 0",
	  "EvSel": 40,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.RxC_WBQ0_REJECT.BL_WB_VN0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 0",
	  "EvSel": 40,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RxC_WBQ1_REJECT": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 1",
	  "EvSel": 41,
	  "ExtSel": "",
     },
     "CHA.RxC_WBQ1_REJECT.LLC_OR_SF_WAY": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 1",
	  "EvSel": 41,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.RxC_WBQ1_REJECT.ALLOW_SNP": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 1",
	  "EvSel": 41,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.RxC_WBQ1_REJECT.SF_VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 1",
	  "EvSel": 41,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.RxC_WBQ1_REJECT.HA": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 1",
	  "EvSel": 41,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.RxC_WBQ1_REJECT.ANY0": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 1",
	  "EvSel": 41,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.RxC_WBQ1_REJECT.PA_MATCH": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 1",
	  "EvSel": 41,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.RxC_WBQ1_REJECT.LLC_VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 1",
	  "EvSel": 41,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.RxC_WBQ1_REJECT.VICTIM": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS_RETRY Events",
	  "Defn": "Number of times a transaction flowing through the WBQ (Writeback Queue) had to retry.",
	  "Desc": "WBQ Rejects - Set 1",
	  "EvSel": 41,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.RxR_BUSY_STARVED": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
     },
     "CHA.RxR_BUSY_STARVED.BL_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "CHA.RxR_BUSY_STARVED.AD_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "CHA.RxR_BUSY_STARVED.AD_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "CHA.RxR_BUSY_STARVED.BL_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000000",
     },
     "CHA.RxR_BUSY_STARVED.BL_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "CHA.RxR_BUSY_STARVED.AD_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "CHA.RxR_BYPASS": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
     },
     "CHA.RxR_BYPASS.AD_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "CHA.RxR_BYPASS.BL_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "CHA.RxR_BYPASS.AK": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000010",
     },
     "CHA.RxR_BYPASS.AD_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "CHA.RxR_BYPASS.BL_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000000",
     },
     "CHA.RxR_BYPASS.AD_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "CHA.RxR_BYPASS.BL_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "CHA.RxR_BYPASS.AKC_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b10000000",
     },
     "CHA.RxR_BYPASS.IV": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00001000",
     },
     "CHA.RxR_CRD_STARVED": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
     },
     "CHA.RxR_CRD_STARVED.AK": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00000010",
     },
     "CHA.RxR_CRD_STARVED.AD_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "CHA.RxR_CRD_STARVED.IFV": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b10000000",
     },
     "CHA.RxR_CRD_STARVED.BL_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b01000000",
     },
     "CHA.RxR_CRD_STARVED.AD_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "CHA.RxR_CRD_STARVED.BL_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "CHA.RxR_CRD_STARVED.BL_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "CHA.RxR_CRD_STARVED.IV": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00001000",
     },
     "CHA.RxR_CRD_STARVED.AD_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "CHA.RxR_CRD_STARVED_1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 228,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
     },
     "CHA.RxR_INSERTS": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
     },
     "CHA.RxR_INSERTS.AD_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "CHA.RxR_INSERTS.BL_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "CHA.RxR_INSERTS.AKC_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b10000000",
     },
     "CHA.RxR_INSERTS.IV": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00001000",
     },
     "CHA.RxR_INSERTS.BL_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "CHA.RxR_INSERTS.AD_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "CHA.RxR_INSERTS.BL_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000000",
     },
     "CHA.RxR_INSERTS.AK": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000010",
     },
     "CHA.RxR_INSERTS.AD_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "CHA.RxR_OCCUPANCY": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
     },
     "CHA.RxR_OCCUPANCY.BL_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00100000",
     },
     "CHA.RxR_OCCUPANCY.AD_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "CHA.RxR_OCCUPANCY.AK": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000010",
     },
     "CHA.RxR_OCCUPANCY.BL_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "CHA.RxR_OCCUPANCY.AD_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "CHA.RxR_OCCUPANCY.AKC_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b10000000",
     },
     "CHA.RxR_OCCUPANCY.BL_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "CHA.RxR_OCCUPANCY.IV": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00001000",
     },
     "CHA.RxR_OCCUPANCY.AD_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "CHA.SF_EVICTION": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Defn": "Counts number of times a snoop filter entry was evicted, due to lack of space, and replaced with a new entry.",
	  "Desc": "Snoop Filter Capacity Evictions",
	  "EvSel": 61,
	  "ExtSel": "",
	  "Notes": "For cache lines this CHA has some responsibility for managing, the snoop filter tracks their state in the Cores. Does not count clean evictions",
     },
     "CHA.SF_EVICTION.S_STATE": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Defn": "Counts number of times a snoop filter entry was evicted, due to lack of space, and replaced with a new entry.",
	  "Desc": "Snoop Filter Capacity Evictions",
	  "EvSel": 61,
	  "ExtSel": "",
	  "Notes": "For cache lines this CHA has some responsibility for managing, the snoop filter tracks their state in the Cores. Does not count clean evictions",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.SF_EVICTION.M_STATE": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Defn": "Counts number of times a snoop filter entry was evicted, due to lack of space, and replaced with a new entry.",
	  "Desc": "Snoop Filter Capacity Evictions",
	  "EvSel": 61,
	  "ExtSel": "",
	  "Notes": "For cache lines this CHA has some responsibility for managing, the snoop filter tracks their state in the Cores. Does not count clean evictions",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.SF_EVICTION.E_STATE": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Defn": "Counts number of times a snoop filter entry was evicted, due to lack of space, and replaced with a new entry.",
	  "Desc": "Snoop Filter Capacity Evictions",
	  "EvSel": 61,
	  "ExtSel": "",
	  "Notes": "For cache lines this CHA has some responsibility for managing, the snoop filter tracks their state in the Cores. Does not count clean evictions",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.SNOOPS_SENT": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Defn": "Counts the number of snoops issued by the HA.",
	  "Desc": "Snoops Sent",
	  "EvSel": 81,
	  "ExtSel": "",
     },
     "CHA.SNOOPS_SENT.DIRECT_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Defn": "Counts the number of snoops issued by the HA.",
	  "Desc": "Snoops Sent",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.SNOOPS_SENT.LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Defn": "Counts the number of snoops issued by the HA.",
	  "Desc": "Snoops Sent",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.SNOOPS_SENT.REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Defn": "Counts the number of snoops issued by the HA.",
	  "Desc": "Snoops Sent",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.SNOOPS_SENT.DIRECT_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Defn": "Counts the number of snoops issued by the HA.",
	  "Desc": "Snoops Sent",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.SNOOPS_SENT.ALL": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Defn": "Counts the number of snoops issued by the HA.",
	  "Desc": "Snoops Sent",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.SNOOPS_SENT.BCST_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Defn": "Counts the number of snoops issued by the HA.",
	  "Desc": "Snoops Sent",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.SNOOPS_SENT.BCST_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Defn": "Counts the number of snoops issued by the HA.",
	  "Desc": "Snoops Sent",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.SNOOP_RESP": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Counts the total number of RspI snoop responses received.  Whenever a snoops are issued, one or more snoop responses will be returned depending on the topology of the system.   In systems larger than 2s, when multiple snoops are returned this will count all the snoops that are received.  For example, if 3 snoops were issued and returned RspI, RspS, and RspSFwd; then each of these sub-events would increment by 1.",
	  "Desc": "Snoop Responses Received",
	  "EvSel": 92,
	  "ExtSel": "",
     },
     "CHA.SNOOP_RESP.RSPS": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Counts the total number of RspI snoop responses received.  Whenever a snoops are issued, one or more snoop responses will be returned depending on the topology of the system.   In systems larger than 2s, when multiple snoops are returned this will count all the snoops that are received.  For example, if 3 snoops were issued and returned RspI, RspS, and RspSFwd; then each of these sub-events would increment by 1.",
	  "Desc": "Snoop Responses Received",
	  "EvSel": 92,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.SNOOP_RESP.RSPFWD": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Counts the total number of RspI snoop responses received.  Whenever a snoops are issued, one or more snoop responses will be returned depending on the topology of the system.   In systems larger than 2s, when multiple snoops are returned this will count all the snoops that are received.  For example, if 3 snoops were issued and returned RspI, RspS, and RspSFwd; then each of these sub-events would increment by 1.",
	  "Desc": "Snoop Responses Received",
	  "EvSel": 92,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.SNOOP_RESP.RSPCNFLCT": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Counts the total number of RspI snoop responses received.  Whenever a snoops are issued, one or more snoop responses will be returned depending on the topology of the system.   In systems larger than 2s, when multiple snoops are returned this will count all the snoops that are received.  For example, if 3 snoops were issued and returned RspI, RspS, and RspSFwd; then each of these sub-events would increment by 1.",
	  "Desc": "Snoop Responses Received",
	  "EvSel": 92,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.SNOOP_RESP.RSPSFWD": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Counts the total number of RspI snoop responses received.  Whenever a snoops are issued, one or more snoop responses will be returned depending on the topology of the system.   In systems larger than 2s, when multiple snoops are returned this will count all the snoops that are received.  For example, if 3 snoops were issued and returned RspI, RspS, and RspSFwd; then each of these sub-events would increment by 1.",
	  "Desc": "Snoop Responses Received",
	  "EvSel": 92,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.SNOOP_RESP.RSPWB": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Counts the total number of RspI snoop responses received.  Whenever a snoops are issued, one or more snoop responses will be returned depending on the topology of the system.   In systems larger than 2s, when multiple snoops are returned this will count all the snoops that are received.  For example, if 3 snoops were issued and returned RspI, RspS, and RspSFwd; then each of these sub-events would increment by 1.",
	  "Desc": "Snoop Responses Received",
	  "EvSel": 92,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.SNOOP_RESP.RSPIFWD": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Counts the total number of RspI snoop responses received.  Whenever a snoops are issued, one or more snoop responses will be returned depending on the topology of the system.   In systems larger than 2s, when multiple snoops are returned this will count all the snoops that are received.  For example, if 3 snoops were issued and returned RspI, RspS, and RspSFwd; then each of these sub-events would increment by 1.",
	  "Desc": "Snoop Responses Received",
	  "EvSel": 92,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.SNOOP_RESP.RSPI": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Counts the total number of RspI snoop responses received.  Whenever a snoops are issued, one or more snoop responses will be returned depending on the topology of the system.   In systems larger than 2s, when multiple snoops are returned this will count all the snoops that are received.  For example, if 3 snoops were issued and returned RspI, RspS, and RspSFwd; then each of these sub-events would increment by 1.",
	  "Desc": "Snoop Responses Received",
	  "EvSel": 92,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.SNOOP_RESP.RSPFWDWB": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Counts the total number of RspI snoop responses received.  Whenever a snoops are issued, one or more snoop responses will be returned depending on the topology of the system.   In systems larger than 2s, when multiple snoops are returned this will count all the snoops that are received.  For example, if 3 snoops were issued and returned RspI, RspS, and RspSFwd; then each of these sub-events would increment by 1.",
	  "Desc": "Snoop Responses Received",
	  "EvSel": 92,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.SNOOP_RESP_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Number of snoop responses received for a Local  request",
	  "Desc": "Snoop Responses Received Local",
	  "EvSel": 93,
	  "ExtSel": "",
     },
     "CHA.SNOOP_RESP_LOCAL.RSPIFWD": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Number of snoop responses received for a Local  request",
	  "Desc": "Snoop Responses Received Local",
	  "EvSel": 93,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.SNOOP_RESP_LOCAL.RSPWB": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Number of snoop responses received for a Local  request",
	  "Desc": "Snoop Responses Received Local",
	  "EvSel": 93,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.SNOOP_RESP_LOCAL.RSPFWDWB": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Number of snoop responses received for a Local  request",
	  "Desc": "Snoop Responses Received Local",
	  "EvSel": 93,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.SNOOP_RESP_LOCAL.RSPI": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Number of snoop responses received for a Local  request",
	  "Desc": "Snoop Responses Received Local",
	  "EvSel": 93,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.SNOOP_RESP_LOCAL.RSPS": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Number of snoop responses received for a Local  request",
	  "Desc": "Snoop Responses Received Local",
	  "EvSel": 93,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.SNOOP_RESP_LOCAL.RSPFWD": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Number of snoop responses received for a Local  request",
	  "Desc": "Snoop Responses Received Local",
	  "EvSel": 93,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.SNOOP_RESP_LOCAL.RSPSFWD": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Number of snoop responses received for a Local  request",
	  "Desc": "Snoop Responses Received Local",
	  "EvSel": 93,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.SNOOP_RESP_LOCAL.RSPCNFLCT": {
	  "Box": "CHA",
	  "Category": "CHA HA SNOOP RESPONSE Events",
	  "Defn": "Number of snoop responses received for a Local  request",
	  "Desc": "Snoop Responses Received Local",
	  "EvSel": 93,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.SNOOP_RSP_MISC": {
	  "Box": "CHA",
	  "Category": "CHA CBO SNOOP RESPONSE Events",
	  "Desc": "Misc Snoop Responses Received",
	  "EvSel": 107,
	  "ExtSel": "",
     },
     "CHA.SNOOP_RSP_MISC.RSPIFWDMPTL_HITLLC": {
	  "Box": "CHA",
	  "Category": "CHA CBO SNOOP RESPONSE Events",
	  "Desc": "Misc Snoop Responses Received",
	  "EvSel": 107,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.SNOOP_RSP_MISC.MTOI_RSPDATAM": {
	  "Box": "CHA",
	  "Category": "CHA CBO SNOOP RESPONSE Events",
	  "Desc": "Misc Snoop Responses Received",
	  "EvSel": 107,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.SNOOP_RSP_MISC.RSPIFWDMPTL_HITSF": {
	  "Box": "CHA",
	  "Category": "CHA CBO SNOOP RESPONSE Events",
	  "Desc": "Misc Snoop Responses Received",
	  "EvSel": 107,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.SNOOP_RSP_MISC.PULLDATAPTL_HITSF": {
	  "Box": "CHA",
	  "Category": "CHA CBO SNOOP RESPONSE Events",
	  "Desc": "Misc Snoop Responses Received",
	  "EvSel": 107,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.SNOOP_RSP_MISC.MTOI_RSPIFWDM": {
	  "Box": "CHA",
	  "Category": "CHA CBO SNOOP RESPONSE Events",
	  "Desc": "Misc Snoop Responses Received",
	  "EvSel": 107,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.SNOOP_RSP_MISC.PULLDATAPTL_HITLLC": {
	  "Box": "CHA",
	  "Category": "CHA CBO SNOOP RESPONSE Events",
	  "Desc": "Misc Snoop Responses Received",
	  "EvSel": 107,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR2": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR6": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR7": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR3": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR5": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR4": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR2": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR5": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR4": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR6": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR3": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR7": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR2": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR4": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR5": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR3": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR7": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR6": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR2": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR5": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR4": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR6": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR3": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR7": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.STALL1_NO_TxR_HORZ_CRD_AD_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 209,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "CHA.STALL1_NO_TxR_HORZ_CRD_AD_AG0.TGR8": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 209,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.STALL1_NO_TxR_HORZ_CRD_AD_AG0.TGR10": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 209,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.STALL1_NO_TxR_HORZ_CRD_AD_AG0.TGR9": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 209,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.STALL1_NO_TxR_HORZ_CRD_AD_AG1_1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "CHA.STALL1_NO_TxR_HORZ_CRD_AD_AG1_1.TGR9": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.STALL1_NO_TxR_HORZ_CRD_AD_AG1_1.TGR10": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.STALL1_NO_TxR_HORZ_CRD_AD_AG1_1.TGR8": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.STALL1_NO_TxR_HORZ_CRD_BL_AG0_1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 213,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "CHA.STALL1_NO_TxR_HORZ_CRD_BL_AG0_1.TGR8": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 213,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.STALL1_NO_TxR_HORZ_CRD_BL_AG0_1.TGR9": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 213,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.STALL1_NO_TxR_HORZ_CRD_BL_AG0_1.TGR10": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 213,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.STALL1_NO_TxR_HORZ_CRD_BL_AG1_1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "CHA.STALL1_NO_TxR_HORZ_CRD_BL_AG1_1.TGR9": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.STALL1_NO_TxR_HORZ_CRD_BL_AG1_1.TGR10": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.STALL1_NO_TxR_HORZ_CRD_BL_AG1_1.TGR8": {
	  "Box": "CHA",
	  "Category": "CHA CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.TOR_INSERTS": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
     },
     "CHA.TOR_INSERTS.ISOC": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "b1xxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_INSERTS.IO_MISS_RFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC803FE,
     },
     "CHA.TOR_INSERTS.MMCFG": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxx1xxxxx",
     },
     "CHA.TOR_INSERTS.IA_MISS_LOCAL_WCIL_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86E86,
     },
     "CHA.TOR_INSERTS.IA_DRD_OPT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC827FF,
     },
     "CHA.TOR_INSERTS.IO_HIT_PCIRDCUR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC8F3FD,
     },
     "CHA.TOR_INSERTS.LOC_IA": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC000FF,
     },
     "CHA.TOR_INSERTS.IO_MISS_ITOM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xCC43FE,
     },
     "CHA.TOR_INSERTS.IA_MISS_CRD_PREF_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC88F7E,
     },
     "CHA.TOR_INSERTS.IA_LLCPREFRFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCC7FF,
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC897FE,
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC816FE,
     },
     "CHA.TOR_INSERTS.IA_MISS_LOCAL_WCILF_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86686,
     },
     "CHA.TOR_INSERTS.IA_MISS_WCILF_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8678A,
     },
     "CHA.TOR_INSERTS.IO_ITOM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xCC43FF,
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD_LOCAL_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC81686,
     },
     "CHA.TOR_INSERTS.IA_HIT_DRD_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC897FD,
     },
     "CHA.TOR_INSERTS.NONCOH": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bx1xxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_INSERTS.IA_HIT_CRD_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC88FFD,
     },
     "CHA.TOR_INSERTS.IA_HIT_LLCPREFCODE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCCFFD,
     },
     "CHA.TOR_INSERTS.IA_MISS_RFO_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8077E,
     },
     "CHA.TOR_INSERTS.MISS": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxx1x",
     },
     "CHA.TOR_INSERTS.IA_ITOMCACHENEAR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCD47FF,
     },
     "CHA.TOR_INSERTS.IA_SPECITOM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCC57FF,
     },
     "CHA.TOR_INSERTS.IO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC001FF,
     },
     "CHA.TOR_INSERTS.IO_HIT_RFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC803FD,
     },
     "CHA.TOR_INSERTS.IA_MISS_LLCPREFDATA": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCD7FE,
     },
     "CHA.TOR_INSERTS.IA_LLCPREFDATA": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCD7FF,
     },
     "CHA.TOR_INSERTS.IA_LLCPREFCODE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCCFFF,
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD_PREF_LOCAL_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC89686,
     },
     "CHA.TOR_INSERTS.IRQ_NON_IA": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxx1xxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_INSERTS.IPQ": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxx1xxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD_OPT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC827FE,
     },
     "CHA.TOR_INSERTS.IA_MISS_CRD": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC80FFE,
     },
     "CHA.TOR_INSERTS.IO_RFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC803FF,
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8177E,
     },
     "CHA.TOR_INSERTS.IA_HIT_DRD_OPT_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8A7FD,
     },
     "CHA.TOR_INSERTS.IA_DRD_OPT_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8A7FF,
     },
     "CHA.TOR_INSERTS.IO_HIT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC001FD,
     },
     "CHA.TOR_INSERTS.IO_PCIRDCUR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC8F3FF,
     },
     "CHA.TOR_INSERTS.LOC_ALL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000101",
	  "UmaskExt": 0xC000FF,
     },
     "CHA.TOR_INSERTS.PREMORPH_OPC": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxXXXXXXXXXXX1xxxxxxxxxx",
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD_LOCAL_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8168A,
     },
     "CHA.TOR_INSERTS.IO_MISS": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC001FE,
     },
     "CHA.TOR_INSERTS.IRQ_IA": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxxxx1",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD_REMOTE_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC81706,
     },
     "CHA.TOR_INSERTS.IA_MISS_LLCPREFCODE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCCFFE,
     },
     "CHA.TOR_INSERTS.PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxx1xxx",
     },
     "CHA.TOR_INSERTS.IA_DRDPTE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC837FF,
     },
     "CHA.TOR_INSERTS.NOT_NEARMEM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxx1xxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD_PREF_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8978A,
     },
     "CHA.TOR_INSERTS.PRQ_NON_IOSF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxx1xxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_INSERTS.IA_HIT_CRD": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC80FFD,
     },
     "CHA.TOR_INSERTS.IA_MISS_REMOTE_WCIL_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86F06,
     },
     "CHA.TOR_INSERTS.IA_HIT_DRD": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC817FD,
     },
     "CHA.TOR_INSERTS.IA_CLFLUSH": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8C7FF,
     },
     "CHA.TOR_INSERTS.IO_HIT_ITOM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xCC43FD,
     },
     "CHA.TOR_INSERTS.WBQ": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b1xxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_INSERTS.IA_MISS_RFO_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC887FE,
     },
     "CHA.TOR_INSERTS.IO_MISS_ITOMCACHENEAR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xCD43FE,
     },
     "CHA.TOR_INSERTS.IA_HIT_LLCPREFRFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCC7FD,
     },
     "CHA.TOR_INSERTS.IA_MISS_RFO_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC806FE,
     },
     "CHA.TOR_INSERTS.LOC_IO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC000FF,
     },
     "CHA.TOR_INSERTS.IA_MISS_CRD_PREF_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC88EFE,
     },
     "CHA.TOR_INSERTS.IA_MISS_WCIL_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86F86,
     },
     "CHA.TOR_INSERTS.HBM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxx1xxxx",
     },
     "CHA.TOR_INSERTS.IA_WBMTOI": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCC27FF,
     },
     "CHA.TOR_INSERTS.IA_RFO_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC887FF,
     },
     "CHA.TOR_INSERTS.IA_DRD": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC817FF,
     },
     "CHA.TOR_INSERTS.IA_MISS_UCRDF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC877DE,
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD_PREF_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC89786,
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD_OPT_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8A7FE,
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8178A,
     },
     "CHA.TOR_INSERTS.IA_MISS_CRD_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC80EFE,
     },
     "CHA.TOR_INSERTS.IA_MISS_LOCAL_WCIL_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86E8A,
     },
     "CHA.TOR_INSERTS.IA_HIT_RFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC807FD,
     },
     "CHA.TOR_INSERTS.IA_MISS_RFO_PREF_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC886FE,
     },
     "CHA.TOR_INSERTS.IA_MISS_CRD_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC88FFE,
     },
     "CHA.TOR_INSERTS.IA": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC001FF,
     },
     "CHA.TOR_INSERTS.NEARMEM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxx1xxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_INSERTS.IA_WCIL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86FFF,
     },
     "CHA.TOR_INSERTS.IA_MISS_WIL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC87FDE,
     },
     "CHA.TOR_INSERTS.IO_ITOMCACHENEAR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xCD43FF,
     },
     "CHA.TOR_INSERTS.IA_MISS_DRDPTE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC837FE,
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC81786,
     },
     "CHA.TOR_INSERTS.IA_HIT_DRDPTE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC837FD,
     },
     "CHA.TOR_INSERTS.IA_MISS_WCILF_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86786,
     },
     "CHA.TOR_INSERTS.IA_MISS_WCIL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86FFE,
     },
     "CHA.TOR_INSERTS.IO_HIT_ITOMCACHENEAR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xCD43FD,
     },
     "CHA.TOR_INSERTS.IA_MISS_LOCAL_WCILF_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8668A,
     },
     "CHA.TOR_INSERTS.MATCH_OPC": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxXXXXXXXXXXXx1xxxxxxxxx",
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD_PREF_REMOTE_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC89706,
     },
     "CHA.TOR_INSERTS.REMOTE_TGT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxx1xxxxxxxx",
     },
     "CHA.TOR_INSERTS.IA_ITOM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCC47FF,
     },
     "CHA.TOR_INSERTS.IA_HIT_LLCPREFDATA": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCD7FD,
     },
     "CHA.TOR_INSERTS.IA_MISS_ITOM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCC47FE,
     },
     "CHA.TOR_INSERTS.IA_MISS_RFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC807FE,
     },
     "CHA.TOR_INSERTS.IA_HIT_DRD_OPT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC827FD,
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD_PREF_LOCAL_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8968A,
     },
     "CHA.TOR_INSERTS.IA_MISS_REMOTE_WCILF_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8670A,
     },
     "CHA.TOR_INSERTS.IA_MISS_WCILF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC867FE,
     },
     "CHA.TOR_INSERTS.IA_MISS_LLCPREFRFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCC7FE,
     },
     "CHA.TOR_INSERTS.IA_HIT_RFO_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC887FD,
     },
     "CHA.TOR_INSERTS.IA_MISS_REMOTE_WCILF_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86706,
     },
     "CHA.TOR_INSERTS.IA_CRD": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC80FFF,
     },
     "CHA.TOR_INSERTS.IO_MISS_PCIRDCUR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC8F3FE,
     },
     "CHA.TOR_INSERTS.IO_WBMTOI": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xCC23FF,
     },
     "CHA.TOR_INSERTS.IA_WCILF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC867FF,
     },
     "CHA.TOR_INSERTS.PRQ_IOSF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxx1xx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_INSERTS.HIT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxx1",
     },
     "CHA.TOR_INSERTS.IA_MISS_CRD_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC80F7E,
     },
     "CHA.TOR_INSERTS.MMIO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxx1xxxxxx",
     },
     "CHA.TOR_INSERTS.IA_CLFLUSHOPT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8D7FF,
     },
     "CHA.TOR_INSERTS.LOCAL_TGT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxx1xxxxxxx",
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC817FE,
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD_REMOTE_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8170A,
     },
     "CHA.TOR_INSERTS.EVICT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxxx1x",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_INSERTS.IA_MISS_REMOTE_WCIL_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86F0A,
     },
     "CHA.TOR_INSERTS.IA_HIT_ITOM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCC47FD,
     },
     "CHA.TOR_INSERTS.IO_CLFLUSH": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC8C3FF,
     },
     "CHA.TOR_INSERTS.IA_MISS_WCIL_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86F8A,
     },
     "CHA.TOR_INSERTS.IA_MISS": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC001FE,
     },
     "CHA.TOR_INSERTS.IA_HIT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC001FD,
     },
     "CHA.TOR_INSERTS.RRQ": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bx1xxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_INSERTS.IA_MISS_RFO_PREF_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8877E,
     },
     "CHA.TOR_INSERTS.ALL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b11111111",
	  "UmaskExt": 0xC001FF,
     },
     "CHA.TOR_INSERTS.DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxx1xx",
     },
     "CHA.TOR_INSERTS.IA_MISS_DRD_PREF_REMOTE_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8970A,
     },
     "CHA.TOR_INSERTS.IA_RFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC807FF,
     },
     "CHA.TOR_INSERTS.IA_DRD_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries successfuly inserted into the TOR that match qualifications specified by the subevent.   Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Inserts",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaning it is necessary to set one of the queue bits before one can measure .HIT or .MISS.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC897FF,
     },
     "CHA.TOR_OCCUPANCY": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_REMOTE_WCILF_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86706,
     },
     "CHA.TOR_OCCUPANCY.IA_CRD": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC80FFF,
     },
     "CHA.TOR_OCCUPANCY.IA_HIT_RFO_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC887FD,
     },
     "CHA.TOR_OCCUPANCY.HIT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxx1",
     },
     "CHA.TOR_OCCUPANCY.IA_WCILF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC867FF,
     },
     "CHA.TOR_OCCUPANCY.IO_MISS_PCIRDCUR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC8F3FE,
     },
     "CHA.TOR_OCCUPANCY.IO_WBMTOI": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xCC23FF,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD_REMOTE_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8170A,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC817FE,
     },
     "CHA.TOR_OCCUPANCY.LOCAL_TGT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxx1xxxxxxx",
     },
     "CHA.TOR_OCCUPANCY.EVICT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxxx1x",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_OCCUPANCY.MMIO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxx1xxxxxx",
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_CRD_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC80F7E,
     },
     "CHA.TOR_OCCUPANCY.IA_CLFLUSHOPT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8D7FF,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_WCIL_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86F8A,
     },
     "CHA.TOR_OCCUPANCY.IA_HIT_ITOM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCC47FD,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_REMOTE_WCIL_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86F0A,
     },
     "CHA.TOR_OCCUPANCY.IO_CLFLUSH": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC8C3FF,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC001FE,
     },
     "CHA.TOR_OCCUPANCY.IA_HIT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC001FD,
     },
     "CHA.TOR_OCCUPANCY.DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxx1xx",
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD_PREF_REMOTE_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8970A,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_RFO_PREF_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8877E,
     },
     "CHA.TOR_OCCUPANCY.IA_RFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC807FF,
     },
     "CHA.TOR_OCCUPANCY.IA_DRD_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC897FF,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8178A,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD_OPT_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8A7FE,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_UCRDF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC877DE,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD_PREF_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC89786,
     },
     "CHA.TOR_OCCUPANCY.IA_DRD": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC817FF,
     },
     "CHA.TOR_OCCUPANCY.IA_RFO_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC887FF,
     },
     "CHA.TOR_OCCUPANCY.IA": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC001FF,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_CRD_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC88FFE,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_CRD_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC80EFE,
     },
     "CHA.TOR_OCCUPANCY.IA_HIT_RFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC807FD,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_RFO_PREF_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC886FE,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_LOCAL_WCIL_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86E8A,
     },
     "CHA.TOR_OCCUPANCY.NEARMEM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxx1xxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_WIL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC87FDE,
     },
     "CHA.TOR_OCCUPANCY.IA_WCIL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86FFF,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC81786,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRDPTE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC837FE,
     },
     "CHA.TOR_OCCUPANCY.IO_ITOMCACHENEAR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xCD43FF,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_WCIL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86FFE,
     },
     "CHA.TOR_OCCUPANCY.PRQ": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxx1xx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_WCILF_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86786,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_LOCAL_WCILF_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8668A,
     },
     "CHA.TOR_OCCUPANCY.IO_HIT_ITOMCACHENEAR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xCD43FD,
     },
     "CHA.TOR_OCCUPANCY.IA_HIT_DRDPTE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC837FD,
     },
     "CHA.TOR_OCCUPANCY.IA_HIT_LLCPREFDATA": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCD7FD,
     },
     "CHA.TOR_OCCUPANCY.IA_ITOM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCC47FF,
     },
     "CHA.TOR_OCCUPANCY.REMOTE_TGT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxx1xxxxxxxx",
     },
     "CHA.TOR_OCCUPANCY.MATCH_OPC": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxXXXXXXXXXXXx1xxxxxxxxx",
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD_PREF_REMOTE_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC89706,
     },
     "CHA.TOR_OCCUPANCY.IA_HIT_DRD_OPT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC827FD,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_RFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC807FE,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD_PREF_LOCAL_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8968A,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_ITOM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCC47FE,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_LLCPREFRFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCC7FE,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_REMOTE_WCILF_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8670A,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_WCILF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC867FE,
     },
     "CHA.TOR_OCCUPANCY.IA_LLCPREFCODE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCCFFF,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD_PREF_LOCAL_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC89686,
     },
     "CHA.TOR_OCCUPANCY.IPQ": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxx1xxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_OCCUPANCY.IRQ_NON_IA": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxx1xxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8177E,
     },
     "CHA.TOR_OCCUPANCY.IA_DRD_OPT_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8A7FF,
     },
     "CHA.TOR_OCCUPANCY.IA_HIT_DRD_OPT_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8A7FD,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD_OPT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC827FE,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_CRD": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC80FFE,
     },
     "CHA.TOR_OCCUPANCY.IO_RFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC803FF,
     },
     "CHA.TOR_OCCUPANCY.IO_PCIRDCUR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC8F3FF,
     },
     "CHA.TOR_OCCUPANCY.IO_HIT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC001FD,
     },
     "CHA.TOR_OCCUPANCY.LOC_ALL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000101",
	  "UmaskExt": 0xC000FF,
     },
     "CHA.TOR_OCCUPANCY.IO_MISS": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC001FE,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD_LOCAL_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8168A,
     },
     "CHA.TOR_OCCUPANCY.PREMORPH_OPC": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxXXXXXXXXXXX1xxxxxxxxxx",
     },
     "CHA.TOR_OCCUPANCY.PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxx1xxx",
     },
     "CHA.TOR_OCCUPANCY.IA_DRDPTE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC837FF,
     },
     "CHA.TOR_OCCUPANCY.IRQ_IA": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxxxx1",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD_REMOTE_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC81706,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_LLCPREFCODE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCCFFE,
     },
     "CHA.TOR_OCCUPANCY.PRQ_NON_IOSF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxx1xxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_OCCUPANCY.NOT_NEARMEM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxx1xxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD_PREF_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8978A,
     },
     "CHA.TOR_OCCUPANCY.IA_CLFLUSH": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8C7FF,
     },
     "CHA.TOR_OCCUPANCY.IO_HIT_ITOM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xCC43FD,
     },
     "CHA.TOR_OCCUPANCY.IA_HIT_CRD": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC80FFD,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_REMOTE_WCIL_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86F06,
     },
     "CHA.TOR_OCCUPANCY.IA_HIT_DRD": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC817FD,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_RFO_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC806FE,
     },
     "CHA.TOR_OCCUPANCY.IA_HIT_LLCPREFRFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCC7FD,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_CRD_PREF_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC88EFE,
     },
     "CHA.TOR_OCCUPANCY.LOC_IO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC000FF,
     },
     "CHA.TOR_OCCUPANCY.IO_MISS_ITOMCACHENEAR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xCD43FE,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_RFO_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC887FE,
     },
     "CHA.TOR_OCCUPANCY.IA_WBMTOI": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCC27FF,
     },
     "CHA.TOR_OCCUPANCY.HBM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxx1xxxx",
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_WCIL_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86F86,
     },
     "CHA.TOR_OCCUPANCY.IO_HIT_PCIRDCUR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC8F3FD,
     },
     "CHA.TOR_OCCUPANCY.LOC_IA": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC000FF,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_LOCAL_WCIL_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86E86,
     },
     "CHA.TOR_OCCUPANCY.IA_DRD_OPT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC827FF,
     },
     "CHA.TOR_OCCUPANCY.IO_MISS_ITOM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xCC43FE,
     },
     "CHA.TOR_OCCUPANCY.ISOC": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "b1xxxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_OCCUPANCY.MMCFG": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxx1xxxxx",
     },
     "CHA.TOR_OCCUPANCY.IO_MISS_RFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC803FE,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_CRD_PREF_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC88F7E,
     },
     "CHA.TOR_OCCUPANCY.IA_LLCPREFRFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCC7FF,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_LOCAL_WCILF_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC86686,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD_LOCAL": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC816FE,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC897FE,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_WCILF_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8678A,
     },
     "CHA.TOR_OCCUPANCY.IO_ITOM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xCC43FF,
     },
     "CHA.TOR_OCCUPANCY.IA_HIT_DRD_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC897FD,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_DRD_LOCAL_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC81686,
     },
     "CHA.TOR_OCCUPANCY.IA_HIT_CRD_PREF": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC88FFD,
     },
     "CHA.TOR_OCCUPANCY.NONCOH": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bx1xxxxxxxxxxxxxxxxxxxxxxxx",
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_RFO_REMOTE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xC8077E,
     },
     "CHA.TOR_OCCUPANCY.IA_ITOMCACHENEAR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCD47FF,
     },
     "CHA.TOR_OCCUPANCY.MISS": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxxxxxxxxxxxxxxxxxxx1x",
     },
     "CHA.TOR_OCCUPANCY.IA_HIT_LLCPREFCODE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCCFFD,
     },
     "CHA.TOR_OCCUPANCY.IA_SPECITOM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCC57FF,
     },
     "CHA.TOR_OCCUPANCY.IO_HIT_RFO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC803FD,
     },
     "CHA.TOR_OCCUPANCY.IA_MISS_LLCPREFDATA": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCD7FE,
     },
     "CHA.TOR_OCCUPANCY.IA_LLCPREFDATA": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000001",
	  "UmaskExt": 0xCCD7FF,
     },
     "CHA.TOR_OCCUPANCY.IO": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Counters": 0,
	  "Defn": "For each cycle, this event accumulates the number of valid entries in the TOR that match qualifications specified by the subevent.     Does not include addressless requests such as locks and interrupts.",
	  "Desc": "TOR Occupancy",
	  "EvSel": 54,
	  "ExtSel": "",
	  "MaxIncCyc": 20,
	  "Notes": "HW does not strictly OR each subevent.   The equation is roughly (IRQ|EVICT|PRQ|IPQ|RRQ|WBQ) & (HIT|MISS).  Meaing it is necessary to set one of the queue bits before one can measure .HIT or .MISS.   Also note this event is subect to CHA Filter1 which allows a user to opcode match against TOR entries, distinguish those requests satsified locally vs. those that came from a remote node, etc.",
	  "Umask": "b00000100",
	  "UmaskExt": 0xC001FF,
     },
     "CHA.TxR_HORZ_ADS_USED": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
     },
     "CHA.TxR_HORZ_ADS_USED.AD_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "CHA.TxR_HORZ_ADS_USED.AD_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "CHA.TxR_HORZ_ADS_USED.BL_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "CHA.TxR_HORZ_ADS_USED.AD_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "CHA.TxR_HORZ_ADS_USED.BL_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "CHA.TxR_HORZ_ADS_USED.BL_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "CHA.TxR_HORZ_BYPASS": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
     },
     "CHA.TxR_HORZ_BYPASS.AD_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "CHA.TxR_HORZ_BYPASS.BL_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "CHA.TxR_HORZ_BYPASS.AK": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "CHA.TxR_HORZ_BYPASS.AD_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "CHA.TxR_HORZ_BYPASS.BL_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "CHA.TxR_HORZ_BYPASS.AD_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "CHA.TxR_HORZ_BYPASS.AKC_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "CHA.TxR_HORZ_BYPASS.BL_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "CHA.TxR_HORZ_BYPASS.IV": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "CHA.TxR_HORZ_CYCLES_FULL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
     },
     "CHA.TxR_HORZ_CYCLES_FULL.AD_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "CHA.TxR_HORZ_CYCLES_FULL.AKC_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "CHA.TxR_HORZ_CYCLES_FULL.IV": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "CHA.TxR_HORZ_CYCLES_FULL.BL_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "CHA.TxR_HORZ_CYCLES_FULL.BL_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "CHA.TxR_HORZ_CYCLES_FULL.AD_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "CHA.TxR_HORZ_CYCLES_FULL.BL_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "CHA.TxR_HORZ_CYCLES_FULL.AD_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "CHA.TxR_HORZ_CYCLES_FULL.AK": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "CHA.TxR_HORZ_CYCLES_NE": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
     },
     "CHA.TxR_HORZ_CYCLES_NE.AD_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "CHA.TxR_HORZ_CYCLES_NE.AK": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "CHA.TxR_HORZ_CYCLES_NE.BL_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "CHA.TxR_HORZ_CYCLES_NE.AD_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "CHA.TxR_HORZ_CYCLES_NE.BL_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "CHA.TxR_HORZ_CYCLES_NE.AKC_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "CHA.TxR_HORZ_CYCLES_NE.BL_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "CHA.TxR_HORZ_CYCLES_NE.IV": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "CHA.TxR_HORZ_CYCLES_NE.AD_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "CHA.TxR_HORZ_INSERTS": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
     },
     "CHA.TxR_HORZ_INSERTS.AD_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "CHA.TxR_HORZ_INSERTS.AK": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "CHA.TxR_HORZ_INSERTS.BL_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "CHA.TxR_HORZ_INSERTS.AD_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "CHA.TxR_HORZ_INSERTS.BL_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "CHA.TxR_HORZ_INSERTS.IV": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "CHA.TxR_HORZ_INSERTS.AKC_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "CHA.TxR_HORZ_INSERTS.BL_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "CHA.TxR_HORZ_INSERTS.AD_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "CHA.TxR_HORZ_NACK": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
     },
     "CHA.TxR_HORZ_NACK.BL_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "CHA.TxR_HORZ_NACK.AK": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "CHA.TxR_HORZ_NACK.AD_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "CHA.TxR_HORZ_NACK.BL_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "CHA.TxR_HORZ_NACK.AD_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "CHA.TxR_HORZ_NACK.BL_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "CHA.TxR_HORZ_NACK.AKC_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "CHA.TxR_HORZ_NACK.IV": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "CHA.TxR_HORZ_NACK.AD_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "CHA.TxR_HORZ_OCCUPANCY": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
     },
     "CHA.TxR_HORZ_OCCUPANCY.AK": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "CHA.TxR_HORZ_OCCUPANCY.AD_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "CHA.TxR_HORZ_OCCUPANCY.BL_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "CHA.TxR_HORZ_OCCUPANCY.AD_CRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "CHA.TxR_HORZ_OCCUPANCY.BL_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "CHA.TxR_HORZ_OCCUPANCY.IV": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "CHA.TxR_HORZ_OCCUPANCY.AKC_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "CHA.TxR_HORZ_OCCUPANCY.BL_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "CHA.TxR_HORZ_OCCUPANCY.AD_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "CHA.TxR_HORZ_STARVED": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
     },
     "CHA.TxR_HORZ_STARVED.BL_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "CHA.TxR_HORZ_STARVED.AK": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "CHA.TxR_HORZ_STARVED.AD_ALL": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "CHA.TxR_HORZ_STARVED.AD_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "CHA.TxR_HORZ_STARVED.IV": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "CHA.TxR_HORZ_STARVED.AKC_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "CHA.TxR_HORZ_STARVED.BL_UNCRD": {
	  "Box": "CHA",
	  "Category": "CHA CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "CHA.TxR_VERT_ADS_USED": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
     },
     "CHA.TxR_VERT_ADS_USED.AD_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.TxR_VERT_ADS_USED.BL_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.TxR_VERT_ADS_USED.AD_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.TxR_VERT_ADS_USED.BL_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.TxR_VERT_BYPASS": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
     },
     "CHA.TxR_VERT_BYPASS.IV_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.TxR_VERT_BYPASS.BL_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.TxR_VERT_BYPASS.AK_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.TxR_VERT_BYPASS.AD_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.TxR_VERT_BYPASS.AD_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.TxR_VERT_BYPASS.AK_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.TxR_VERT_BYPASS.BL_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.TxR_VERT_BYPASS_1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 158,
	  "ExtSel": "",
     },
     "CHA.TxR_VERT_BYPASS_1.AKC_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 158,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.TxR_VERT_BYPASS_1.AKC_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 158,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.TxR_VERT_CYCLES_FULL0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
     },
     "CHA.TxR_VERT_CYCLES_FULL0.BL_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.TxR_VERT_CYCLES_FULL0.AD_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.TxR_VERT_CYCLES_FULL0.AK_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.TxR_VERT_CYCLES_FULL0.AD_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.TxR_VERT_CYCLES_FULL0.AK_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.TxR_VERT_CYCLES_FULL0.IV_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.TxR_VERT_CYCLES_FULL0.BL_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.TxR_VERT_CYCLES_FULL1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 149,
	  "ExtSel": "",
     },
     "CHA.TxR_VERT_CYCLES_FULL1.AKC_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 149,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.TxR_VERT_CYCLES_FULL1.AKC_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 149,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.TxR_VERT_CYCLES_NE0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
     },
     "CHA.TxR_VERT_CYCLES_NE0.IV_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.TxR_VERT_CYCLES_NE0.BL_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.TxR_VERT_CYCLES_NE0.AD_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.TxR_VERT_CYCLES_NE0.AK_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.TxR_VERT_CYCLES_NE0.AK_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.TxR_VERT_CYCLES_NE0.AD_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.TxR_VERT_CYCLES_NE0.BL_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.TxR_VERT_CYCLES_NE1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 151,
	  "ExtSel": "",
     },
     "CHA.TxR_VERT_CYCLES_NE1.AKC_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 151,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.TxR_VERT_CYCLES_NE1.AKC_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 151,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.TxR_VERT_INSERTS0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
     },
     "CHA.TxR_VERT_INSERTS0.BL_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.TxR_VERT_INSERTS0.IV_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.TxR_VERT_INSERTS0.AD_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.TxR_VERT_INSERTS0.AK_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.TxR_VERT_INSERTS0.AK_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.TxR_VERT_INSERTS0.AD_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.TxR_VERT_INSERTS0.BL_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.TxR_VERT_INSERTS1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 147,
	  "ExtSel": "",
     },
     "CHA.TxR_VERT_INSERTS1.AKC_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 147,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.TxR_VERT_INSERTS1.AKC_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 147,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.TxR_VERT_NACK0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
     },
     "CHA.TxR_VERT_NACK0.AD_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.TxR_VERT_NACK0.AK_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.TxR_VERT_NACK0.BL_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.TxR_VERT_NACK0.BL_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.TxR_VERT_NACK0.IV_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.TxR_VERT_NACK0.AD_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.TxR_VERT_NACK0.AK_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.TxR_VERT_NACK1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 153,
	  "ExtSel": "",
     },
     "CHA.TxR_VERT_NACK1.AKC_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 153,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.TxR_VERT_NACK1.AKC_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 153,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.TxR_VERT_OCCUPANCY0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
     },
     "CHA.TxR_VERT_OCCUPANCY0.BL_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.TxR_VERT_OCCUPANCY0.AK_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.TxR_VERT_OCCUPANCY0.AD_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.TxR_VERT_OCCUPANCY0.AK_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.TxR_VERT_OCCUPANCY0.AD_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.TxR_VERT_OCCUPANCY0.BL_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.TxR_VERT_OCCUPANCY0.IV_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.TxR_VERT_OCCUPANCY1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 145,
	  "ExtSel": "",
     },
     "CHA.TxR_VERT_OCCUPANCY1.AKC_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 145,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.TxR_VERT_OCCUPANCY1.AKC_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 145,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.TxR_VERT_STARVED0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
     },
     "CHA.TxR_VERT_STARVED0.AK_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "CHA.TxR_VERT_STARVED0.AD_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.TxR_VERT_STARVED0.BL_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.TxR_VERT_STARVED0.IV_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.TxR_VERT_STARVED0.BL_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.TxR_VERT_STARVED0.AK_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.TxR_VERT_STARVED0.AD_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "CHA.TxR_VERT_STARVED1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 155,
	  "ExtSel": "",
     },
     "CHA.TxR_VERT_STARVED1.AKC_AG0": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 155,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.TxR_VERT_STARVED1.TGC": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 155,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.TxR_VERT_STARVED1.AKC_AG1": {
	  "Box": "CHA",
	  "Category": "CHA CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 155,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.VERT_RING_AD_IN_USE": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
     },
     "CHA.VERT_RING_AD_IN_USE.UP_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.VERT_RING_AD_IN_USE.DN_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.VERT_RING_AD_IN_USE.DN_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.VERT_RING_AD_IN_USE.UP_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.VERT_RING_AKC_IN_USE": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
     },
     "CHA.VERT_RING_AKC_IN_USE.UP_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.VERT_RING_AKC_IN_USE.DN_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.VERT_RING_AKC_IN_USE.DN_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.VERT_RING_AKC_IN_USE.UP_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.VERT_RING_AK_IN_USE": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
     },
     "CHA.VERT_RING_AK_IN_USE.DN_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.VERT_RING_AK_IN_USE.UP_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.VERT_RING_AK_IN_USE.UP_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.VERT_RING_AK_IN_USE.DN_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.VERT_RING_BL_IN_USE": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
     },
     "CHA.VERT_RING_BL_IN_USE.DN_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.VERT_RING_BL_IN_USE.UP_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.VERT_RING_BL_IN_USE.UP_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.VERT_RING_BL_IN_USE.DN_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.VERT_RING_IV_IN_USE": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Vertical IV Ring in Use",
	  "EvSel": 179,
	  "ExtSel": "",
     },
     "CHA.VERT_RING_IV_IN_USE.DN": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Vertical IV Ring in Use",
	  "EvSel": 179,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.VERT_RING_IV_IN_USE.UP": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Vertical IV Ring in Use",
	  "EvSel": 179,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.VERT_RING_TGC_IN_USE": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
     },
     "CHA.VERT_RING_TGC_IN_USE.UP_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.VERT_RING_TGC_IN_USE.DN_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.VERT_RING_TGC_IN_USE.DN_ODD": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.VERT_RING_TGC_IN_USE.UP_EVEN": {
	  "Box": "CHA",
	  "Category": "CHA Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.WB_PUSH_MTOI": {
	  "Box": "CHA",
	  "Category": "CHA HA WBPUSHMTOI Events",
	  "Defn": "Counts the number of times when the CHA was received WbPushMtoI",
	  "Desc": "WbPushMtoI",
	  "EvSel": 86,
	  "ExtSel": "",
     },
     "CHA.WB_PUSH_MTOI.MEM": {
	  "Box": "CHA",
	  "Category": "CHA HA WBPUSHMTOI Events",
	  "Defn": "Counts the number of times when the CHA was received WbPushMtoI",
	  "Desc": "WbPushMtoI",
	  "EvSel": 86,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "CHA.WB_PUSH_MTOI.LLC": {
	  "Box": "CHA",
	  "Category": "CHA HA WBPUSHMTOI Events",
	  "Defn": "Counts the number of times when the CHA was received WbPushMtoI",
	  "Desc": "WbPushMtoI",
	  "EvSel": 86,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.WRITE_NO_CREDITS": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending WRITEs from the CHA into the iMC.  In order to send WRITEs into the memory controller, the HA must first acquire a credit for the iMC's BL Ingress queue.",
	  "Desc": "CHA iMC CHNx WRITE Credits Empty",
	  "EvSel": 90,
	  "ExtSel": "",
     },
     "CHA.WRITE_NO_CREDITS.MC2": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending WRITEs from the CHA into the iMC.  In order to send WRITEs into the memory controller, the HA must first acquire a credit for the iMC's BL Ingress queue.",
	  "Desc": "CHA iMC CHNx WRITE Credits Empty",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.WRITE_NO_CREDITS.MC5": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending WRITEs from the CHA into the iMC.  In order to send WRITEs into the memory controller, the HA must first acquire a credit for the iMC's BL Ingress queue.",
	  "Desc": "CHA iMC CHNx WRITE Credits Empty",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.WRITE_NO_CREDITS.MC9": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending WRITEs from the CHA into the iMC.  In order to send WRITEs into the memory controller, the HA must first acquire a credit for the iMC's BL Ingress queue.",
	  "Desc": "CHA iMC CHNx WRITE Credits Empty",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxx1x",
     },
     "CHA.WRITE_NO_CREDITS.MC7": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending WRITEs from the CHA into the iMC.  In order to send WRITEs into the memory controller, the HA must first acquire a credit for the iMC's BL Ingress queue.",
	  "Desc": "CHA iMC CHNx WRITE Credits Empty",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.WRITE_NO_CREDITS.MC8": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending WRITEs from the CHA into the iMC.  In order to send WRITEs into the memory controller, the HA must first acquire a credit for the iMC's BL Ingress queue.",
	  "Desc": "CHA iMC CHNx WRITE Credits Empty",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxx1",
     },
     "CHA.WRITE_NO_CREDITS.MC10": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending WRITEs from the CHA into the iMC.  In order to send WRITEs into the memory controller, the HA must first acquire a credit for the iMC's BL Ingress queue.",
	  "Desc": "CHA iMC CHNx WRITE Credits Empty",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxx1xx",
     },
     "CHA.WRITE_NO_CREDITS.MC13": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending WRITEs from the CHA into the iMC.  In order to send WRITEs into the memory controller, the HA must first acquire a credit for the iMC's BL Ingress queue.",
	  "Desc": "CHA iMC CHNx WRITE Credits Empty",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxx1xxxxx",
     },
     "CHA.WRITE_NO_CREDITS.MC4": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending WRITEs from the CHA into the iMC.  In order to send WRITEs into the memory controller, the HA must first acquire a credit for the iMC's BL Ingress queue.",
	  "Desc": "CHA iMC CHNx WRITE Credits Empty",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.WRITE_NO_CREDITS.MC3": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending WRITEs from the CHA into the iMC.  In order to send WRITEs into the memory controller, the HA must first acquire a credit for the iMC's BL Ingress queue.",
	  "Desc": "CHA iMC CHNx WRITE Credits Empty",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.WRITE_NO_CREDITS.MC6": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending WRITEs from the CHA into the iMC.  In order to send WRITEs into the memory controller, the HA must first acquire a credit for the iMC's BL Ingress queue.",
	  "Desc": "CHA iMC CHNx WRITE Credits Empty",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.WRITE_NO_CREDITS.MC12": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending WRITEs from the CHA into the iMC.  In order to send WRITEs into the memory controller, the HA must first acquire a credit for the iMC's BL Ingress queue.",
	  "Desc": "CHA iMC CHNx WRITE Credits Empty",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxx1xxxx",
     },
     "CHA.WRITE_NO_CREDITS.MC11": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending WRITEs from the CHA into the iMC.  In order to send WRITEs into the memory controller, the HA must first acquire a credit for the iMC's BL Ingress queue.",
	  "Desc": "CHA iMC CHNx WRITE Credits Empty",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxx1xxx",
     },
     "CHA.WRITE_NO_CREDITS.MC1": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending WRITEs from the CHA into the iMC.  In order to send WRITEs into the memory controller, the HA must first acquire a credit for the iMC's BL Ingress queue.",
	  "Desc": "CHA iMC CHNx WRITE Credits Empty",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.WRITE_NO_CREDITS.MC0": {
	  "Box": "CHA",
	  "Category": "CHA MC Credit and Traffic Events",
	  "Defn": "Counts the number of times when there are no credits available for sending WRITEs from the CHA into the iMC.  In order to send WRITEs into the memory controller, the HA must first acquire a credit for the iMC's BL Ingress queue.",
	  "Desc": "CHA iMC CHNx WRITE Credits Empty",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
	  "UmaskExt": "bxxxxxxxx",
     },
     "CHA.XPT_PREF": {
	  "Box": "CHA",
	  "Category": "CHA XPT Events",
	  "Desc": "XPT Prefetches",
	  "EvSel": 111,
	  "ExtSel": "",
     },
     "CHA.XPT_PREF.DROP1_NOCRD": {
	  "Box": "CHA",
	  "Category": "CHA XPT Events",
	  "Desc": "XPT Prefetches",
	  "EvSel": 111,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "CHA.XPT_PREF.DROP0_CONFLICT": {
	  "Box": "CHA",
	  "Category": "CHA XPT Events",
	  "Desc": "XPT Prefetches",
	  "EvSel": 111,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "CHA.XPT_PREF.SENT0": {
	  "Box": "CHA",
	  "Category": "CHA XPT Events",
	  "Desc": "XPT Prefetches",
	  "EvSel": 111,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "CHA.XPT_PREF.DROP1_CONFLICT": {
	  "Box": "CHA",
	  "Category": "CHA XPT Events",
	  "Desc": "XPT Prefetches",
	  "EvSel": 111,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "CHA.XPT_PREF.DROP0_NOCRD": {
	  "Box": "CHA",
	  "Category": "CHA XPT Events",
	  "Desc": "XPT Prefetches",
	  "EvSel": 111,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "CHA.XPT_PREF.SENT1": {
	  "Box": "CHA",
	  "Category": "CHA XPT Events",
	  "Desc": "XPT Prefetches",
	  "EvSel": 111,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },

# IRP:
     "IRP.CACHE_TOTAL_OCCUPANCY": {
	  "Box": "IRP",
	  "Category": "IRP WRITE_CACHE Events",
	  "Counters": "0-1",
	  "Defn": "Accumulates the number of reads and writes that are outstanding in the uncore in each cycle.  This is effectively the sum of the READ_OCCUPANCY and WRITE_OCCUPANCY events.",
	  "Desc": "Total Write Cache Occupancy",
	  "EvSel": 15,
	  "ExtSel": "",
	  "MaxIncCyc": 511,
     },
     "IRP.CACHE_TOTAL_OCCUPANCY.MEM": {
	  "Box": "IRP",
	  "Category": "IRP WRITE_CACHE Events",
	  "Counters": "0-1",
	  "Defn": "Accumulates the number of reads and writes that are outstanding in the uncore in each cycle.  This is effectively the sum of the READ_OCCUPANCY and WRITE_OCCUPANCY events.",
	  "Desc": "Total Write Cache Occupancy",
	  "EvSel": 15,
	  "ExtSel": "",
	  "MaxIncCyc": 511,
	  "Umask": "b00000100",
     },
     "IRP.CACHE_TOTAL_OCCUPANCY.ANY": {
	  "Box": "IRP",
	  "Category": "IRP WRITE_CACHE Events",
	  "Counters": "0-1",
	  "Defn": "Accumulates the number of reads and writes that are outstanding in the uncore in each cycle.  This is effectively the sum of the READ_OCCUPANCY and WRITE_OCCUPANCY events.",
	  "Desc": "Total Write Cache Occupancy",
	  "EvSel": 15,
	  "ExtSel": "",
	  "MaxIncCyc": 511,
	  "Umask": "b00000001",
     },
     "IRP.CACHE_TOTAL_OCCUPANCY.IV_Q": {
	  "Box": "IRP",
	  "Category": "IRP WRITE_CACHE Events",
	  "Counters": "0-1",
	  "Defn": "Accumulates the number of reads and writes that are outstanding in the uncore in each cycle.  This is effectively the sum of the READ_OCCUPANCY and WRITE_OCCUPANCY events.",
	  "Desc": "Total Write Cache Occupancy",
	  "EvSel": 15,
	  "ExtSel": "",
	  "MaxIncCyc": 511,
	  "Umask": "b00000010",
     },
     "IRP.CLOCKTICKS": {
	  "Box": "IRP",
	  "Category": "IRP CLOCK Events",
	  "Counters": "0-1",
	  "Desc": "Clockticks of the IO coherency tracker (IRP)",
	  "EvSel": 1,
	  "ExtSel": "",
     },
     "IRP.COHERENT_OPS": {
	  "Box": "IRP",
	  "Category": "IRP Coherency Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of coherency related operations servied by the IRP",
	  "Desc": "Coherent Ops",
	  "EvSel": 16,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
     },
     "IRP.COHERENT_OPS.WBMTOI": {
	  "Box": "IRP",
	  "Category": "IRP Coherency Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of coherency related operations servied by the IRP",
	  "Desc": "Coherent Ops",
	  "EvSel": 16,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bx1xxxxxx",
     },
     "IRP.COHERENT_OPS.PCIRDCUR": {
	  "Box": "IRP",
	  "Category": "IRP Coherency Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of coherency related operations servied by the IRP",
	  "Desc": "Coherent Ops",
	  "EvSel": 16,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxxxxx1",
     },
     "IRP.COHERENT_OPS.CLFLUSH": {
	  "Box": "IRP",
	  "Category": "IRP Coherency Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of coherency related operations servied by the IRP",
	  "Desc": "Coherent Ops",
	  "EvSel": 16,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "b1xxxxxxx",
     },
     "IRP.COHERENT_OPS.RFO": {
	  "Box": "IRP",
	  "Category": "IRP Coherency Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of coherency related operations servied by the IRP",
	  "Desc": "Coherent Ops",
	  "EvSel": 16,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxx1xxx",
     },
     "IRP.COHERENT_OPS.PCITOM": {
	  "Box": "IRP",
	  "Category": "IRP Coherency Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of coherency related operations servied by the IRP",
	  "Desc": "Coherent Ops",
	  "EvSel": 16,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxx1xxxx",
     },
     "IRP.FAF_FULL": {
	  "Box": "IRP",
	  "Category": "IRP FAF Events",
	  "Counters": "0-1",
	  "Desc": "FAF RF full",
	  "EvSel": 23,
	  "ExtSel": "",
     },
     "IRP.FAF_INSERTS": {
	  "Box": "IRP",
	  "Category": "IRP FAF Events",
	  "Counters": "0-1",
	  "Defn": "Read transactions",
	  "Desc": "FAF - request insert from TC.",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Notes": "Read prefetch transactions no longer go through M2IOSF",
     },
     "IRP.FAF_OCCUPANCY": {
	  "Box": "IRP",
	  "Category": "IRP FAF Events",
	  "Counters": "0-1",
	  "Desc": "FAF occupancy",
	  "EvSel": 25,
	  "ExtSel": "",
	  "MaxIncCyc": 31,
     },
     "IRP.FAF_TRANSACTIONS": {
	  "Box": "IRP",
	  "Category": "IRP FAF Events",
	  "Counters": "0-1",
	  "Desc": "FAF allocation -- sent to ADQ",
	  "EvSel": 22,
	  "ExtSel": "",
     },
     "IRP.IRP_ALL": {
	  "Box": "IRP",
	  "Category": "IRP IRP Buffer Events",
	  "Counters": "0-1",
	  "EvSel": 32,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
     },
     "IRP.IRP_ALL.INBOUND_INSERTS": {
	  "Box": "IRP",
	  "Category": "IRP IRP Buffer Events",
	  "Counters": "0-1",
	  "EvSel": 32,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "b00000001",
     },
     "IRP.IRP_ALL.OUTBOUND_INSERTS": {
	  "Box": "IRP",
	  "Category": "IRP IRP Buffer Events",
	  "Counters": "0-1",
	  "EvSel": 32,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "b00000010",
     },
     "IRP.IRP_ALL.EVICTS": {
	  "Box": "IRP",
	  "Category": "IRP IRP Buffer Events",
	  "Counters": "0-1",
	  "EvSel": 32,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "b00000100",
     },
     "IRP.MISC0": {
	  "Box": "IRP",
	  "Category": "IRP MISC Events",
	  "Counters": "0-1",
	  "Desc": "Counts Timeouts - Set 0",
	  "EvSel": 30,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
     },
     "IRP.MISC0.FAST_REJ": {
	  "Box": "IRP",
	  "Category": "IRP MISC Events",
	  "Counters": "0-1",
	  "Desc": "Counts Timeouts - Set 0",
	  "EvSel": 30,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "b0000001x",
     },
     "IRP.MISC0.SLOWPATH_FWPF_NO_PRF": {
	  "Box": "IRP",
	  "Category": "IRP MISC Events",
	  "Counters": "0-1",
	  "Desc": "Counts Timeouts - Set 0",
	  "EvSel": 30,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "b1xx00000",
     },
     "IRP.MISC0.FAST_XFER": {
	  "Box": "IRP",
	  "Category": "IRP MISC Events",
	  "Counters": "0-1",
	  "Desc": "Counts Timeouts - Set 0",
	  "EvSel": 30,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxx100000",
     },
     "IRP.MISC0.2ND_WR_INSERT": {
	  "Box": "IRP",
	  "Category": "IRP MISC Events",
	  "Counters": "0-1",
	  "Desc": "Counts Timeouts - Set 0",
	  "EvSel": 30,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bx00x1x00",
     },
     "IRP.MISC0.2ND_RD_INSERT": {
	  "Box": "IRP",
	  "Category": "IRP MISC Events",
	  "Counters": "0-1",
	  "Desc": "Counts Timeouts - Set 0",
	  "EvSel": 30,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bx00xx100",
     },
     "IRP.MISC0.PF_ACK_HINT": {
	  "Box": "IRP",
	  "Category": "IRP MISC Events",
	  "Counters": "0-1",
	  "Desc": "Counts Timeouts - Set 0",
	  "EvSel": 30,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bx1x00000",
     },
     "IRP.MISC0.FAST_REQ": {
	  "Box": "IRP",
	  "Category": "IRP MISC Events",
	  "Counters": "0-1",
	  "Desc": "Counts Timeouts - Set 0",
	  "EvSel": 30,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "b000000x1",
     },
     "IRP.MISC0.2ND_ATOMIC_INSERT": {
	  "Box": "IRP",
	  "Category": "IRP MISC Events",
	  "Counters": "0-1",
	  "Desc": "Counts Timeouts - Set 0",
	  "EvSel": 30,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bx001xx00",
     },
     "IRP.MISC1": {
	  "Box": "IRP",
	  "Category": "IRP MISC Events",
	  "Counters": "0-1",
	  "Desc": "Misc Events - Set 1",
	  "EvSel": 31,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
     },
     "IRP.MISC1.SLOW_M": {
	  "Box": "IRP",
	  "Category": "IRP MISC Events",
	  "Counters": "0-1",
	  "Desc": "Misc Events - Set 1",
	  "EvSel": 31,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "b000x1xxx",
     },
     "IRP.MISC1.SLOW_I": {
	  "Box": "IRP",
	  "Category": "IRP MISC Events",
	  "Counters": "0-1",
	  "Desc": "Misc Events - Set 1",
	  "EvSel": 31,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "b000xxxx1",
     },
     "IRP.MISC1.SEC_RCVD_VLD": {
	  "Box": "IRP",
	  "Category": "IRP MISC Events",
	  "Counters": "0-1",
	  "Desc": "Misc Events - Set 1",
	  "EvSel": 31,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bx1xx0000",
     },
     "IRP.MISC1.SLOW_E": {
	  "Box": "IRP",
	  "Category": "IRP MISC Events",
	  "Counters": "0-1",
	  "Desc": "Misc Events - Set 1",
	  "EvSel": 31,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "b000xx1xx",
     },
     "IRP.MISC1.SEC_RCVD_INVLD": {
	  "Box": "IRP",
	  "Category": "IRP MISC Events",
	  "Counters": "0-1",
	  "Desc": "Misc Events - Set 1",
	  "EvSel": 31,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxx1x0000",
     },
     "IRP.MISC1.SLOW_S": {
	  "Box": "IRP",
	  "Category": "IRP MISC Events",
	  "Counters": "0-1",
	  "Desc": "Misc Events - Set 1",
	  "EvSel": 31,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "b000xxx1x",
     },
     "IRP.MISC1.LOST_FWD": {
	  "Box": "IRP",
	  "Category": "IRP MISC Events",
	  "Counters": "0-1",
	  "Desc": "Misc Events - Set 1",
	  "EvSel": 31,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "b0001xxxx",
     },
     "IRP.P2P_INSERTS": {
	  "Box": "IRP",
	  "Category": "IRP P2P Events",
	  "Counters": "0-1",
	  "Defn": "P2P requests from the ITC",
	  "Desc": "P2P Requests",
	  "EvSel": 20,
	  "ExtSel": "",
     },
     "IRP.P2P_OCCUPANCY": {
	  "Box": "IRP",
	  "Category": "IRP P2P Events",
	  "Counters": "0-1",
	  "Defn": "P2P B & S Queue Occupancy",
	  "Desc": "P2P Occupancy",
	  "EvSel": 21,
	  "ExtSel": "",
	  "MaxIncCyc": 63,
     },
     "IRP.P2P_TRANSACTIONS": {
	  "Box": "IRP",
	  "Category": "IRP P2P Events",
	  "Counters": "0-1",
	  "Desc": "P2P Transactions",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Notes": "Top 4 bits can be Ored.   Bottom 4 bits allow specific filtering.   .REM = 0 and .LOC = 0 == ALL.   .REM = 1 and .LOC = 1 == ALL.  .REM = 1 and .LOC = 0 then you just measure remote traffic.  .REM = 0 and .LOC = 1 then you just measure local traffic of whatever type of traffic chosen in first 4 bits.   Unsure how to define P2P target.   Some HW ID?",
     },
     "IRP.P2P_TRANSACTIONS.MSG": {
	  "Box": "IRP",
	  "Category": "IRP P2P Events",
	  "Counters": "0-1",
	  "Desc": "P2P Transactions",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Notes": "Top 4 bits can be Ored.   Bottom 4 bits allow specific filtering.   .REM = 0 and .LOC = 0 == ALL.   .REM = 1 and .LOC = 1 == ALL.  .REM = 1 and .LOC = 0 then you just measure remote traffic.  .REM = 0 and .LOC = 1 then you just measure local traffic of whatever type of traffic chosen in first 4 bits.   Unsure how to define P2P target.   Some HW ID?",
	  "Umask": "bxxxxx1xx",
     },
     "IRP.P2P_TRANSACTIONS.CMPL": {
	  "Box": "IRP",
	  "Category": "IRP P2P Events",
	  "Counters": "0-1",
	  "Desc": "P2P Transactions",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Notes": "Top 4 bits can be Ored.   Bottom 4 bits allow specific filtering.   .REM = 0 and .LOC = 0 == ALL.   .REM = 1 and .LOC = 1 == ALL.  .REM = 1 and .LOC = 0 then you just measure remote traffic.  .REM = 0 and .LOC = 1 then you just measure local traffic of whatever type of traffic chosen in first 4 bits.   Unsure how to define P2P target.   Some HW ID?",
	  "Umask": "bxxxx1xxx",
     },
     "IRP.P2P_TRANSACTIONS.RD": {
	  "Box": "IRP",
	  "Category": "IRP P2P Events",
	  "Counters": "0-1",
	  "Desc": "P2P Transactions",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Notes": "Top 4 bits can be Ored.   Bottom 4 bits allow specific filtering.   .REM = 0 and .LOC = 0 == ALL.   .REM = 1 and .LOC = 1 == ALL.  .REM = 1 and .LOC = 0 then you just measure remote traffic.  .REM = 0 and .LOC = 1 then you just measure local traffic of whatever type of traffic chosen in first 4 bits.   Unsure how to define P2P target.   Some HW ID?",
	  "Umask": "bxxxxxxx1",
     },
     "IRP.P2P_TRANSACTIONS.LOC_AND_TGT_MATCH": {
	  "Box": "IRP",
	  "Category": "IRP P2P Events",
	  "Counters": "0-1",
	  "Desc": "P2P Transactions",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Notes": "Top 4 bits can be Ored.   Bottom 4 bits allow specific filtering.   .REM = 0 and .LOC = 0 == ALL.   .REM = 1 and .LOC = 1 == ALL.  .REM = 1 and .LOC = 0 then you just measure remote traffic.  .REM = 0 and .LOC = 1 then you just measure local traffic of whatever type of traffic chosen in first 4 bits.   Unsure how to define P2P target.   Some HW ID?",
	  "Umask": "b1xxxxxxx",
     },
     "IRP.P2P_TRANSACTIONS.REM": {
	  "Box": "IRP",
	  "Category": "IRP P2P Events",
	  "Counters": "0-1",
	  "Desc": "P2P Transactions",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Notes": "Top 4 bits can be Ored.   Bottom 4 bits allow specific filtering.   .REM = 0 and .LOC = 0 == ALL.   .REM = 1 and .LOC = 1 == ALL.  .REM = 1 and .LOC = 0 then you just measure remote traffic.  .REM = 0 and .LOC = 1 then you just measure local traffic of whatever type of traffic chosen in first 4 bits.   Unsure how to define P2P target.   Some HW ID?",
	  "Umask": "bxxx1xxxx",
     },
     "IRP.P2P_TRANSACTIONS.WR": {
	  "Box": "IRP",
	  "Category": "IRP P2P Events",
	  "Counters": "0-1",
	  "Desc": "P2P Transactions",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Notes": "Top 4 bits can be Ored.   Bottom 4 bits allow specific filtering.   .REM = 0 and .LOC = 0 == ALL.   .REM = 1 and .LOC = 1 == ALL.  .REM = 1 and .LOC = 0 then you just measure remote traffic.  .REM = 0 and .LOC = 1 then you just measure local traffic of whatever type of traffic chosen in first 4 bits.   Unsure how to define P2P target.   Some HW ID?",
	  "Umask": "bxxxxxx1x",
     },
     "IRP.P2P_TRANSACTIONS.REM_AND_TGT_MATCH": {
	  "Box": "IRP",
	  "Category": "IRP P2P Events",
	  "Counters": "0-1",
	  "Desc": "P2P Transactions",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Notes": "Top 4 bits can be Ored.   Bottom 4 bits allow specific filtering.   .REM = 0 and .LOC = 0 == ALL.   .REM = 1 and .LOC = 1 == ALL.  .REM = 1 and .LOC = 0 then you just measure remote traffic.  .REM = 0 and .LOC = 1 then you just measure local traffic of whatever type of traffic chosen in first 4 bits.   Unsure how to define P2P target.   Some HW ID?",
	  "Umask": "bxx1xxxxx",
     },
     "IRP.P2P_TRANSACTIONS.LOC": {
	  "Box": "IRP",
	  "Category": "IRP P2P Events",
	  "Counters": "0-1",
	  "Desc": "P2P Transactions",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Notes": "Top 4 bits can be Ored.   Bottom 4 bits allow specific filtering.   .REM = 0 and .LOC = 0 == ALL.   .REM = 1 and .LOC = 1 == ALL.  .REM = 1 and .LOC = 0 then you just measure remote traffic.  .REM = 0 and .LOC = 1 then you just measure local traffic of whatever type of traffic chosen in first 4 bits.   Unsure how to define P2P target.   Some HW ID?",
	  "Umask": "bx1xxxxxx",
     },
     "IRP.SNOOP_RESP": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Desc": "Snoop Responses",
	  "EvSel": 18,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Notes": "The first 4 subevent bits are the Responses to the Code/Data/Invalid Snoops represented by the last 3 subevent bits.  At least 1 of the bottom 4 bits must be combined with 1 of the top 3 bits to obtain counts.  Unsure which combinations are possible.",
     },
     "IRP.SNOOP_RESP.HIT_M": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Desc": "Snoop Responses",
	  "EvSel": 18,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Notes": "The first 4 subevent bits are the Responses to the Code/Data/Invalid Snoops represented by the last 3 subevent bits.  At least 1 of the bottom 4 bits must be combined with 1 of the top 3 bits to obtain counts.  Unsure which combinations are possible.",
	  "Umask": "bxxxx1xxx",
     },
     "IRP.SNOOP_RESP.ALL_HIT": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Desc": "Snoop Responses",
	  "EvSel": 18,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Notes": "The first 4 subevent bits are the Responses to the Code/Data/Invalid Snoops represented by the last 3 subevent bits.  At least 1 of the bottom 4 bits must be combined with 1 of the top 3 bits to obtain counts.  Unsure which combinations are possible.",
	  "Umask": "b01111110",
     },
     "IRP.SNOOP_RESP.ALL_HIT_ES": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Desc": "Snoop Responses",
	  "EvSel": 18,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Notes": "The first 4 subevent bits are the Responses to the Code/Data/Invalid Snoops represented by the last 3 subevent bits.  At least 1 of the bottom 4 bits must be combined with 1 of the top 3 bits to obtain counts.  Unsure which combinations are possible.",
	  "Umask": "b01110100",
     },
     "IRP.SNOOP_RESP.ALL_HIT_M": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Desc": "Snoop Responses",
	  "EvSel": 18,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Notes": "The first 4 subevent bits are the Responses to the Code/Data/Invalid Snoops represented by the last 3 subevent bits.  At least 1 of the bottom 4 bits must be combined with 1 of the top 3 bits to obtain counts.  Unsure which combinations are possible.",
	  "Umask": "b01111000",
     },
     "IRP.SNOOP_RESP.ALL_HIT_I": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Desc": "Snoop Responses",
	  "EvSel": 18,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Notes": "The first 4 subevent bits are the Responses to the Code/Data/Invalid Snoops represented by the last 3 subevent bits.  At least 1 of the bottom 4 bits must be combined with 1 of the top 3 bits to obtain counts.  Unsure which combinations are possible.",
	  "Umask": "b01110010",
     },
     "IRP.SNOOP_RESP.MISS": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Desc": "Snoop Responses",
	  "EvSel": 18,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Notes": "The first 4 subevent bits are the Responses to the Code/Data/Invalid Snoops represented by the last 3 subevent bits.  At least 1 of the bottom 4 bits must be combined with 1 of the top 3 bits to obtain counts.  Unsure which combinations are possible.",
	  "Umask": "bxxxxxxx1",
     },
     "IRP.SNOOP_RESP.SNPINV": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Desc": "Snoop Responses",
	  "EvSel": 18,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Notes": "The first 4 subevent bits are the Responses to the Code/Data/Invalid Snoops represented by the last 3 subevent bits.  At least 1 of the bottom 4 bits must be combined with 1 of the top 3 bits to obtain counts.  Unsure which combinations are possible.",
	  "Umask": "bx1xxxxxx",
     },
     "IRP.SNOOP_RESP.SNPDATA": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Desc": "Snoop Responses",
	  "EvSel": 18,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Notes": "The first 4 subevent bits are the Responses to the Code/Data/Invalid Snoops represented by the last 3 subevent bits.  At least 1 of the bottom 4 bits must be combined with 1 of the top 3 bits to obtain counts.  Unsure which combinations are possible.",
	  "Umask": "bxx1xxxxx",
     },
     "IRP.SNOOP_RESP.HIT_I": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Desc": "Snoop Responses",
	  "EvSel": 18,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Notes": "The first 4 subevent bits are the Responses to the Code/Data/Invalid Snoops represented by the last 3 subevent bits.  At least 1 of the bottom 4 bits must be combined with 1 of the top 3 bits to obtain counts.  Unsure which combinations are possible.",
	  "Umask": "bxxxxxx1x",
     },
     "IRP.SNOOP_RESP.ALL_MISS": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Desc": "Snoop Responses",
	  "EvSel": 18,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Notes": "The first 4 subevent bits are the Responses to the Code/Data/Invalid Snoops represented by the last 3 subevent bits.  At least 1 of the bottom 4 bits must be combined with 1 of the top 3 bits to obtain counts.  Unsure which combinations are possible.",
	  "Umask": "b01110001",
     },
     "IRP.SNOOP_RESP.HIT_ES": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Desc": "Snoop Responses",
	  "EvSel": 18,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Notes": "The first 4 subevent bits are the Responses to the Code/Data/Invalid Snoops represented by the last 3 subevent bits.  At least 1 of the bottom 4 bits must be combined with 1 of the top 3 bits to obtain counts.  Unsure which combinations are possible.",
	  "Umask": "bxxxxx1xx",
     },
     "IRP.SNOOP_RESP.SNPCODE": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Desc": "Snoop Responses",
	  "EvSel": 18,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Notes": "The first 4 subevent bits are the Responses to the Code/Data/Invalid Snoops represented by the last 3 subevent bits.  At least 1 of the bottom 4 bits must be combined with 1 of the top 3 bits to obtain counts.  Unsure which combinations are possible.",
	  "Umask": "bxxx1xxxx",
     },
     "IRP.TRANSACTIONS": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of \"Inbound\" transactions from the IRP to the Uncore.  This can be filtered based on request type in addition to the source queue.  Note the special filtering equation.  We do OR-reduction on the request type.  If the SOURCE bit is set, then we also do AND qualification based on the source portID.",
	  "Desc": "Inbound Transaction Count",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Notes": "Bit 7 is a filter that can be applied to the other subevents.  Meaningless by itself.",
     },
     "IRP.TRANSACTIONS.WR_PREF": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of \"Inbound\" transactions from the IRP to the Uncore.  This can be filtered based on request type in addition to the source queue.  Note the special filtering equation.  We do OR-reduction on the request type.  If the SOURCE bit is set, then we also do AND qualification based on the source portID.",
	  "Desc": "Inbound Transaction Count",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Notes": "Bit 7 is a filter that can be applied to the other subevents.  Meaningless by itself.",
	  "Umask": "bxxxx1xxx",
     },
     "IRP.TRANSACTIONS.ATOMIC": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of \"Inbound\" transactions from the IRP to the Uncore.  This can be filtered based on request type in addition to the source queue.  Note the special filtering equation.  We do OR-reduction on the request type.  If the SOURCE bit is set, then we also do AND qualification based on the source portID.",
	  "Desc": "Inbound Transaction Count",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Notes": "Bit 7 is a filter that can be applied to the other subevents.  Meaningless by itself.",
	  "Umask": "bxxx1xxxx",
     },
     "IRP.TRANSACTIONS.WRITES": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of \"Inbound\" transactions from the IRP to the Uncore.  This can be filtered based on request type in addition to the source queue.  Note the special filtering equation.  We do OR-reduction on the request type.  If the SOURCE bit is set, then we also do AND qualification based on the source portID.",
	  "Desc": "Inbound Transaction Count",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Notes": "Bit 7 is a filter that can be applied to the other subevents.  Meaningless by itself.",
	  "Umask": "bxxxxxx1x",
     },
     "IRP.TRANSACTIONS.OTHER": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of \"Inbound\" transactions from the IRP to the Uncore.  This can be filtered based on request type in addition to the source queue.  Note the special filtering equation.  We do OR-reduction on the request type.  If the SOURCE bit is set, then we also do AND qualification based on the source portID.",
	  "Desc": "Inbound Transaction Count",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Notes": "Bit 7 is a filter that can be applied to the other subevents.  Meaningless by itself.",
	  "Umask": "bxx1xxxxx",
     },
     "IRP.TRANSACTIONS.ORDERINGQ": {
	  "Box": "IRP",
	  "Category": "IRP TRANSACTIONS Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of \"Inbound\" transactions from the IRP to the Uncore.  This can be filtered based on request type in addition to the source queue.  Note the special filtering equation.  We do OR-reduction on the request type.  If the SOURCE bit is set, then we also do AND qualification based on the source portID.",
	  "Desc": "Inbound Transaction Count",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Notes": "Bit 7 is a filter that can be applied to the other subevents.  Meaningless by itself.",
	  "Umask": "bx1xxxxxx",
     },
     "IRP.TxC_AK_INSERTS": {
	  "Box": "IRP",
	  "Category": "IRP AK Egress Events",
	  "Counters": "0-1",
	  "Desc": "AK Egress Allocations",
	  "EvSel": 11,
	  "ExtSel": "",
     },
     "IRP.TxC_BL_DRS_CYCLES_FULL": {
	  "Box": "IRP",
	  "Category": "IRP BL Egress Events",
	  "Counters": "0-1",
	  "Desc": "BL DRS Egress Cycles Full",
	  "EvSel": 5,
	  "ExtSel": "",
     },
     "IRP.TxC_BL_DRS_INSERTS": {
	  "Box": "IRP",
	  "Category": "IRP BL Egress Events",
	  "Counters": "0-1",
	  "Desc": "BL DRS Egress Inserts",
	  "EvSel": 2,
	  "ExtSel": "",
     },
     "IRP.TxC_BL_DRS_OCCUPANCY": {
	  "Box": "IRP",
	  "Category": "IRP BL Egress Events",
	  "Counters": "0-1",
	  "Desc": "BL DRS Egress Occupancy",
	  "EvSel": 8,
	  "ExtSel": "",
	  "MaxIncCyc": 63,
     },
     "IRP.TxC_BL_NCB_CYCLES_FULL": {
	  "Box": "IRP",
	  "Category": "IRP BL Egress Events",
	  "Counters": "0-1",
	  "Desc": "BL NCB Egress Cycles Full",
	  "EvSel": 6,
	  "ExtSel": "",
     },
     "IRP.TxC_BL_NCB_INSERTS": {
	  "Box": "IRP",
	  "Category": "IRP BL Egress Events",
	  "Counters": "0-1",
	  "Desc": "BL NCB Egress Inserts",
	  "EvSel": 3,
	  "ExtSel": "",
     },
     "IRP.TxC_BL_NCB_OCCUPANCY": {
	  "Box": "IRP",
	  "Category": "IRP BL Egress Events",
	  "Counters": "0-1",
	  "Desc": "BL NCB Egress Occupancy",
	  "EvSel": 9,
	  "ExtSel": "",
	  "MaxIncCyc": 31,
     },
     "IRP.TxC_BL_NCS_CYCLES_FULL": {
	  "Box": "IRP",
	  "Category": "IRP BL Egress Events",
	  "Counters": "0-1",
	  "Desc": "BL NCS Egress Cycles Full",
	  "EvSel": 7,
	  "ExtSel": "",
     },
     "IRP.TxC_BL_NCS_INSERTS": {
	  "Box": "IRP",
	  "Category": "IRP BL Egress Events",
	  "Counters": "0-1",
	  "Desc": "BL NCS Egress Inserts",
	  "EvSel": 4,
	  "ExtSel": "",
     },
     "IRP.TxC_BL_NCS_OCCUPANCY": {
	  "Box": "IRP",
	  "Category": "IRP BL Egress Events",
	  "Counters": "0-1",
	  "Desc": "BL NCS Egress Occupancy",
	  "EvSel": 10,
	  "ExtSel": "",
	  "MaxIncCyc": 15,
     },
     "IRP.TxR2_AD01_STALL_CREDIT_CYCLES": {
	  "Box": "IRP",
	  "Category": "IRP STALL_CYCLES Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number times when it is not possible to issue a request to the M2PCIe because there are no Egress Credits available on AD0, A1 or AD0&AD1 both. Stalls on both AD0 and AD1 will count as 2",
	  "EvSel": 28,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
     },
     "IRP.TxR2_AD0_STALL_CREDIT_CYCLES": {
	  "Box": "IRP",
	  "Category": "IRP STALL_CYCLES Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number times when it is not possible to issue a request to the M2PCIe because there are no AD0 Egress Credits available.",
	  "Desc": "No AD0 Egress Credits Stalls",
	  "EvSel": 26,
	  "ExtSel": "",
     },
     "IRP.TxR2_AD1_STALL_CREDIT_CYCLES": {
	  "Box": "IRP",
	  "Category": "IRP STALL_CYCLES Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number times when it is not possible to issue a request to the M2PCIe because there are no AD1 Egress Credits available.",
	  "Desc": "No AD1 Egress Credits Stalls",
	  "EvSel": 27,
	  "ExtSel": "",
     },
     "IRP.TxR2_BL_STALL_CREDIT_CYCLES": {
	  "Box": "IRP",
	  "Category": "IRP STALL_CYCLES Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number times when it is not possible to issue data to the R2PCIe because there are no BL Egress Credits available.",
	  "Desc": "No BL Egress Credit Stalls",
	  "EvSel": 29,
	  "ExtSel": "",
     },
     "IRP.TxS_DATA_INSERTS_NCB": {
	  "Box": "IRP",
	  "Category": "IRP OUTBOUND_REQUESTS Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of requests issued to the switch (towards the devices).",
	  "Desc": "Outbound Read Requests",
	  "EvSel": 13,
	  "ExtSel": "",
     },
     "IRP.TxS_DATA_INSERTS_NCS": {
	  "Box": "IRP",
	  "Category": "IRP OUTBOUND_REQUESTS Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of requests issued to the switch (towards the devices).",
	  "Desc": "Outbound Read Requests",
	  "EvSel": 14,
	  "ExtSel": "",
     },
     "IRP.TxS_REQUEST_OCCUPANCY": {
	  "Box": "IRP",
	  "Category": "IRP OUTBOUND_REQUESTS Events",
	  "Counters": "0-1",
	  "Defn": "Accumultes the number of outstanding outbound requests from the IRP to the switch (towards the devices).  This can be used in conjuection with the allocations event in order to calculate average latency of outbound requests.",
	  "Desc": "Outbound Request Queue Occupancy",
	  "EvSel": 12,
	  "ExtSel": "",
     },

# M2M:
     "M2M.AG0_AD_CRD_ACQUIRED0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
     },
     "M2M.AG0_AD_CRD_ACQUIRED0.TGR1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.AG0_AD_CRD_ACQUIRED0.TGR0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.AG0_AD_CRD_ACQUIRED0.TGR2": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.AG0_AD_CRD_ACQUIRED0.TGR4": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.AG0_AD_CRD_ACQUIRED0.TGR5": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.AG0_AD_CRD_ACQUIRED0.TGR3": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.AG0_AD_CRD_ACQUIRED0.TGR7": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "b1xxxxxxx",
     },
     "M2M.AG0_AD_CRD_ACQUIRED0.TGR6": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.AG0_AD_CRD_ACQUIRED1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 129,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
     },
     "M2M.AG0_AD_CRD_ACQUIRED1.TGR10": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 129,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.AG0_AD_CRD_ACQUIRED1.TGR9": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 129,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.AG0_AD_CRD_ACQUIRED1.TGR8": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 129,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.AG0_AD_CRD_OCCUPANCY0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
     },
     "M2M.AG0_AD_CRD_OCCUPANCY0.TGR4": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00010000",
     },
     "M2M.AG0_AD_CRD_OCCUPANCY0.TGR5": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00100000",
     },
     "M2M.AG0_AD_CRD_OCCUPANCY0.TGR6": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b01000000",
     },
     "M2M.AG0_AD_CRD_OCCUPANCY0.TGR7": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b10000000",
     },
     "M2M.AG0_AD_CRD_OCCUPANCY0.TGR3": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00001000",
     },
     "M2M.AG0_AD_CRD_OCCUPANCY0.TGR0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000001",
     },
     "M2M.AG0_AD_CRD_OCCUPANCY0.TGR1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000010",
     },
     "M2M.AG0_AD_CRD_OCCUPANCY0.TGR2": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000100",
     },
     "M2M.AG0_AD_CRD_OCCUPANCY1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 131,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
     },
     "M2M.AG0_AD_CRD_OCCUPANCY1.TGR10": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 131,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000100",
     },
     "M2M.AG0_AD_CRD_OCCUPANCY1.TGR9": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 131,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000010",
     },
     "M2M.AG0_AD_CRD_OCCUPANCY1.TGR8": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 131,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000001",
     },
     "M2M.AG0_BL_CRD_ACQUIRED0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
     },
     "M2M.AG0_BL_CRD_ACQUIRED0.TGR5": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.AG0_BL_CRD_ACQUIRED0.TGR4": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.AG0_BL_CRD_ACQUIRED0.TGR6": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.AG0_BL_CRD_ACQUIRED0.TGR3": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.AG0_BL_CRD_ACQUIRED0.TGR7": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2M.AG0_BL_CRD_ACQUIRED0.TGR0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.AG0_BL_CRD_ACQUIRED0.TGR1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.AG0_BL_CRD_ACQUIRED0.TGR2": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.AG0_BL_CRD_ACQUIRED1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 137,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M2M.AG0_BL_CRD_ACQUIRED1.TGR9": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 137,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.AG0_BL_CRD_ACQUIRED1.TGR10": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 137,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.AG0_BL_CRD_ACQUIRED1.TGR8": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 137,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.AG0_BL_CRD_OCCUPANCY0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
     },
     "M2M.AG0_BL_CRD_OCCUPANCY0.TGR2": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2M.AG0_BL_CRD_OCCUPANCY0.TGR1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2M.AG0_BL_CRD_OCCUPANCY0.TGR0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2M.AG0_BL_CRD_OCCUPANCY0.TGR7": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2M.AG0_BL_CRD_OCCUPANCY0.TGR3": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2M.AG0_BL_CRD_OCCUPANCY0.TGR6": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2M.AG0_BL_CRD_OCCUPANCY0.TGR5": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00100000",
     },
     "M2M.AG0_BL_CRD_OCCUPANCY0.TGR4": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2M.AG0_BL_CRD_OCCUPANCY1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 139,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M2M.AG0_BL_CRD_OCCUPANCY1.TGR9": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 139,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000010",
     },
     "M2M.AG0_BL_CRD_OCCUPANCY1.TGR10": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 139,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000100",
     },
     "M2M.AG0_BL_CRD_OCCUPANCY1.TGR8": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 139,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000001",
     },
     "M2M.AG1_AD_CRD_ACQUIRED0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
     },
     "M2M.AG1_AD_CRD_ACQUIRED0.TGR2": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.AG1_AD_CRD_ACQUIRED0.TGR1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.AG1_AD_CRD_ACQUIRED0.TGR0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.AG1_AD_CRD_ACQUIRED0.TGR3": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.AG1_AD_CRD_ACQUIRED0.TGR7": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "b1xxxxxxx",
     },
     "M2M.AG1_AD_CRD_ACQUIRED0.TGR6": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.AG1_AD_CRD_ACQUIRED0.TGR4": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.AG1_AD_CRD_ACQUIRED0.TGR5": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.AG1_AD_CRD_ACQUIRED1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 133,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
     },
     "M2M.AG1_AD_CRD_ACQUIRED1.TGR10": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 133,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.AG1_AD_CRD_ACQUIRED1.TGR9": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 133,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.AG1_AD_CRD_ACQUIRED1.TGR8": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 133,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.AG1_AD_CRD_OCCUPANCY0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
     },
     "M2M.AG1_AD_CRD_OCCUPANCY0.TGR2": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000100",
     },
     "M2M.AG1_AD_CRD_OCCUPANCY0.TGR0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000001",
     },
     "M2M.AG1_AD_CRD_OCCUPANCY0.TGR1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000010",
     },
     "M2M.AG1_AD_CRD_OCCUPANCY0.TGR6": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b01000000",
     },
     "M2M.AG1_AD_CRD_OCCUPANCY0.TGR3": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00001000",
     },
     "M2M.AG1_AD_CRD_OCCUPANCY0.TGR7": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b10000000",
     },
     "M2M.AG1_AD_CRD_OCCUPANCY0.TGR5": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00100000",
     },
     "M2M.AG1_AD_CRD_OCCUPANCY0.TGR4": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00010000",
     },
     "M2M.AG1_AD_CRD_OCCUPANCY1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 135,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
     },
     "M2M.AG1_AD_CRD_OCCUPANCY1.TGR8": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 135,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000001",
     },
     "M2M.AG1_AD_CRD_OCCUPANCY1.TGR9": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 135,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000010",
     },
     "M2M.AG1_AD_CRD_OCCUPANCY1.TGR10": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 135,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000100",
     },
     "M2M.AG1_BL_CRD_ACQUIRED0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
     },
     "M2M.AG1_BL_CRD_ACQUIRED0.TGR2": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.AG1_BL_CRD_ACQUIRED0.TGR1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.AG1_BL_CRD_ACQUIRED0.TGR0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.AG1_BL_CRD_ACQUIRED0.TGR7": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2M.AG1_BL_CRD_ACQUIRED0.TGR3": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.AG1_BL_CRD_ACQUIRED0.TGR6": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.AG1_BL_CRD_ACQUIRED0.TGR4": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.AG1_BL_CRD_ACQUIRED0.TGR5": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.AG1_BL_CRD_ACQUIRED1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 141,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M2M.AG1_BL_CRD_ACQUIRED1.TGR9": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 141,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.AG1_BL_CRD_ACQUIRED1.TGR10": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 141,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.AG1_BL_CRD_ACQUIRED1.TGR8": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 141,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.AG1_BL_CRD_OCCUPANCY0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
     },
     "M2M.AG1_BL_CRD_OCCUPANCY0.TGR2": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2M.AG1_BL_CRD_OCCUPANCY0.TGR0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2M.AG1_BL_CRD_OCCUPANCY0.TGR1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2M.AG1_BL_CRD_OCCUPANCY0.TGR6": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2M.AG1_BL_CRD_OCCUPANCY0.TGR7": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2M.AG1_BL_CRD_OCCUPANCY0.TGR3": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2M.AG1_BL_CRD_OCCUPANCY0.TGR4": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2M.AG1_BL_CRD_OCCUPANCY0.TGR5": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00100000",
     },
     "M2M.AG1_BL_CRD_OCCUPANCY1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 143,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M2M.AG1_BL_CRD_OCCUPANCY1.TGR9": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 143,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000010",
     },
     "M2M.AG1_BL_CRD_OCCUPANCY1.TGR10": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 143,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000100",
     },
     "M2M.AG1_BL_CRD_OCCUPANCY1.TGR8": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 143,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000001",
     },
     "M2M.BYPASS_M2M_EGRESS": {
	  "Box": "M2M",
	  "Category": "M2M BL Egress Events",
	  "Desc": "M2M to iMC Bypass",
	  "EvSel": 34,
	  "ExtSel": "",
     },
     "M2M.BYPASS_M2M_EGRESS.NOT_TAKEN": {
	  "Box": "M2M",
	  "Category": "M2M BL Egress Events",
	  "Desc": "M2M to iMC Bypass",
	  "EvSel": 34,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.BYPASS_M2M_EGRESS.TAKEN": {
	  "Box": "M2M",
	  "Category": "M2M BL Egress Events",
	  "Desc": "M2M to iMC Bypass",
	  "EvSel": 34,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.BYPASS_M2M_INGRESS": {
	  "Box": "M2M",
	  "Category": "M2M BL Ingress Events",
	  "Counters": "0-3",
	  "Desc": "M2M to iMC Bypass",
	  "EvSel": 33,
	  "ExtSel": "",
     },
     "M2M.BYPASS_M2M_INGRESS.NOT_TAKEN": {
	  "Box": "M2M",
	  "Category": "M2M BL Ingress Events",
	  "Counters": "0-3",
	  "Desc": "M2M to iMC Bypass",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.BYPASS_M2M_INGRESS.TAKEN": {
	  "Box": "M2M",
	  "Category": "M2M BL Ingress Events",
	  "Counters": "0-3",
	  "Desc": "M2M to iMC Bypass",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.CLOCKTICKS": {
	  "Box": "M2M",
	  "Category": "M2M UCLK Events",
	  "Desc": "Clockticks of the mesh to memory (M2M)",
	  "EvSel": 0,
	  "ExtSel": "",
     },
     "M2M.CMS_CLOCKTICKS": {
	  "Box": "M2M",
	  "Category": "M2M Misc Events",
	  "Desc": "CMS Clockticks",
	  "EvSel": 192,
	  "ExtSel": "",
     },
     "M2M.DIRECT2CORE_NOT_TAKEN_DIRSTATE": {
	  "Box": "M2M",
	  "Category": "M2M DIRECT2CORE Events",
	  "Counters": "0-3",
	  "Desc": "Cycles when direct to core mode, which bypasses the CHA, was disabled",
	  "EvSel": 36,
	  "ExtSel": "",
     },
     "M2M.DIRECT2CORE_NOT_TAKEN_NOTFORKED": {
	  "Box": "M2M",
	  "Category": "M2M DIRECT2CORE Events",
	  "Counters": "0-3",
	  "EvSel": 96,
	  "ExtSel": "",
     },
     "M2M.DIRECT2CORE_TXN_OVERRIDE": {
	  "Box": "M2M",
	  "Category": "M2M DIRECT2CORE Events",
	  "Counters": "0-3",
	  "Desc": "Number of reads in which direct to core transaction was overridden",
	  "EvSel": 37,
	  "ExtSel": "",
     },
     "M2M.DIRECT2UPI_NOT_TAKEN_CREDITS": {
	  "Box": "M2M",
	  "Category": "M2M DIRECT2UPI Events",
	  "Desc": "Number of reads in which direct to Intel UPI transactions were overridden",
	  "EvSel": 40,
	  "ExtSel": "",
     },
     "M2M.DIRECT2UPI_NOT_TAKEN_DIRSTATE": {
	  "Box": "M2M",
	  "Category": "M2M DIRECT2UPI Events",
	  "Desc": "Cycles when Direct2UPI was Disabled",
	  "EvSel": 39,
	  "ExtSel": "",
     },
     "M2M.DIRECT2UPI_TXN_OVERRIDE": {
	  "Box": "M2M",
	  "Category": "M2M DIRECT2UPI Events",
	  "Desc": "Number of times a direct to UPI transaction was overridden.",
	  "EvSel": 41,
	  "ExtSel": "",
     },
     "M2M.DIRECTORY_HIT": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Hit",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
     },
     "M2M.DIRECTORY_HIT.CLEAN_P": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Hit",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.DIRECTORY_HIT.DIRTY_P": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Hit",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.DIRECTORY_HIT.DIRTY_S": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Hit",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.DIRECTORY_HIT.CLEAN_A": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Hit",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
	  "Umask": "b1xxxxxxx",
     },
     "M2M.DIRECTORY_HIT.CLEAN_I": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Hit",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.DIRECTORY_HIT.DIRTY_A": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Hit",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.DIRECTORY_HIT.CLEAN_S": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Hit",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.DIRECTORY_HIT.DIRTY_I": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Hit",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.DIRECTORY_LOOKUP": {
	  "Box": "M2M",
	  "Category": "M2M DIRECTORY Events",
	  "Counters": "0-3",
	  "Desc": "Multi-socket cacheline Directory Lookups",
	  "EvSel": 45,
	  "ExtSel": "",
     },
     "M2M.DIRECTORY_LOOKUP.ANY": {
	  "Box": "M2M",
	  "Category": "M2M DIRECTORY Events",
	  "Counters": "0-3",
	  "Desc": "Multi-socket cacheline Directory Lookups",
	  "EvSel": 45,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.DIRECTORY_LOOKUP.STATE_S": {
	  "Box": "M2M",
	  "Category": "M2M DIRECTORY Events",
	  "Counters": "0-3",
	  "Desc": "Multi-socket cacheline Directory Lookups",
	  "EvSel": 45,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.DIRECTORY_LOOKUP.STATE_I": {
	  "Box": "M2M",
	  "Category": "M2M DIRECTORY Events",
	  "Counters": "0-3",
	  "Desc": "Multi-socket cacheline Directory Lookups",
	  "EvSel": 45,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.DIRECTORY_LOOKUP.STATE_A": {
	  "Box": "M2M",
	  "Category": "M2M DIRECTORY Events",
	  "Counters": "0-3",
	  "Desc": "Multi-socket cacheline Directory Lookups",
	  "EvSel": 45,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.DIRECTORY_MISS": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Miss",
	  "EvSel": 43,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
     },
     "M2M.DIRECTORY_MISS.DIRTY_A": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Miss",
	  "EvSel": 43,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.DIRECTORY_MISS.CLEAN_S": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Miss",
	  "EvSel": 43,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.DIRECTORY_MISS.DIRTY_I": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Miss",
	  "EvSel": 43,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.DIRECTORY_MISS.CLEAN_A": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Miss",
	  "EvSel": 43,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
	  "Umask": "b1xxxxxxx",
     },
     "M2M.DIRECTORY_MISS.DIRTY_S": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Miss",
	  "EvSel": 43,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.DIRECTORY_MISS.CLEAN_I": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Miss",
	  "EvSel": 43,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.DIRECTORY_MISS.DIRTY_P": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Miss",
	  "EvSel": 43,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.DIRECTORY_MISS.CLEAN_P": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Directory Miss",
	  "EvSel": 43,
	  "ExtSel": "",
	  "Notes": "Covers NearMem Reads (Demand and Underfill).",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.DISTRESS_ASSERTED": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
     },
     "M2M.DISTRESS_ASSERTED.DPT_NONLOCAL": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.DISTRESS_ASSERTED.VERT": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2M.DISTRESS_ASSERTED.PMM_NONLOCAL": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.DISTRESS_ASSERTED.HORZ": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2M.DISTRESS_ASSERTED.PMM_LOCAL": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.DISTRESS_ASSERTED.DPT_LOCAL": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.DISTRESS_ASSERTED.DPT_STALL_NOCRD": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2M.DISTRESS_ASSERTED.DPT_STALL_IV": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.DISTRESS_PMM": {
	  "Box": "M2M",
	  "Category": "M2M Distress Events",
	  "Counters": "0-3",
	  "EvSel": 242,
	  "ExtSel": "",
     },
     "M2M.DISTRESS_PMM_MEMMODE": {
	  "Box": "M2M",
	  "Category": "M2M Distress Events",
	  "Counters": "0-3",
	  "EvSel": 241,
	  "ExtSel": "",
     },
     "M2M.EGRESS_ORDERING": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts number of cycles IV was blocked in the TGR Egress due to SNP/GO Ordering requirements",
	  "Desc": "Egress Blocking due to Ordering requirements",
	  "EvSel": 186,
	  "ExtSel": "",
     },
     "M2M.EGRESS_ORDERING.IV_SNOOPGO_UP": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts number of cycles IV was blocked in the TGR Egress due to SNP/GO Ordering requirements",
	  "Desc": "Egress Blocking due to Ordering requirements",
	  "EvSel": 186,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.EGRESS_ORDERING.IV_SNOOPGO_DN": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts number of cycles IV was blocked in the TGR Egress due to SNP/GO Ordering requirements",
	  "Desc": "Egress Blocking due to Ordering requirements",
	  "EvSel": 186,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.HORZ_RING_AD_IN_USE": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
     },
     "M2M.HORZ_RING_AD_IN_USE.RIGHT_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.HORZ_RING_AD_IN_USE.LEFT_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.HORZ_RING_AD_IN_USE.LEFT_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.HORZ_RING_AD_IN_USE.RIGHT_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.HORZ_RING_AKC_IN_USE": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
     },
     "M2M.HORZ_RING_AKC_IN_USE.RIGHT_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.HORZ_RING_AKC_IN_USE.RIGHT_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.HORZ_RING_AKC_IN_USE.LEFT_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.HORZ_RING_AKC_IN_USE.LEFT_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.HORZ_RING_AK_IN_USE": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
     },
     "M2M.HORZ_RING_AK_IN_USE.RIGHT_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.HORZ_RING_AK_IN_USE.LEFT_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.HORZ_RING_AK_IN_USE.LEFT_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.HORZ_RING_AK_IN_USE.RIGHT_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.HORZ_RING_BL_IN_USE": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
     },
     "M2M.HORZ_RING_BL_IN_USE.LEFT_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.HORZ_RING_BL_IN_USE.LEFT_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.HORZ_RING_BL_IN_USE.RIGHT_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.HORZ_RING_BL_IN_USE.RIGHT_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.HORZ_RING_IV_IN_USE": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Horizontal IV Ring in Use",
	  "EvSel": 185,
	  "ExtSel": "",
     },
     "M2M.HORZ_RING_IV_IN_USE.LEFT": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Horizontal IV Ring in Use",
	  "EvSel": 185,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.HORZ_RING_IV_IN_USE.RIGHT": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Horizontal IV Ring in Use",
	  "EvSel": 185,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.IMC_READS": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
     },
     "M2M.IMC_READS.CH1_TO_DDR_AS_CACHE": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxxx1xxxx",
	  "UmaskExt": "bx1x",
     },
     "M2M.IMC_READS.TO_DDR_AS_MEM": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxxxx1xxx",
	  "UmaskExt": "b111",
     },
     "M2M.IMC_READS.NORMAL": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxxxxxxx1",
	  "UmaskExt": "b111",
     },
     "M2M.IMC_READS.CH1_FROM_TGR": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bx1xxxxxx",
	  "UmaskExt": "bx1x",
     },
     "M2M.IMC_READS.CH0_TO_PMM": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxx1xxxxx",
	  "UmaskExt": "bxx1",
     },
     "M2M.IMC_READS.ALL": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxxxxx1xx",
	  "UmaskExt": "b111",
     },
     "M2M.IMC_READS.CH1_ISOCH": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxxxxxx1x",
	  "UmaskExt": "bx1x",
     },
     "M2M.IMC_READS.CH1_TO_DDR_AS_MEM": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxxxx1xxx",
	  "UmaskExt": "bx1x",
     },
     "M2M.IMC_READS.CH1_ALL": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxxxxx1xx",
	  "UmaskExt": "bx1x",
     },
     "M2M.IMC_READS.CH0_FROM_TGR": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bx1xxxxxx",
	  "UmaskExt": "bxx1",
     },
     "M2M.IMC_READS.CH0_TO_DDR_AS_CACHE": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxxx1xxxx",
	  "UmaskExt": "bxx1",
     },
     "M2M.IMC_READS.CH1_TO_PMM": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxx1xxxxx",
	  "UmaskExt": "bx1x",
     },
     "M2M.IMC_READS.CH0_TO_DDR_AS_MEM": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxxxx1xxx",
	  "UmaskExt": "bxx1",
     },
     "M2M.IMC_READS.CH0_ISOCH": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxxxxxx1x",
	  "UmaskExt": "bxx1",
     },
     "M2M.IMC_READS.CH0_ALL": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxxxxx1xx",
	  "UmaskExt": "bxx1",
     },
     "M2M.IMC_READS.TO_PMM": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxx1xxxxx",
	  "UmaskExt": "b111",
     },
     "M2M.IMC_READS.CH1_NORMAL": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxxxxxxx1",
	  "UmaskExt": "bx1x",
     },
     "M2M.IMC_READS.CH2_FROM_TGR": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bx1xxxxxx",
	  "UmaskExt": "b1xx",
     },
     "M2M.IMC_READS.CH0_NORMAL": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxxxxxxx1",
	  "UmaskExt": "bxx1",
     },
     "M2M.IMC_READS.TO_DDR_AS_CACHE": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxxx1xxxx",
	  "UmaskExt": "b111",
     },
     "M2M.IMC_READS.FROM_TGR": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bx1xxxxxx",
	  "UmaskExt": "b111",
     },
     "M2M.IMC_READS.ISOCH": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Reads Issued to iMC",
	  "EvSel": 55,
	  "ExtSel": "",
	  "Notes": "Scrub Reads due to ECC errors not currently included",
	  "Umask": "bxxxxxx1x",
	  "UmaskExt": "b111",
     },
     "M2M.IMC_WRITES": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
     },
     "M2M.IMC_WRITES.CH1_FULL": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxxxx1",
	  "UmaskExt": "bx1xxx",
     },
     "M2M.IMC_WRITES.TO_PMM": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "b1xxxxxxx",
	  "UmaskExt": "b111xx",
     },
     "M2M.IMC_WRITES.CH0_PARTIAL_ISOCH": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxx1xxx",
	  "UmaskExt": "bxx1xx",
     },
     "M2M.IMC_WRITES.PARTIAL_ISOCH": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxx1xxx",
	  "UmaskExt": "b111xx",
     },
     "M2M.IMC_WRITES.CH1_FULL_ISOCH": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxx1xx",
	  "UmaskExt": "bx1xxx",
     },
     "M2M.IMC_WRITES.CH1_PARTIAL": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxxx1x",
	  "UmaskExt": "bx1xxx",
     },
     "M2M.IMC_WRITES.NI": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "b1111x",
     },
     "M2M.IMC_WRITES.CH1_NI": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bx1x1x",
     },
     "M2M.IMC_WRITES.TO_DDR_AS_CACHE": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bx1xxxxxx",
	  "UmaskExt": "b111xx",
     },
     "M2M.IMC_WRITES.CH1_TO_DDR_AS_CACHE": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bx1xxxxxx",
	  "UmaskExt": "bx1xxx",
     },
     "M2M.IMC_WRITES.CH0_TO_PMM": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "b1xxxxxxx",
	  "UmaskExt": "bxx1xx",
     },
     "M2M.IMC_WRITES.FULL_ISOCH": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxx1xx",
	  "UmaskExt": "b111xx",
     },
     "M2M.IMC_WRITES.CH1_ALL": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxx1xxxx",
	  "UmaskExt": "bx1xxx",
     },
     "M2M.IMC_WRITES.CH0_FROM_TGR": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxx1x1",
     },
     "M2M.IMC_WRITES.CH0_NI_MISS": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "b1xxxxx",
     },
     "M2M.IMC_WRITES.CH0_TO_DDR_AS_MEM": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxx1xxxxx",
	  "UmaskExt": "bxx1xx",
     },
     "M2M.IMC_WRITES.FULL": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxxxx1",
	  "UmaskExt": "b111xx",
     },
     "M2M.IMC_WRITES.PARTIAL": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxxx1x",
	  "UmaskExt": "b111xx",
     },
     "M2M.IMC_WRITES.CH0_FULL": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxxxx1",
	  "UmaskExt": "bxx1xx",
     },
     "M2M.IMC_WRITES.CH0_FULL_ISOCH": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxx1xx",
	  "UmaskExt": "bxx1xx",
     },
     "M2M.IMC_WRITES.NI_MISS": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "b111xx",
     },
     "M2M.IMC_WRITES.CH1_PARTIAL_ISOCH": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxx1xxx",
	  "UmaskExt": "bx1xxx",
     },
     "M2M.IMC_WRITES.FROM_TGR": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "b111x1",
     },
     "M2M.IMC_WRITES.CH0_PARTIAL": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxxx1x",
	  "UmaskExt": "bxx1xx",
     },
     "M2M.IMC_WRITES.CH0_NI": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxx11x",
     },
     "M2M.IMC_WRITES.CH1_FROM_TGR": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bx1xx1",
     },
     "M2M.IMC_WRITES.TO_DDR_AS_MEM": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxx1xxxxx",
	  "UmaskExt": "b111xx",
     },
     "M2M.IMC_WRITES.ALL": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxx1xxxx",
	  "UmaskExt": "b111xx",
     },
     "M2M.IMC_WRITES.CH1_TO_DDR_AS_MEM": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxx1xxxxx",
	  "UmaskExt": "bx1xxx",
     },
     "M2M.IMC_WRITES.CH1_NI_MISS": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bx11xx",
     },
     "M2M.IMC_WRITES.CH0_TO_DDR_AS_CACHE": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bx1xxxxxx",
	  "UmaskExt": "bxx1xx",
     },
     "M2M.IMC_WRITES.CH1_TO_PMM": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "b1xxxxxxx",
	  "UmaskExt": "bx1xxx",
     },
     "M2M.IMC_WRITES.CH0_ALL": {
	  "Box": "M2M",
	  "Category": "M2M IMC Events",
	  "Counters": "0-3",
	  "Desc": "M2M Writes Issued to iMC",
	  "EvSel": 56,
	  "ExtSel": "",
	  "Notes": "Scrub Writes due to ECC errors not currently included",
	  "Umask": "bxxx1xxxx",
	  "UmaskExt": "bxx1xx",
     },
     "M2M.MIRR_WRQ_INSERTS": {
	  "Box": "M2M",
	  "Category": "M2M Mirror WriteQ EVENTS",
	  "Desc": "Write Tracker Inserts",
	  "EvSel": 100,
	  "ExtSel": "",
     },
     "M2M.MIRR_WRQ_OCCUPANCY": {
	  "Box": "M2M",
	  "Category": "M2M Mirror WriteQ EVENTS",
	  "Desc": "Write Tracker Occupancy",
	  "EvSel": 101,
	  "ExtSel": "",
     },
     "M2M.MISC_EXTERNAL": {
	  "Box": "M2M",
	  "Category": "M2M External Misc Events (eg. From MS2IDI)",
	  "Desc": "Miscellaneous Events (mostly from MS2IDI)",
	  "EvSel": 230,
	  "ExtSel": "",
	  "Notes": "ONLY relevant to the CHA's CMS",
     },
     "M2M.MISC_EXTERNAL.MBE_INST1": {
	  "Box": "M2M",
	  "Category": "M2M External Misc Events (eg. From MS2IDI)",
	  "Desc": "Miscellaneous Events (mostly from MS2IDI)",
	  "EvSel": 230,
	  "ExtSel": "",
	  "Notes": "ONLY relevant to the CHA's CMS",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.MISC_EXTERNAL.MBE_INST0": {
	  "Box": "M2M",
	  "Category": "M2M External Misc Events (eg. From MS2IDI)",
	  "Desc": "Miscellaneous Events (mostly from MS2IDI)",
	  "EvSel": 230,
	  "ExtSel": "",
	  "Notes": "ONLY relevant to the CHA's CMS",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.PKT_MATCH": {
	  "Box": "M2M",
	  "Category": "M2M PACKET MATCH Events",
	  "Desc": "Number Packet Header Matches",
	  "EvSel": 76,
	  "ExtSel": "",
     },
     "M2M.PKT_MATCH.MC": {
	  "Box": "M2M",
	  "Category": "M2M PACKET MATCH Events",
	  "Desc": "Number Packet Header Matches",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.PKT_MATCH.MESH": {
	  "Box": "M2M",
	  "Category": "M2M PACKET MATCH Events",
	  "Desc": "Number Packet Header Matches",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.PREFCAM_CIS_DROPS": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "EvSel": 115,
	  "ExtSel": "",
     },
     "M2M.PREFCAM_CYCLES_FULL": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Cycles Full",
	  "EvSel": 107,
	  "ExtSel": "",
     },
     "M2M.PREFCAM_CYCLES_FULL.CH2": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Cycles Full",
	  "EvSel": 107,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.PREFCAM_CYCLES_FULL.CH1": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Cycles Full",
	  "EvSel": 107,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.PREFCAM_CYCLES_FULL.ALLCH": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Cycles Full",
	  "EvSel": 107,
	  "ExtSel": "",
	  "Umask": "bxxxxx111",
     },
     "M2M.PREFCAM_CYCLES_FULL.CH0": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Cycles Full",
	  "EvSel": 107,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.PREFCAM_CYCLES_NE": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Cycles Not Empty",
	  "EvSel": 108,
	  "ExtSel": "",
     },
     "M2M.PREFCAM_CYCLES_NE.CH2": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Cycles Not Empty",
	  "EvSel": 108,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.PREFCAM_CYCLES_NE.CH1": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Cycles Not Empty",
	  "EvSel": 108,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.PREFCAM_CYCLES_NE.ALLCH": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Cycles Not Empty",
	  "EvSel": 108,
	  "ExtSel": "",
	  "Umask": "bxxxxx111",
     },
     "M2M.PREFCAM_CYCLES_NE.CH0": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Cycles Not Empty",
	  "EvSel": 108,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.PREFCAM_DEALLOCS": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Deallocs",
	  "EvSel": 110,
	  "ExtSel": "",
     },
     "M2M.PREFCAM_DEALLOCS.CH2_MISS_INVAL": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Deallocs",
	  "EvSel": 110,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxx1xx",
     },
     "M2M.PREFCAM_DEALLOCS.CH2_RSP_PDRESET": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Deallocs",
	  "EvSel": 110,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxx1xxx",
     },
     "M2M.PREFCAM_DEALLOCS.CH0_HITA0_INVAL": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Deallocs",
	  "EvSel": 110,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DEALLOCS.CH0_HITA1_INVAL": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Deallocs",
	  "EvSel": 110,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DEALLOCS.CH1_MISS_INVAL": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Deallocs",
	  "EvSel": 110,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DEALLOCS.CH1_RSP_PDRESET": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Deallocs",
	  "EvSel": 110,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DEALLOCS.CH2_HITA1_INVAL": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Deallocs",
	  "EvSel": 110,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxx1x",
     },
     "M2M.PREFCAM_DEALLOCS.CH1_HITA0_INVAL": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Deallocs",
	  "EvSel": 110,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DEALLOCS.CH1_HITA1_INVAL": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Deallocs",
	  "EvSel": 110,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DEALLOCS.CH2_HITA0_INVAL": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Deallocs",
	  "EvSel": 110,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxx1",
     },
     "M2M.PREFCAM_DEALLOCS.CH0_RSP_PDRESET": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Deallocs",
	  "EvSel": 110,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DEALLOCS.CH0_MISS_INVAL": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Deallocs",
	  "EvSel": 110,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DEMAND_DROPS": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped",
	  "EvSel": 111,
	  "ExtSel": "",
     },
     "M2M.PREFCAM_DEMAND_DROPS.CH0_XPT": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped",
	  "EvSel": 111,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.PREFCAM_DEMAND_DROPS.CH0_UPI": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped",
	  "EvSel": 111,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.PREFCAM_DEMAND_DROPS.CH2_UPI": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped",
	  "EvSel": 111,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.PREFCAM_DEMAND_DROPS.UPI_ALLCH": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped",
	  "EvSel": 111,
	  "ExtSel": "",
	  "Umask": "b000101010",
     },
     "M2M.PREFCAM_DEMAND_DROPS.XPT_ALLCH": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped",
	  "EvSel": 111,
	  "ExtSel": "",
	  "Umask": "b000010101",
     },
     "M2M.PREFCAM_DEMAND_DROPS.CH2_XPT": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped",
	  "EvSel": 111,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.PREFCAM_DEMAND_DROPS.CH1_XPT": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped",
	  "EvSel": 111,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.PREFCAM_DEMAND_DROPS.CH1_UPI": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped",
	  "EvSel": 111,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.PREFCAM_DEMAND_MERGE": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Demands Merged with CAMed Prefetches",
	  "EvSel": 116,
	  "ExtSel": "",
     },
     "M2M.PREFCAM_DEMAND_MERGE.CH2_XPTUPI": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Demands Merged with CAMed Prefetches",
	  "EvSel": 116,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.PREFCAM_DEMAND_MERGE.XPTUPI_ALLCH": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Demands Merged with CAMed Prefetches",
	  "EvSel": 116,
	  "ExtSel": "",
	  "Umask": "b000010101",
     },
     "M2M.PREFCAM_DEMAND_MERGE.CH1_XPTUPI": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Demands Merged with CAMed Prefetches",
	  "EvSel": 116,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.PREFCAM_DEMAND_MERGE.CH0_XPTUPI": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Demands Merged with CAMed Prefetches",
	  "EvSel": 116,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.PREFCAM_DEMAND_NO_MERGE": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Demands Not Merged with CAMed Prefetches",
	  "EvSel": 117,
	  "ExtSel": "",
     },
     "M2M.PREFCAM_DEMAND_NO_MERGE.CH0_XPTUPI": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Demands Not Merged with CAMed Prefetches",
	  "EvSel": 117,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.PREFCAM_DEMAND_NO_MERGE.CH1_XPTUPI": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Demands Not Merged with CAMed Prefetches",
	  "EvSel": 117,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.PREFCAM_DEMAND_NO_MERGE.XPTUPI_ALLCH": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Demands Not Merged with CAMed Prefetches",
	  "EvSel": 117,
	  "ExtSel": "",
	  "Umask": "b000010101",
     },
     "M2M.PREFCAM_DEMAND_NO_MERGE.CH2_XPTUPI": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Demands Not Merged with CAMed Prefetches",
	  "EvSel": 117,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH0": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch0 - Reasons",
	  "EvSel": 112,
	  "ExtSel": "",
     },
     "M2M.PREFCAM_DROP_REASONS_CH0.PF_AD_CRD": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch0 - Reasons",
	  "EvSel": 112,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH0.ERRORBLK_RxC": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch0 - Reasons",
	  "EvSel": 112,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH0.XPT_THRESH": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch0 - Reasons",
	  "EvSel": 112,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxx1x",
     },
     "M2M.PREFCAM_DROP_REASONS_CH0.UPI_THRESH": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch0 - Reasons",
	  "EvSel": 112,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxx1xx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH0.RPQ_PROXY": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch0 - Reasons",
	  "EvSel": 112,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxx1",
     },
     "M2M.PREFCAM_DROP_REASONS_CH0.WPQ_PROXY": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch0 - Reasons",
	  "EvSel": 112,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH0.PF_CAM_HIT": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch0 - Reasons",
	  "EvSel": 112,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH0.STOP_B2B": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch0 - Reasons",
	  "EvSel": 112,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH0.PF_CAM_FULL": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch0 - Reasons",
	  "EvSel": 112,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH0.NOT_PF_SAD_REGION": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch0 - Reasons",
	  "EvSel": 112,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH0.PF_SECURE_DROP": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch0 - Reasons",
	  "EvSel": 112,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH1": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch1 - Reasons",
	  "EvSel": 113,
	  "ExtSel": "",
     },
     "M2M.PREFCAM_DROP_REASONS_CH1.NOT_PF_SAD_REGION": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch1 - Reasons",
	  "EvSel": 113,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH1.PF_SECURE_DROP": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch1 - Reasons",
	  "EvSel": 113,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH1.WPQ_PROXY": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch1 - Reasons",
	  "EvSel": 113,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH1.PF_CAM_HIT": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch1 - Reasons",
	  "EvSel": 113,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH1.STOP_B2B": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch1 - Reasons",
	  "EvSel": 113,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH1.PF_CAM_FULL": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch1 - Reasons",
	  "EvSel": 113,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH1.ERRORBLK_RxC": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch1 - Reasons",
	  "EvSel": 113,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH1.UPI_THRESH": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch1 - Reasons",
	  "EvSel": 113,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxx1xx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH1.XPT_THRESH": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch1 - Reasons",
	  "EvSel": 113,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxx1x",
     },
     "M2M.PREFCAM_DROP_REASONS_CH1.RPQ_PROXY": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch1 - Reasons",
	  "EvSel": 113,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxx1",
     },
     "M2M.PREFCAM_DROP_REASONS_CH1.PF_AD_CRD": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch1 - Reasons",
	  "EvSel": 113,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH2": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch2 - Reasons",
	  "EvSel": 114,
	  "ExtSel": "",
     },
     "M2M.PREFCAM_DROP_REASONS_CH2.NOT_PF_SAD_REGION": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch2 - Reasons",
	  "EvSel": 114,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH2.PF_SECURE_DROP": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch2 - Reasons",
	  "EvSel": 114,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH2.STOP_B2B": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch2 - Reasons",
	  "EvSel": 114,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH2.PF_CAM_HIT": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch2 - Reasons",
	  "EvSel": 114,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH2.WPQ_PROXY": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch2 - Reasons",
	  "EvSel": 114,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH2.PF_CAM_FULL": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch2 - Reasons",
	  "EvSel": 114,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH2.XPT_THRESH": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch2 - Reasons",
	  "EvSel": 114,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxx1x",
     },
     "M2M.PREFCAM_DROP_REASONS_CH2.UPI_THRESH": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch2 - Reasons",
	  "EvSel": 114,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxx1xx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH2.ERRORBLK_RxC": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch2 - Reasons",
	  "EvSel": 114,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_DROP_REASONS_CH2.RPQ_PROXY": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch2 - Reasons",
	  "EvSel": 114,
	  "ExtSel": "",
	  "Umask": "bxxxxxxxx",
	  "UmaskExt": "bxxxxxxx1",
     },
     "M2M.PREFCAM_DROP_REASONS_CH2.PF_AD_CRD": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Data Prefetches Dropped Ch2 - Reasons",
	  "EvSel": 114,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
	  "UmaskExt": "bxxxxxxxx",
     },
     "M2M.PREFCAM_INSERTS": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Inserts",
	  "EvSel": 109,
	  "ExtSel": "",
     },
     "M2M.PREFCAM_INSERTS.CH1_XPT": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Inserts",
	  "EvSel": 109,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.PREFCAM_INSERTS.CH1_UPI": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Inserts",
	  "EvSel": 109,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.PREFCAM_INSERTS.CH2_UPI": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Inserts",
	  "EvSel": 109,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.PREFCAM_INSERTS.UPI_ALLCH": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Inserts",
	  "EvSel": 109,
	  "ExtSel": "",
	  "Umask": "b000101010",
     },
     "M2M.PREFCAM_INSERTS.XPT_ALLCH": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Inserts",
	  "EvSel": 109,
	  "ExtSel": "",
	  "Umask": "b000010101",
     },
     "M2M.PREFCAM_INSERTS.CH2_XPT": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Inserts",
	  "EvSel": 109,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.PREFCAM_INSERTS.CH0_XPT": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Inserts",
	  "EvSel": 109,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.PREFCAM_INSERTS.CH0_UPI": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Inserts",
	  "EvSel": 109,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.PREFCAM_OCCUPANCY": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Occupancy",
	  "EvSel": 106,
	  "ExtSel": "",
     },
     "M2M.PREFCAM_OCCUPANCY.CH2": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Occupancy",
	  "EvSel": 106,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.PREFCAM_OCCUPANCY.ALLCH": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Occupancy",
	  "EvSel": 106,
	  "ExtSel": "",
	  "Umask": "bxxxxx111",
     },
     "M2M.PREFCAM_OCCUPANCY.CH1": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Occupancy",
	  "EvSel": 106,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.PREFCAM_OCCUPANCY.CH0": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "Desc": "Prefetch CAM Occupancy",
	  "EvSel": 106,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.PREFCAM_RESP_MISS": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "EvSel": 118,
	  "ExtSel": "",
     },
     "M2M.PREFCAM_RESP_MISS.CH1": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "EvSel": 118,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.PREFCAM_RESP_MISS.ALLCH": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "EvSel": 118,
	  "ExtSel": "",
	  "Umask": "bxxxxx111",
     },
     "M2M.PREFCAM_RESP_MISS.CH0": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "EvSel": 118,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.PREFCAM_RESP_MISS.CH2": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "EvSel": 118,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.PREFCAM_RxC_CYCLES_NE": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "EvSel": 121,
	  "ExtSel": "",
     },
     "M2M.PREFCAM_RxC_DEALLOCS": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "EvSel": 122,
	  "ExtSel": "",
     },
     "M2M.PREFCAM_RxC_DEALLOCS.SQUASHED": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "EvSel": 122,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.PREFCAM_RxC_DEALLOCS.PMM_MEMMODE_ACCEPT": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "EvSel": 122,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.PREFCAM_RxC_DEALLOCS.1LM_POSTED": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "EvSel": 122,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.PREFCAM_RxC_DEALLOCS.CIS": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "EvSel": 122,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.PREFCAM_RxC_INSERTS": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "EvSel": 120,
	  "ExtSel": "",
     },
     "M2M.PREFCAM_RxC_OCCUPANCY": {
	  "Box": "M2M",
	  "Category": "M2M Prefetch CAM Events",
	  "EvSel": 119,
	  "ExtSel": "",
     },
     "M2M.RING_BOUNCES_HORZ": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
     },
     "M2M.RING_BOUNCES_HORZ.IV": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.RING_BOUNCES_HORZ.BL": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.RING_BOUNCES_HORZ.AK": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.RING_BOUNCES_HORZ.AD": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.RING_BOUNCES_VERT": {
	  "Box": "M2M",
	  "Category": "M2M Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
     },
     "M2M.RING_BOUNCES_VERT.AK": {
	  "Box": "M2M",
	  "Category": "M2M Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxxxx1x",
     },
     "M2M.RING_BOUNCES_VERT.AKC": {
	  "Box": "M2M",
	  "Category": "M2M Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxx1xxxx",
     },
     "M2M.RING_BOUNCES_VERT.IV": {
	  "Box": "M2M",
	  "Category": "M2M Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxx1xxx",
     },
     "M2M.RING_BOUNCES_VERT.BL": {
	  "Box": "M2M",
	  "Category": "M2M Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxxx1xx",
     },
     "M2M.RING_BOUNCES_VERT.AD": {
	  "Box": "M2M",
	  "Category": "M2M Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxxxxx1",
     },
     "M2M.RING_SINK_STARVED_HORZ": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
     },
     "M2M.RING_SINK_STARVED_HORZ.AD": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.RING_SINK_STARVED_HORZ.AK_AG1": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.RING_SINK_STARVED_HORZ.AK": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.RING_SINK_STARVED_HORZ.IV": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.RING_SINK_STARVED_HORZ.BL": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.RING_SINK_STARVED_VERT": {
	  "Box": "M2M",
	  "Category": "M2M Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
     },
     "M2M.RING_SINK_STARVED_VERT.AK": {
	  "Box": "M2M",
	  "Category": "M2M Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.RING_SINK_STARVED_VERT.AKC": {
	  "Box": "M2M",
	  "Category": "M2M Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.RING_SINK_STARVED_VERT.IV": {
	  "Box": "M2M",
	  "Category": "M2M Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.RING_SINK_STARVED_VERT.BL": {
	  "Box": "M2M",
	  "Category": "M2M Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.RING_SINK_STARVED_VERT.AD": {
	  "Box": "M2M",
	  "Category": "M2M Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.RING_SRC_THRTL": {
	  "Box": "M2M",
	  "Category": "M2M Horizontal  RING Events",
	  "Desc": "Source Throttle",
	  "EvSel": 174,
	  "ExtSel": "",
     },
     "M2M.RPQ_NO_REG_CRD": {
	  "Box": "M2M",
	  "Category": "M2M RPQ CREDIT Events",
	  "Desc": "M2M to iMC RPQ Cycles w/Credits - Regular",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
     },
     "M2M.RPQ_NO_REG_CRD.CH2": {
	  "Box": "M2M",
	  "Category": "M2M RPQ CREDIT Events",
	  "Desc": "M2M to iMC RPQ Cycles w/Credits - Regular",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.RPQ_NO_REG_CRD.CH0": {
	  "Box": "M2M",
	  "Category": "M2M RPQ CREDIT Events",
	  "Desc": "M2M to iMC RPQ Cycles w/Credits - Regular",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.RPQ_NO_REG_CRD.CH1": {
	  "Box": "M2M",
	  "Category": "M2M RPQ CREDIT Events",
	  "Desc": "M2M to iMC RPQ Cycles w/Credits - Regular",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.RPQ_NO_REG_CRD_PMM": {
	  "Box": "M2M",
	  "Category": "M2M RPQ CREDIT Events",
	  "Desc": "M2M->iMC RPQ Cycles w/Credits - PMM",
	  "EvSel": 79,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
     },
     "M2M.RPQ_NO_REG_CRD_PMM.CHN0": {
	  "Box": "M2M",
	  "Category": "M2M RPQ CREDIT Events",
	  "Desc": "M2M->iMC RPQ Cycles w/Credits - PMM",
	  "EvSel": 79,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.RPQ_NO_REG_CRD_PMM.CHN1": {
	  "Box": "M2M",
	  "Category": "M2M RPQ CREDIT Events",
	  "Desc": "M2M->iMC RPQ Cycles w/Credits - PMM",
	  "EvSel": 79,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.RPQ_NO_REG_CRD_PMM.CHN2": {
	  "Box": "M2M",
	  "Category": "M2M RPQ CREDIT Events",
	  "Desc": "M2M->iMC RPQ Cycles w/Credits - PMM",
	  "EvSel": 79,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.RPQ_NO_SPEC_CRD": {
	  "Box": "M2M",
	  "Category": "M2M RPQ CREDIT Events",
	  "Desc": "M2M to iMC RPQ Cycles w/Credits - Special",
	  "EvSel": 68,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
     },
     "M2M.RPQ_NO_SPEC_CRD.CH0": {
	  "Box": "M2M",
	  "Category": "M2M RPQ CREDIT Events",
	  "Desc": "M2M to iMC RPQ Cycles w/Credits - Special",
	  "EvSel": 68,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.RPQ_NO_SPEC_CRD.CH1": {
	  "Box": "M2M",
	  "Category": "M2M RPQ CREDIT Events",
	  "Desc": "M2M to iMC RPQ Cycles w/Credits - Special",
	  "EvSel": 68,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.RPQ_NO_SPEC_CRD.CH2": {
	  "Box": "M2M",
	  "Category": "M2M RPQ CREDIT Events",
	  "Desc": "M2M to iMC RPQ Cycles w/Credits - Special",
	  "EvSel": 68,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.RxC_AD_CYCLES_FULL": {
	  "Box": "M2M",
	  "Category": "M2M AD Ingress Events",
	  "Desc": "AD Ingress (from CMS) Full",
	  "EvSel": 4,
	  "ExtSel": "",
     },
     "M2M.RxC_AD_CYCLES_NE": {
	  "Box": "M2M",
	  "Category": "M2M AD Ingress Events",
	  "Desc": "AD Ingress (from CMS) Not Empty",
	  "EvSel": 3,
	  "ExtSel": "",
     },
     "M2M.RxC_AD_INSERTS": {
	  "Box": "M2M",
	  "Category": "M2M AD Ingress Events",
	  "Desc": "AD Ingress (from CMS) Allocations",
	  "EvSel": 1,
	  "ExtSel": "",
     },
     "M2M.RxC_AD_OCCUPANCY": {
	  "Box": "M2M",
	  "Category": "M2M AD Ingress Events",
	  "Desc": "AD Ingress (from CMS) Occupancy",
	  "EvSel": 2,
	  "ExtSel": "",
     },
     "M2M.RxC_AD_PREF_OCCUPANCY": {
	  "Box": "M2M",
	  "Category": "M2M AD Ingress Events",
	  "Desc": "AD Ingress (from CMS) Occupancy - Prefetches",
	  "EvSel": 119,
	  "ExtSel": "",
     },
     "M2M.RxC_AK_WR_CMP": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Allocations",
	  "EvSel": 92,
	  "ExtSel": "",
     },
     "M2M.RxC_BL_CYCLES_FULL": {
	  "Box": "M2M",
	  "Category": "M2M BL Ingress Events",
	  "Desc": "BL Ingress (from CMS) Full",
	  "EvSel": 8,
	  "ExtSel": "",
     },
     "M2M.RxC_BL_CYCLES_NE": {
	  "Box": "M2M",
	  "Category": "M2M BL Ingress Events",
	  "Desc": "BL Ingress (from CMS) Not Empty",
	  "EvSel": 7,
	  "ExtSel": "",
     },
     "M2M.RxC_BL_INSERTS": {
	  "Box": "M2M",
	  "Category": "M2M BL Ingress Events",
	  "Desc": "BL Ingress (from CMS) Allocations",
	  "EvSel": 5,
	  "ExtSel": "",
     },
     "M2M.RxC_BL_OCCUPANCY": {
	  "Box": "M2M",
	  "Category": "M2M BL Ingress Events",
	  "Desc": "BL Ingress (from CMS) Occupancy",
	  "EvSel": 6,
	  "ExtSel": "",
     },
     "M2M.RxR_BUSY_STARVED": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
     },
     "M2M.RxR_BUSY_STARVED.BL_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "M2M.RxR_BUSY_STARVED.BL_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000000",
     },
     "M2M.RxR_BUSY_STARVED.AD_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "M2M.RxR_BUSY_STARVED.BL_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "M2M.RxR_BUSY_STARVED.AD_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "M2M.RxR_BUSY_STARVED.AD_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "M2M.RxR_BYPASS": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
     },
     "M2M.RxR_BYPASS.BL_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000000",
     },
     "M2M.RxR_BYPASS.AK": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000010",
     },
     "M2M.RxR_BYPASS.AD_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "M2M.RxR_BYPASS.BL_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "M2M.RxR_BYPASS.AD_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "M2M.RxR_BYPASS.AKC_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b10000000",
     },
     "M2M.RxR_BYPASS.IV": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00001000",
     },
     "M2M.RxR_BYPASS.BL_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "M2M.RxR_BYPASS.AD_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "M2M.RxR_CRD_STARVED": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
     },
     "M2M.RxR_CRD_STARVED.BL_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b01000000",
     },
     "M2M.RxR_CRD_STARVED.AK": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00000010",
     },
     "M2M.RxR_CRD_STARVED.AD_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "M2M.RxR_CRD_STARVED.IFV": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b10000000",
     },
     "M2M.RxR_CRD_STARVED.BL_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "M2M.RxR_CRD_STARVED.AD_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "M2M.RxR_CRD_STARVED.IV": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00001000",
     },
     "M2M.RxR_CRD_STARVED.BL_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "M2M.RxR_CRD_STARVED.AD_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "M2M.RxR_CRD_STARVED_1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 228,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
     },
     "M2M.RxR_INSERTS": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
     },
     "M2M.RxR_INSERTS.AD_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "M2M.RxR_INSERTS.BL_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "M2M.RxR_INSERTS.AKC_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b10000000",
     },
     "M2M.RxR_INSERTS.IV": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00001000",
     },
     "M2M.RxR_INSERTS.AD_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "M2M.RxR_INSERTS.BL_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "M2M.RxR_INSERTS.AD_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "M2M.RxR_INSERTS.AK": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000010",
     },
     "M2M.RxR_INSERTS.BL_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000000",
     },
     "M2M.RxR_OCCUPANCY": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
     },
     "M2M.RxR_OCCUPANCY.AD_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "M2M.RxR_OCCUPANCY.BL_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "M2M.RxR_OCCUPANCY.AK": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000010",
     },
     "M2M.RxR_OCCUPANCY.AD_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "M2M.RxR_OCCUPANCY.BL_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00100000",
     },
     "M2M.RxR_OCCUPANCY.AD_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "M2M.RxR_OCCUPANCY.AKC_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b10000000",
     },
     "M2M.RxR_OCCUPANCY.BL_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "M2M.RxR_OCCUPANCY.IV": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00001000",
     },
     "M2M.SCOREBOARD_AD_RETRY_ACCEPTS": {
	  "Box": "M2M",
	  "Category": "M2M Scoreboard Events",
	  "EvSel": 51,
	  "ExtSel": "",
     },
     "M2M.SCOREBOARD_AD_RETRY_REJECTS": {
	  "Box": "M2M",
	  "Category": "M2M Scoreboard Events",
	  "EvSel": 52,
	  "ExtSel": "",
     },
     "M2M.SCOREBOARD_BL_RETRY_ACCEPTS": {
	  "Box": "M2M",
	  "Category": "M2M Scoreboard Events",
	  "Desc": "Retry - Mem Mirroring Mode",
	  "EvSel": 53,
	  "ExtSel": "",
     },
     "M2M.SCOREBOARD_BL_RETRY_REJECTS": {
	  "Box": "M2M",
	  "Category": "M2M Scoreboard Events",
	  "Desc": "Retry - Mem Mirroring Mode",
	  "EvSel": 54,
	  "ExtSel": "",
     },
     "M2M.SCOREBOARD_RD_ACCEPTS": {
	  "Box": "M2M",
	  "Category": "M2M Scoreboard Events",
	  "Desc": "Scoreboard Accepts",
	  "EvSel": 47,
	  "ExtSel": "",
     },
     "M2M.SCOREBOARD_RD_REJECTS": {
	  "Box": "M2M",
	  "Category": "M2M Scoreboard Events",
	  "Desc": "Scoreboard Rejects",
	  "EvSel": 48,
	  "ExtSel": "",
     },
     "M2M.SCOREBOARD_WR_ACCEPTS": {
	  "Box": "M2M",
	  "Category": "M2M Scoreboard Events",
	  "Desc": "Scoreboard Accepts",
	  "EvSel": 49,
	  "ExtSel": "",
     },
     "M2M.SCOREBOARD_WR_REJECTS": {
	  "Box": "M2M",
	  "Category": "M2M Scoreboard Events",
	  "Desc": "Scoreboard Rejects",
	  "EvSel": 50,
	  "ExtSel": "",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR7": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR3": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR6": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR5": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR4": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR2": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR4": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR5": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR7": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR3": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR6": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR2": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR4": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR5": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR7": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR3": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR6": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR2": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR3": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR7": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR6": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR5": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR4": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR2": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.STALL1_NO_TxR_HORZ_CRD_AD_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 209,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M2M.STALL1_NO_TxR_HORZ_CRD_AD_AG0.TGR8": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 209,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.STALL1_NO_TxR_HORZ_CRD_AD_AG0.TGR9": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 209,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.STALL1_NO_TxR_HORZ_CRD_AD_AG0.TGR10": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 209,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.STALL1_NO_TxR_HORZ_CRD_AD_AG1_1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M2M.STALL1_NO_TxR_HORZ_CRD_AD_AG1_1.TGR9": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.STALL1_NO_TxR_HORZ_CRD_AD_AG1_1.TGR10": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.STALL1_NO_TxR_HORZ_CRD_AD_AG1_1.TGR8": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.STALL1_NO_TxR_HORZ_CRD_BL_AG0_1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 213,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M2M.STALL1_NO_TxR_HORZ_CRD_BL_AG0_1.TGR8": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 213,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.STALL1_NO_TxR_HORZ_CRD_BL_AG0_1.TGR10": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 213,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.STALL1_NO_TxR_HORZ_CRD_BL_AG0_1.TGR9": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 213,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.STALL1_NO_TxR_HORZ_CRD_BL_AG1_1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M2M.STALL1_NO_TxR_HORZ_CRD_BL_AG1_1.TGR8": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.STALL1_NO_TxR_HORZ_CRD_BL_AG1_1.TGR9": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.STALL1_NO_TxR_HORZ_CRD_BL_AG1_1.TGR10": {
	  "Box": "M2M",
	  "Category": "M2M CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.TAG_HIT": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Defn": "Tag Hit indicates when a request sent to the iMC hit in Near Memory.",
	  "Desc": "Tag Hit",
	  "EvSel": 44,
	  "ExtSel": "",
	  "Notes": "When the iMC returns data, the response's tag is compared against request tag,   A hit indicates to M2M the data was found in NearMem.",
     },
     "M2M.TAG_HIT.NM_UFILL_HIT_CLEAN": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Defn": "Tag Hit indicates when a request sent to the iMC hit in Near Memory.",
	  "Desc": "Tag Hit",
	  "EvSel": 44,
	  "ExtSel": "",
	  "Notes": "When the iMC returns data, the response's tag is compared against request tag,   A hit indicates to M2M the data was found in NearMem.",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.TAG_HIT.NM_UFILL_HIT_DIRTY": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Defn": "Tag Hit indicates when a request sent to the iMC hit in Near Memory.",
	  "Desc": "Tag Hit",
	  "EvSel": 44,
	  "ExtSel": "",
	  "Notes": "When the iMC returns data, the response's tag is compared against request tag,   A hit indicates to M2M the data was found in NearMem.",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.TAG_HIT.NM_RD_HIT_DIRTY": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Defn": "Tag Hit indicates when a request sent to the iMC hit in Near Memory.",
	  "Desc": "Tag Hit",
	  "EvSel": 44,
	  "ExtSel": "",
	  "Notes": "When the iMC returns data, the response's tag is compared against request tag,   A hit indicates to M2M the data was found in NearMem.",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TAG_HIT.NM_RD_HIT_CLEAN": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Defn": "Tag Hit indicates when a request sent to the iMC hit in Near Memory.",
	  "Desc": "Tag Hit",
	  "EvSel": 44,
	  "ExtSel": "",
	  "Notes": "When the iMC returns data, the response's tag is compared against request tag,   A hit indicates to M2M the data was found in NearMem.",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TAG_MISS": {
	  "Box": "M2M",
	  "Category": "M2M Directory State Events",
	  "Desc": "Tag Miss",
	  "EvSel": 97,
	  "ExtSel": "",
     },
     "M2M.TGR_AD_CREDITS": {
	  "Box": "M2M",
	  "Category": "M2M Transgress Credit Events",
	  "Desc": "Number AD Ingress Credits",
	  "EvSel": 65,
	  "ExtSel": "",
     },
     "M2M.TGR_BL_CREDITS": {
	  "Box": "M2M",
	  "Category": "M2M Transgress Credit Events",
	  "Desc": "Number BL Ingress Credits",
	  "EvSel": 66,
	  "ExtSel": "",
     },
     "M2M.TRACKER_FULL": {
	  "Box": "M2M",
	  "Category": "M2M TRACKER Events",
	  "Desc": "Tracker Cycles Full",
	  "EvSel": 69,
	  "ExtSel": "",
     },
     "M2M.TRACKER_FULL.CH0": {
	  "Box": "M2M",
	  "Category": "M2M TRACKER Events",
	  "Desc": "Tracker Cycles Full",
	  "EvSel": 69,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TRACKER_FULL.CH1": {
	  "Box": "M2M",
	  "Category": "M2M TRACKER Events",
	  "Desc": "Tracker Cycles Full",
	  "EvSel": 69,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TRACKER_FULL.CH2": {
	  "Box": "M2M",
	  "Category": "M2M TRACKER Events",
	  "Desc": "Tracker Cycles Full",
	  "EvSel": 69,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.TRACKER_INSERTS": {
	  "Box": "M2M",
	  "Category": "M2M TRACKER Events",
	  "Desc": "Tracker Inserts",
	  "EvSel": 73,
	  "ExtSel": "",
     },
     "M2M.TRACKER_INSERTS.CH2": {
	  "Box": "M2M",
	  "Category": "M2M TRACKER Events",
	  "Desc": "Tracker Inserts",
	  "EvSel": 73,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.TRACKER_INSERTS.CH0": {
	  "Box": "M2M",
	  "Category": "M2M TRACKER Events",
	  "Desc": "Tracker Inserts",
	  "EvSel": 73,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TRACKER_INSERTS.CH1": {
	  "Box": "M2M",
	  "Category": "M2M TRACKER Events",
	  "Desc": "Tracker Inserts",
	  "EvSel": 73,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TRACKER_NE": {
	  "Box": "M2M",
	  "Category": "M2M TRACKER Events",
	  "Desc": "Tracker Cycles Not Empty",
	  "EvSel": 70,
	  "ExtSel": "",
     },
     "M2M.TRACKER_NE.CH2": {
	  "Box": "M2M",
	  "Category": "M2M TRACKER Events",
	  "Desc": "Tracker Cycles Not Empty",
	  "EvSel": 70,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.TRACKER_NE.CH1": {
	  "Box": "M2M",
	  "Category": "M2M TRACKER Events",
	  "Desc": "Tracker Cycles Not Empty",
	  "EvSel": 70,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TRACKER_NE.CH0": {
	  "Box": "M2M",
	  "Category": "M2M TRACKER Events",
	  "Desc": "Tracker Cycles Not Empty",
	  "EvSel": 70,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TRACKER_OCCUPANCY": {
	  "Box": "M2M",
	  "Category": "M2M TRACKER Events",
	  "Desc": "Tracker Occupancy",
	  "EvSel": 71,
	  "ExtSel": "",
	  "Notes": "Tie to Packet Mask/Match?",
     },
     "M2M.TRACKER_OCCUPANCY.CH1": {
	  "Box": "M2M",
	  "Category": "M2M TRACKER Events",
	  "Desc": "Tracker Occupancy",
	  "EvSel": 71,
	  "ExtSel": "",
	  "Notes": "Tie to Packet Mask/Match?",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TRACKER_OCCUPANCY.CH0": {
	  "Box": "M2M",
	  "Category": "M2M TRACKER Events",
	  "Desc": "Tracker Occupancy",
	  "EvSel": 71,
	  "ExtSel": "",
	  "Notes": "Tie to Packet Mask/Match?",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TRACKER_OCCUPANCY.CH2": {
	  "Box": "M2M",
	  "Category": "M2M TRACKER Events",
	  "Desc": "Tracker Occupancy",
	  "EvSel": 71,
	  "ExtSel": "",
	  "Notes": "Tie to Packet Mask/Match?",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.TxC_AD_CREDITS_ACQUIRED": {
	  "Box": "M2M",
	  "Category": "M2M AD CMS/Mesh Egress Credit Events",
	  "Desc": "AD Egress (to CMS) Credit Acquired",
	  "EvSel": 13,
	  "ExtSel": "",
	  "Notes": "Not a per channel event?",
     },
     "M2M.TxC_AD_CREDIT_OCCUPANCY": {
	  "Box": "M2M",
	  "Category": "M2M AD CMS/Mesh Egress Credit Events",
	  "Desc": "AD Egress (to CMS) Credits Occupancy",
	  "EvSel": 14,
	  "ExtSel": "",
	  "Notes": "Not a per channel event?",
     },
     "M2M.TxC_AD_CYCLES_FULL": {
	  "Box": "M2M",
	  "Category": "M2M AD Egress Events",
	  "Desc": "AD Egress (to CMS) Full",
	  "EvSel": 12,
	  "ExtSel": "",
	  "Notes": "Not a per channel event?",
     },
     "M2M.TxC_AD_CYCLES_NE": {
	  "Box": "M2M",
	  "Category": "M2M AD Egress Events",
	  "Desc": "AD Egress (to CMS) Not Empty",
	  "EvSel": 11,
	  "ExtSel": "",
	  "Notes": "Not a per channel event?",
     },
     "M2M.TxC_AD_INSERTS": {
	  "Box": "M2M",
	  "Category": "M2M AD Egress Events",
	  "Desc": "AD Egress (to CMS) Allocations",
	  "EvSel": 9,
	  "ExtSel": "",
	  "Notes": "Not a per channel event?",
     },
     "M2M.TxC_AD_NO_CREDIT_CYCLES": {
	  "Box": "M2M",
	  "Category": "M2M AD CMS/Mesh Egress Credit Events",
	  "Desc": "Cycles with No AD Egress (to CMS) Credits",
	  "EvSel": 15,
	  "ExtSel": "",
	  "Notes": "Not a per channel event?",
     },
     "M2M.TxC_AD_NO_CREDIT_STALLED": {
	  "Box": "M2M",
	  "Category": "M2M AD CMS/Mesh Egress Credit Events",
	  "Desc": "Cycles Stalled with No AD Egress (to CMS) Credits",
	  "EvSel": 16,
	  "ExtSel": "",
	  "Notes": "Not a per channel event?",
     },
     "M2M.TxC_AD_OCCUPANCY": {
	  "Box": "M2M",
	  "Category": "M2M AD Egress Events",
	  "Desc": "AD Egress (to CMS) Occupancy",
	  "EvSel": 10,
	  "ExtSel": "",
	  "Notes": "Not a per channel event?",
     },
     "M2M.TxC_AK": {
	  "Box": "M2M",
	  "Category": "M2M OUTBOUND_TX Events",
	  "Desc": "Outbound Ring Transactions on AK",
	  "EvSel": 57,
	  "ExtSel": "",
     },
     "M2M.TxC_AK.CRD_CBO": {
	  "Box": "M2M",
	  "Category": "M2M OUTBOUND_TX Events",
	  "Desc": "Outbound Ring Transactions on AK",
	  "EvSel": 57,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxC_AK.NDR": {
	  "Box": "M2M",
	  "Category": "M2M OUTBOUND_TX Events",
	  "Desc": "Outbound Ring Transactions on AK",
	  "EvSel": 57,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxC_AKC_CREDITS": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AKC Credits",
	  "EvSel": 95,
	  "ExtSel": "",
     },
     "M2M.TxC_AK_CREDITS_ACQUIRED": {
	  "Box": "M2M",
	  "Category": "M2M AK CMS/Mesh Egress Credit Events",
	  "Desc": "AK Egress (to CMS) Credit Acquired",
	  "EvSel": 29,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
     },
     "M2M.TxC_AK_CREDITS_ACQUIRED.CMS1": {
	  "Box": "M2M",
	  "Category": "M2M AK CMS/Mesh Egress Credit Events",
	  "Desc": "AK Egress (to CMS) Credit Acquired",
	  "EvSel": 29,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxC_AK_CREDITS_ACQUIRED.CMS0": {
	  "Box": "M2M",
	  "Category": "M2M AK CMS/Mesh Egress Credit Events",
	  "Desc": "AK Egress (to CMS) Credit Acquired",
	  "EvSel": 29,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxC_AK_CYCLES_FULL": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Full",
	  "EvSel": 20,
	  "ExtSel": "",
	  "Notes": "Some extra wild guesses as to what the subevents count - and why does it seem to track 0 credits for each CMS agent, but the other related events don't?",
     },
     "M2M.TxC_AK_CYCLES_FULL.CMS1": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Full",
	  "EvSel": 20,
	  "ExtSel": "",
	  "Notes": "Some extra wild guesses as to what the subevents count - and why does it seem to track 0 credits for each CMS agent, but the other related events don't?",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxC_AK_CYCLES_FULL.CMS0": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Full",
	  "EvSel": 20,
	  "ExtSel": "",
	  "Notes": "Some extra wild guesses as to what the subevents count - and why does it seem to track 0 credits for each CMS agent, but the other related events don't?",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxC_AK_CYCLES_FULL.WRCRD0": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Full",
	  "EvSel": 20,
	  "ExtSel": "",
	  "Notes": "Some extra wild guesses as to what the subevents count - and why does it seem to track 0 credits for each CMS agent, but the other related events don't?",
	  "Umask": "b0xx1xxxx",
     },
     "M2M.TxC_AK_CYCLES_FULL.WRCMP0": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Full",
	  "EvSel": 20,
	  "ExtSel": "",
	  "Notes": "Some extra wild guesses as to what the subevents count - and why does it seem to track 0 credits for each CMS agent, but the other related events don't?",
	  "Umask": "b0x1xxxxx",
     },
     "M2M.TxC_AK_CYCLES_FULL.RDCRD0": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Full",
	  "EvSel": 20,
	  "ExtSel": "",
	  "Notes": "Some extra wild guesses as to what the subevents count - and why does it seem to track 0 credits for each CMS agent, but the other related events don't?",
	  "Umask": "b0xxx1xxx",
     },
     "M2M.TxC_AK_CYCLES_FULL.WRCMP1": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Full",
	  "EvSel": 20,
	  "ExtSel": "",
	  "Notes": "Some extra wild guesses as to what the subevents count - and why does it seem to track 0 credits for each CMS agent, but the other related events don't?",
	  "Umask": "b1x1xxxxx",
     },
     "M2M.TxC_AK_CYCLES_FULL.RDCRD1": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Full",
	  "EvSel": 20,
	  "ExtSel": "",
	  "Notes": "Some extra wild guesses as to what the subevents count - and why does it seem to track 0 credits for each CMS agent, but the other related events don't?",
	  "Umask": "b1xxx1xxx",
     },
     "M2M.TxC_AK_CYCLES_FULL.ALL": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Full",
	  "EvSel": 20,
	  "ExtSel": "",
	  "Notes": "Some extra wild guesses as to what the subevents count - and why does it seem to track 0 credits for each CMS agent, but the other related events don't?",
	  "Umask": "bxxxxxx11",
     },
     "M2M.TxC_AK_CYCLES_FULL.WRCRD1": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Full",
	  "EvSel": 20,
	  "ExtSel": "",
	  "Notes": "Some extra wild guesses as to what the subevents count - and why does it seem to track 0 credits for each CMS agent, but the other related events don't?",
	  "Umask": "b1xx1xxxx",
     },
     "M2M.TxC_AK_CYCLES_NE": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Not Empty",
	  "EvSel": 19,
	  "ExtSel": "",
     },
     "M2M.TxC_AK_CYCLES_NE.WRCMP": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Not Empty",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.TxC_AK_CYCLES_NE.RDCRD": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Not Empty",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.TxC_AK_CYCLES_NE.ALL": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Not Empty",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Umask": "bxxxxxx11",
     },
     "M2M.TxC_AK_CYCLES_NE.CMS0": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Not Empty",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxC_AK_CYCLES_NE.WRCRD": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Not Empty",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.TxC_AK_CYCLES_NE.CMS1": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Not Empty",
	  "EvSel": 19,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxC_AK_INSERTS": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Allocations",
	  "EvSel": 17,
	  "ExtSel": "",
     },
     "M2M.TxC_AK_INSERTS.RDCRD": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Allocations",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.TxC_AK_INSERTS.PREF_RD_CAM_HIT": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Allocations",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.TxC_AK_INSERTS.WRCMP": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Allocations",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.TxC_AK_INSERTS.CMS0": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Allocations",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxC_AK_INSERTS.WRCRD": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Allocations",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.TxC_AK_INSERTS.CMS1": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Allocations",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxC_AK_INSERTS.ALL": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Allocations",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Umask": "bxxxxxx11",
     },
     "M2M.TxC_AK_NO_CREDIT_CYCLES": {
	  "Box": "M2M",
	  "Category": "M2M AK CMS/Mesh Egress Credit Events",
	  "Desc": "Cycles with No AK Egress (to CMS) Credits",
	  "EvSel": 31,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
     },
     "M2M.TxC_AK_NO_CREDIT_CYCLES.CMS1": {
	  "Box": "M2M",
	  "Category": "M2M AK CMS/Mesh Egress Credit Events",
	  "Desc": "Cycles with No AK Egress (to CMS) Credits",
	  "EvSel": 31,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxC_AK_NO_CREDIT_CYCLES.CMS0": {
	  "Box": "M2M",
	  "Category": "M2M AK CMS/Mesh Egress Credit Events",
	  "Desc": "Cycles with No AK Egress (to CMS) Credits",
	  "EvSel": 31,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxC_AK_NO_CREDIT_STALLED": {
	  "Box": "M2M",
	  "Category": "M2M AK CMS/Mesh Egress Credit Events",
	  "Desc": "Cycles Stalled with No AK Egress (to CMS) Credits",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
     },
     "M2M.TxC_AK_NO_CREDIT_STALLED.CMS1": {
	  "Box": "M2M",
	  "Category": "M2M AK CMS/Mesh Egress Credit Events",
	  "Desc": "Cycles Stalled with No AK Egress (to CMS) Credits",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxC_AK_NO_CREDIT_STALLED.CMS0": {
	  "Box": "M2M",
	  "Category": "M2M AK CMS/Mesh Egress Credit Events",
	  "Desc": "Cycles Stalled with No AK Egress (to CMS) Credits",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxC_AK_OCCUPANCY": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Occupancy",
	  "EvSel": 18,
	  "ExtSel": "",
     },
     "M2M.TxC_AK_OCCUPANCY.RDCRD": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Occupancy",
	  "EvSel": 18,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.TxC_AK_OCCUPANCY.WRCMP": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Occupancy",
	  "EvSel": 18,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.TxC_AK_OCCUPANCY.CMS1": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Occupancy",
	  "EvSel": 18,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxC_AK_OCCUPANCY.WRCRD": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Occupancy",
	  "EvSel": 18,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.TxC_AK_OCCUPANCY.CMS0": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Occupancy",
	  "EvSel": 18,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxC_AK_OCCUPANCY.ALL": {
	  "Box": "M2M",
	  "Category": "M2M AK Egress Events",
	  "Desc": "AK Egress (to CMS) Occupancy",
	  "EvSel": 18,
	  "ExtSel": "",
	  "Umask": "bxxxxxx11",
     },
     "M2M.TxC_BL": {
	  "Box": "M2M",
	  "Category": "M2M OUTBOUND_TX Events",
	  "Desc": "Outbound DRS Ring Transactions to Cache",
	  "EvSel": 64,
	  "ExtSel": "",
     },
     "M2M.TxC_BL.DRS_UPI": {
	  "Box": "M2M",
	  "Category": "M2M OUTBOUND_TX Events",
	  "Desc": "Outbound DRS Ring Transactions to Cache",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.TxC_BL.DRS_CORE": {
	  "Box": "M2M",
	  "Category": "M2M OUTBOUND_TX Events",
	  "Desc": "Outbound DRS Ring Transactions to Cache",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxC_BL.DRS_CACHE": {
	  "Box": "M2M",
	  "Category": "M2M OUTBOUND_TX Events",
	  "Desc": "Outbound DRS Ring Transactions to Cache",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxC_BL_CREDITS_ACQUIRED": {
	  "Box": "M2M",
	  "Category": "M2M BL CMS/Mesh Egress Credit Events",
	  "Desc": "BL Egress (to CMS) Credit Acquired",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
     },
     "M2M.TxC_BL_CREDITS_ACQUIRED.CMS0": {
	  "Box": "M2M",
	  "Category": "M2M BL CMS/Mesh Egress Credit Events",
	  "Desc": "BL Egress (to CMS) Credit Acquired",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxC_BL_CREDITS_ACQUIRED.CMS1": {
	  "Box": "M2M",
	  "Category": "M2M BL CMS/Mesh Egress Credit Events",
	  "Desc": "BL Egress (to CMS) Credit Acquired",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxC_BL_CYCLES_FULL": {
	  "Box": "M2M",
	  "Category": "M2M BL Egress Events",
	  "Desc": "BL Egress (to CMS) Full",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
     },
     "M2M.TxC_BL_CYCLES_FULL.ALL": {
	  "Box": "M2M",
	  "Category": "M2M BL Egress Events",
	  "Desc": "BL Egress (to CMS) Full",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxx11",
     },
     "M2M.TxC_BL_CYCLES_FULL.CMS1": {
	  "Box": "M2M",
	  "Category": "M2M BL Egress Events",
	  "Desc": "BL Egress (to CMS) Full",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxC_BL_CYCLES_FULL.CMS0": {
	  "Box": "M2M",
	  "Category": "M2M BL Egress Events",
	  "Desc": "BL Egress (to CMS) Full",
	  "EvSel": 24,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxC_BL_CYCLES_NE": {
	  "Box": "M2M",
	  "Category": "M2M BL Egress Events",
	  "Desc": "BL Egress (to CMS) Not Empty",
	  "EvSel": 23,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
     },
     "M2M.TxC_BL_CYCLES_NE.CMS0": {
	  "Box": "M2M",
	  "Category": "M2M BL Egress Events",
	  "Desc": "BL Egress (to CMS) Not Empty",
	  "EvSel": 23,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxC_BL_CYCLES_NE.CMS1": {
	  "Box": "M2M",
	  "Category": "M2M BL Egress Events",
	  "Desc": "BL Egress (to CMS) Not Empty",
	  "EvSel": 23,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxC_BL_CYCLES_NE.ALL": {
	  "Box": "M2M",
	  "Category": "M2M BL Egress Events",
	  "Desc": "BL Egress (to CMS) Not Empty",
	  "EvSel": 23,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxx11",
     },
     "M2M.TxC_BL_INSERTS": {
	  "Box": "M2M",
	  "Category": "M2M BL Egress Events",
	  "Desc": "BL Egress (to CMS) Allocations",
	  "EvSel": 21,
	  "ExtSel": "",
     },
     "M2M.TxC_BL_INSERTS.CMS0": {
	  "Box": "M2M",
	  "Category": "M2M BL Egress Events",
	  "Desc": "BL Egress (to CMS) Allocations",
	  "EvSel": 21,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxC_BL_INSERTS.CMS1": {
	  "Box": "M2M",
	  "Category": "M2M BL Egress Events",
	  "Desc": "BL Egress (to CMS) Allocations",
	  "EvSel": 21,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxC_BL_INSERTS.ALL": {
	  "Box": "M2M",
	  "Category": "M2M BL Egress Events",
	  "Desc": "BL Egress (to CMS) Allocations",
	  "EvSel": 21,
	  "ExtSel": "",
	  "Umask": "bxxxxxx11",
     },
     "M2M.TxC_BL_NO_CREDIT_CYCLES": {
	  "Box": "M2M",
	  "Category": "M2M BL CMS/Mesh Egress Credit Events",
	  "Desc": "Cycles with No BL Egress (to CMS) Credits",
	  "EvSel": 27,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
     },
     "M2M.TxC_BL_NO_CREDIT_CYCLES.CMS0": {
	  "Box": "M2M",
	  "Category": "M2M BL CMS/Mesh Egress Credit Events",
	  "Desc": "Cycles with No BL Egress (to CMS) Credits",
	  "EvSel": 27,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxC_BL_NO_CREDIT_CYCLES.CMS1": {
	  "Box": "M2M",
	  "Category": "M2M BL CMS/Mesh Egress Credit Events",
	  "Desc": "Cycles with No BL Egress (to CMS) Credits",
	  "EvSel": 27,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxC_BL_NO_CREDIT_STALLED": {
	  "Box": "M2M",
	  "Category": "M2M BL CMS/Mesh Egress Credit Events",
	  "Desc": "Cycles Stalled with No BL Egress (to CMS) Credits",
	  "EvSel": 28,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
     },
     "M2M.TxC_BL_NO_CREDIT_STALLED.CMS0": {
	  "Box": "M2M",
	  "Category": "M2M BL CMS/Mesh Egress Credit Events",
	  "Desc": "Cycles Stalled with No BL Egress (to CMS) Credits",
	  "EvSel": 28,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxC_BL_NO_CREDIT_STALLED.CMS1": {
	  "Box": "M2M",
	  "Category": "M2M BL CMS/Mesh Egress Credit Events",
	  "Desc": "Cycles Stalled with No BL Egress (to CMS) Credits",
	  "EvSel": 28,
	  "ExtSel": "",
	  "Notes": "only on g_chnl==0?",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxR_HORZ_ADS_USED": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
     },
     "M2M.TxR_HORZ_ADS_USED.BL_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M2M.TxR_HORZ_ADS_USED.AD_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2M.TxR_HORZ_ADS_USED.AD_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2M.TxR_HORZ_ADS_USED.BL_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2M.TxR_HORZ_ADS_USED.BL_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2M.TxR_HORZ_ADS_USED.AD_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M2M.TxR_HORZ_BYPASS": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
     },
     "M2M.TxR_HORZ_BYPASS.AD_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2M.TxR_HORZ_BYPASS.IV": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2M.TxR_HORZ_BYPASS.AKC_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2M.TxR_HORZ_BYPASS.BL_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2M.TxR_HORZ_BYPASS.BL_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M2M.TxR_HORZ_BYPASS.AD_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2M.TxR_HORZ_BYPASS.BL_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2M.TxR_HORZ_BYPASS.AK": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2M.TxR_HORZ_BYPASS.AD_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M2M.TxR_HORZ_CYCLES_FULL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
     },
     "M2M.TxR_HORZ_CYCLES_FULL.AD_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2M.TxR_HORZ_CYCLES_FULL.IV": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2M.TxR_HORZ_CYCLES_FULL.AKC_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2M.TxR_HORZ_CYCLES_FULL.BL_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2M.TxR_HORZ_CYCLES_FULL.AD_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2M.TxR_HORZ_CYCLES_FULL.BL_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M2M.TxR_HORZ_CYCLES_FULL.AD_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M2M.TxR_HORZ_CYCLES_FULL.AK": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2M.TxR_HORZ_CYCLES_FULL.BL_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2M.TxR_HORZ_CYCLES_NE": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
     },
     "M2M.TxR_HORZ_CYCLES_NE.BL_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2M.TxR_HORZ_CYCLES_NE.AKC_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2M.TxR_HORZ_CYCLES_NE.IV": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2M.TxR_HORZ_CYCLES_NE.AD_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2M.TxR_HORZ_CYCLES_NE.AD_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M2M.TxR_HORZ_CYCLES_NE.AK": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2M.TxR_HORZ_CYCLES_NE.BL_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2M.TxR_HORZ_CYCLES_NE.AD_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2M.TxR_HORZ_CYCLES_NE.BL_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M2M.TxR_HORZ_INSERTS": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
     },
     "M2M.TxR_HORZ_INSERTS.BL_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M2M.TxR_HORZ_INSERTS.AD_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2M.TxR_HORZ_INSERTS.BL_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2M.TxR_HORZ_INSERTS.AD_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M2M.TxR_HORZ_INSERTS.AK": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2M.TxR_HORZ_INSERTS.AD_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2M.TxR_HORZ_INSERTS.BL_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2M.TxR_HORZ_INSERTS.AKC_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2M.TxR_HORZ_INSERTS.IV": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2M.TxR_HORZ_NACK": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
     },
     "M2M.TxR_HORZ_NACK.AKC_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2M.TxR_HORZ_NACK.BL_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2M.TxR_HORZ_NACK.IV": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2M.TxR_HORZ_NACK.AD_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2M.TxR_HORZ_NACK.AD_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M2M.TxR_HORZ_NACK.AK": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2M.TxR_HORZ_NACK.BL_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2M.TxR_HORZ_NACK.AD_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2M.TxR_HORZ_NACK.BL_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M2M.TxR_HORZ_OCCUPANCY": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
     },
     "M2M.TxR_HORZ_OCCUPANCY.AD_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2M.TxR_HORZ_OCCUPANCY.BL_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M2M.TxR_HORZ_OCCUPANCY.AD_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M2M.TxR_HORZ_OCCUPANCY.AK": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2M.TxR_HORZ_OCCUPANCY.BL_CRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2M.TxR_HORZ_OCCUPANCY.AD_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2M.TxR_HORZ_OCCUPANCY.AKC_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2M.TxR_HORZ_OCCUPANCY.IV": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2M.TxR_HORZ_OCCUPANCY.BL_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2M.TxR_HORZ_STARVED": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
     },
     "M2M.TxR_HORZ_STARVED.AKC_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2M.TxR_HORZ_STARVED.BL_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2M.TxR_HORZ_STARVED.IV": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2M.TxR_HORZ_STARVED.AD_UNCRD": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2M.TxR_HORZ_STARVED.AK": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2M.TxR_HORZ_STARVED.AD_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2M.TxR_HORZ_STARVED.BL_ALL": {
	  "Box": "M2M",
	  "Category": "M2M CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2M.TxR_VERT_ADS_USED": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
     },
     "M2M.TxR_VERT_ADS_USED.AD_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.TxR_VERT_ADS_USED.BL_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.TxR_VERT_ADS_USED.AD_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxR_VERT_ADS_USED.BL_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.TxR_VERT_BYPASS": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
     },
     "M2M.TxR_VERT_BYPASS.AD_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxR_VERT_BYPASS.AK_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.TxR_VERT_BYPASS.BL_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.TxR_VERT_BYPASS.BL_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.TxR_VERT_BYPASS.IV_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.TxR_VERT_BYPASS.AK_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxR_VERT_BYPASS.AD_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.TxR_VERT_BYPASS_1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 158,
	  "ExtSel": "",
     },
     "M2M.TxR_VERT_BYPASS_1.AKC_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 158,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxR_VERT_BYPASS_1.AKC_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 158,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxR_VERT_CYCLES_FULL0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
     },
     "M2M.TxR_VERT_CYCLES_FULL0.AD_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.TxR_VERT_CYCLES_FULL0.AK_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxR_VERT_CYCLES_FULL0.BL_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.TxR_VERT_CYCLES_FULL0.BL_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.TxR_VERT_CYCLES_FULL0.IV_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.TxR_VERT_CYCLES_FULL0.AK_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.TxR_VERT_CYCLES_FULL0.AD_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxR_VERT_CYCLES_FULL1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 149,
	  "ExtSel": "",
     },
     "M2M.TxR_VERT_CYCLES_FULL1.AKC_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 149,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxR_VERT_CYCLES_FULL1.AKC_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 149,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxR_VERT_CYCLES_NE0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
     },
     "M2M.TxR_VERT_CYCLES_NE0.AK_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.TxR_VERT_CYCLES_NE0.AD_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxR_VERT_CYCLES_NE0.IV_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.TxR_VERT_CYCLES_NE0.BL_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.TxR_VERT_CYCLES_NE0.BL_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.TxR_VERT_CYCLES_NE0.AD_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.TxR_VERT_CYCLES_NE0.AK_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxR_VERT_CYCLES_NE1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 151,
	  "ExtSel": "",
     },
     "M2M.TxR_VERT_CYCLES_NE1.AKC_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 151,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxR_VERT_CYCLES_NE1.AKC_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 151,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxR_VERT_INSERTS0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
     },
     "M2M.TxR_VERT_INSERTS0.BL_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.TxR_VERT_INSERTS0.IV_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.TxR_VERT_INSERTS0.AD_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxR_VERT_INSERTS0.AK_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.TxR_VERT_INSERTS0.AD_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.TxR_VERT_INSERTS0.AK_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxR_VERT_INSERTS0.BL_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.TxR_VERT_INSERTS1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 147,
	  "ExtSel": "",
     },
     "M2M.TxR_VERT_INSERTS1.AKC_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 147,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxR_VERT_INSERTS1.AKC_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 147,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxR_VERT_NACK0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
     },
     "M2M.TxR_VERT_NACK0.BL_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.TxR_VERT_NACK0.AD_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.TxR_VERT_NACK0.AK_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxR_VERT_NACK0.AK_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.TxR_VERT_NACK0.AD_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxR_VERT_NACK0.IV_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.TxR_VERT_NACK0.BL_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.TxR_VERT_NACK1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 153,
	  "ExtSel": "",
     },
     "M2M.TxR_VERT_NACK1.AKC_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 153,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxR_VERT_NACK1.AKC_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 153,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxR_VERT_OCCUPANCY0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
     },
     "M2M.TxR_VERT_OCCUPANCY0.AD_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.TxR_VERT_OCCUPANCY0.AK_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxR_VERT_OCCUPANCY0.BL_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.TxR_VERT_OCCUPANCY0.IV_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.TxR_VERT_OCCUPANCY0.BL_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.TxR_VERT_OCCUPANCY0.AD_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxR_VERT_OCCUPANCY0.AK_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.TxR_VERT_OCCUPANCY1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 145,
	  "ExtSel": "",
     },
     "M2M.TxR_VERT_OCCUPANCY1.AKC_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 145,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxR_VERT_OCCUPANCY1.AKC_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 145,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxR_VERT_STARVED0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
     },
     "M2M.TxR_VERT_STARVED0.IV_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.TxR_VERT_STARVED0.BL_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.TxR_VERT_STARVED0.AK_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.TxR_VERT_STARVED0.AD_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxR_VERT_STARVED0.AD_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.TxR_VERT_STARVED0.AK_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxR_VERT_STARVED0.BL_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2M.TxR_VERT_STARVED1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 155,
	  "ExtSel": "",
     },
     "M2M.TxR_VERT_STARVED1.AKC_AG0": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 155,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.TxR_VERT_STARVED1.AKC_AG1": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 155,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.TxR_VERT_STARVED1.TGC": {
	  "Box": "M2M",
	  "Category": "M2M CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 155,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.VERT_RING_AD_IN_USE": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
     },
     "M2M.VERT_RING_AD_IN_USE.UP_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.VERT_RING_AD_IN_USE.DN_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.VERT_RING_AD_IN_USE.DN_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.VERT_RING_AD_IN_USE.UP_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.VERT_RING_AKC_IN_USE": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
     },
     "M2M.VERT_RING_AKC_IN_USE.UP_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.VERT_RING_AKC_IN_USE.DN_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.VERT_RING_AKC_IN_USE.DN_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.VERT_RING_AKC_IN_USE.UP_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.VERT_RING_AK_IN_USE": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
     },
     "M2M.VERT_RING_AK_IN_USE.UP_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.VERT_RING_AK_IN_USE.DN_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.VERT_RING_AK_IN_USE.DN_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.VERT_RING_AK_IN_USE.UP_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.VERT_RING_BL_IN_USE": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
     },
     "M2M.VERT_RING_BL_IN_USE.DN_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.VERT_RING_BL_IN_USE.UP_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.VERT_RING_BL_IN_USE.UP_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.VERT_RING_BL_IN_USE.DN_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.VERT_RING_IV_IN_USE": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Vertical IV Ring in Use",
	  "EvSel": 179,
	  "ExtSel": "",
     },
     "M2M.VERT_RING_IV_IN_USE.UP": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Vertical IV Ring in Use",
	  "EvSel": 179,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.VERT_RING_IV_IN_USE.DN": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Vertical IV Ring in Use",
	  "EvSel": 179,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.VERT_RING_TGC_IN_USE": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
     },
     "M2M.VERT_RING_TGC_IN_USE.DN_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.VERT_RING_TGC_IN_USE.UP_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.VERT_RING_TGC_IN_USE.UP_ODD": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.VERT_RING_TGC_IN_USE.DN_EVEN": {
	  "Box": "M2M",
	  "Category": "M2M Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.WPQ_FLUSH": {
	  "Box": "M2M",
	  "Category": "M2M WPQ EVENTS",
	  "Desc": "WPQ Flush",
	  "EvSel": 88,
	  "ExtSel": "",
     },
     "M2M.WPQ_FLUSH.CH1": {
	  "Box": "M2M",
	  "Category": "M2M WPQ EVENTS",
	  "Desc": "WPQ Flush",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.WPQ_FLUSH.CH0": {
	  "Box": "M2M",
	  "Category": "M2M WPQ EVENTS",
	  "Desc": "WPQ Flush",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.WPQ_FLUSH.CH2": {
	  "Box": "M2M",
	  "Category": "M2M WPQ EVENTS",
	  "Desc": "WPQ Flush",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.WPQ_NO_REG_CRD": {
	  "Box": "M2M",
	  "Category": "M2M WPQ CREDIT Events",
	  "Desc": "M2M->iMC WPQ Cycles w/Credits - Regular",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
     },
     "M2M.WPQ_NO_REG_CRD.CHN0": {
	  "Box": "M2M",
	  "Category": "M2M WPQ CREDIT Events",
	  "Desc": "M2M->iMC WPQ Cycles w/Credits - Regular",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.WPQ_NO_REG_CRD.CHN1": {
	  "Box": "M2M",
	  "Category": "M2M WPQ CREDIT Events",
	  "Desc": "M2M->iMC WPQ Cycles w/Credits - Regular",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.WPQ_NO_REG_CRD.CHN2": {
	  "Box": "M2M",
	  "Category": "M2M WPQ CREDIT Events",
	  "Desc": "M2M->iMC WPQ Cycles w/Credits - Regular",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.WPQ_NO_REG_CRD_PMM": {
	  "Box": "M2M",
	  "Category": "M2M WPQ CREDIT Events",
	  "Desc": "M2M->iMC WPQ Cycles w/Credits - PMM",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
     },
     "M2M.WPQ_NO_REG_CRD_PMM.CHN2": {
	  "Box": "M2M",
	  "Category": "M2M WPQ CREDIT Events",
	  "Desc": "M2M->iMC WPQ Cycles w/Credits - PMM",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.WPQ_NO_REG_CRD_PMM.CHN0": {
	  "Box": "M2M",
	  "Category": "M2M WPQ CREDIT Events",
	  "Desc": "M2M->iMC WPQ Cycles w/Credits - PMM",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.WPQ_NO_REG_CRD_PMM.CHN1": {
	  "Box": "M2M",
	  "Category": "M2M WPQ CREDIT Events",
	  "Desc": "M2M->iMC WPQ Cycles w/Credits - PMM",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.WPQ_NO_SPEC_CRD": {
	  "Box": "M2M",
	  "Category": "M2M WPQ CREDIT Events",
	  "Desc": "M2M->iMC WPQ Cycles w/Credits - Special",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
     },
     "M2M.WPQ_NO_SPEC_CRD.CHN2": {
	  "Box": "M2M",
	  "Category": "M2M WPQ CREDIT Events",
	  "Desc": "M2M->iMC WPQ Cycles w/Credits - Special",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.WPQ_NO_SPEC_CRD.CHN0": {
	  "Box": "M2M",
	  "Category": "M2M WPQ CREDIT Events",
	  "Desc": "M2M->iMC WPQ Cycles w/Credits - Special",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.WPQ_NO_SPEC_CRD.CHN1": {
	  "Box": "M2M",
	  "Category": "M2M WPQ CREDIT Events",
	  "Desc": "M2M->iMC WPQ Cycles w/Credits - Special",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Notes": "To Count # cycles w/o credits, either set .thresh to 1 and .invert to 1 OR subtract this from total cycles",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.WR_TRACKER_FULL": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Cycles Full",
	  "EvSel": 74,
	  "ExtSel": "",
     },
     "M2M.WR_TRACKER_FULL.CH0": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Cycles Full",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.WR_TRACKER_FULL.CH1": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Cycles Full",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.WR_TRACKER_FULL.MIRR": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Cycles Full",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.WR_TRACKER_FULL.CH2": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Cycles Full",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.WR_TRACKER_INSERTS": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Inserts",
	  "EvSel": 86,
	  "ExtSel": "",
     },
     "M2M.WR_TRACKER_INSERTS.CH0": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Inserts",
	  "EvSel": 86,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.WR_TRACKER_INSERTS.CH1": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Inserts",
	  "EvSel": 86,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.WR_TRACKER_INSERTS.CH2": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Inserts",
	  "EvSel": 86,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.WR_TRACKER_NE": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Cycles Not Empty",
	  "EvSel": 75,
	  "ExtSel": "",
     },
     "M2M.WR_TRACKER_NE.CH2": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Cycles Not Empty",
	  "EvSel": 75,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.WR_TRACKER_NE.MIRR_PWR": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Cycles Not Empty",
	  "EvSel": 75,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.WR_TRACKER_NE.MIRR": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Cycles Not Empty",
	  "EvSel": 75,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.WR_TRACKER_NE.CH0": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Cycles Not Empty",
	  "EvSel": 75,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.WR_TRACKER_NE.MIRR_NONTGR": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Cycles Not Empty",
	  "EvSel": 75,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.WR_TRACKER_NE.CH1": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Cycles Not Empty",
	  "EvSel": 75,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.WR_TRACKER_NONPOSTED_INSERTS": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Non-Posted Inserts",
	  "EvSel": 99,
	  "ExtSel": "",
     },
     "M2M.WR_TRACKER_NONPOSTED_INSERTS.CH2": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Non-Posted Inserts",
	  "EvSel": 99,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.WR_TRACKER_NONPOSTED_INSERTS.CH0": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Non-Posted Inserts",
	  "EvSel": 99,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.WR_TRACKER_NONPOSTED_INSERTS.CH1": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Non-Posted Inserts",
	  "EvSel": 99,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.WR_TRACKER_NONPOSTED_OCCUPANCY": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Non-Posted Occupancy",
	  "EvSel": 98,
	  "ExtSel": "",
     },
     "M2M.WR_TRACKER_NONPOSTED_OCCUPANCY.CH2": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Non-Posted Occupancy",
	  "EvSel": 98,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.WR_TRACKER_NONPOSTED_OCCUPANCY.CH1": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Non-Posted Occupancy",
	  "EvSel": 98,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.WR_TRACKER_NONPOSTED_OCCUPANCY.CH0": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Non-Posted Occupancy",
	  "EvSel": 98,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.WR_TRACKER_OCCUPANCY": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Occupancy",
	  "EvSel": 85,
	  "ExtSel": "",
     },
     "M2M.WR_TRACKER_OCCUPANCY.MIRR": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Occupancy",
	  "EvSel": 85,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2M.WR_TRACKER_OCCUPANCY.MIRR_PWR": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Occupancy",
	  "EvSel": 85,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2M.WR_TRACKER_OCCUPANCY.CH1": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Occupancy",
	  "EvSel": 85,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.WR_TRACKER_OCCUPANCY.MIRR_NONTGR": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Occupancy",
	  "EvSel": 85,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2M.WR_TRACKER_OCCUPANCY.CH0": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Occupancy",
	  "EvSel": 85,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.WR_TRACKER_OCCUPANCY.CH2": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Occupancy",
	  "EvSel": 85,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.WR_TRACKER_POSTED_INSERTS": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Posted Inserts",
	  "EvSel": 94,
	  "ExtSel": "",
     },
     "M2M.WR_TRACKER_POSTED_INSERTS.CH0": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Posted Inserts",
	  "EvSel": 94,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.WR_TRACKER_POSTED_INSERTS.CH1": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Posted Inserts",
	  "EvSel": 94,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2M.WR_TRACKER_POSTED_INSERTS.CH2": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Posted Inserts",
	  "EvSel": 94,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.WR_TRACKER_POSTED_OCCUPANCY": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Posted Occupancy",
	  "EvSel": 93,
	  "ExtSel": "",
     },
     "M2M.WR_TRACKER_POSTED_OCCUPANCY.CH2": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Posted Occupancy",
	  "EvSel": 93,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2M.WR_TRACKER_POSTED_OCCUPANCY.CH0": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Posted Occupancy",
	  "EvSel": 93,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2M.WR_TRACKER_POSTED_OCCUPANCY.CH1": {
	  "Box": "M2M",
	  "Category": "M2M Write Tracker Events",
	  "Desc": "Write Tracker Posted Occupancy",
	  "EvSel": 93,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },

# M2PCIe:
     "M2PCIe.AG0_AD_CRD_ACQUIRED0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
     },
     "M2PCIe.AG0_AD_CRD_ACQUIRED0.TGR6": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.AG0_AD_CRD_ACQUIRED0.TGR7": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "b1xxxxxxx",
     },
     "M2PCIe.AG0_AD_CRD_ACQUIRED0.TGR3": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.AG0_AD_CRD_ACQUIRED0.TGR5": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.AG0_AD_CRD_ACQUIRED0.TGR4": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.AG0_AD_CRD_ACQUIRED0.TGR2": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.AG0_AD_CRD_ACQUIRED0.TGR0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.AG0_AD_CRD_ACQUIRED0.TGR1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.AG0_AD_CRD_ACQUIRED1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 129,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
     },
     "M2PCIe.AG0_AD_CRD_ACQUIRED1.TGR10": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 129,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.AG0_AD_CRD_ACQUIRED1.TGR9": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 129,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.AG0_AD_CRD_ACQUIRED1.TGR8": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 129,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.AG0_AD_CRD_OCCUPANCY0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
     },
     "M2PCIe.AG0_AD_CRD_OCCUPANCY0.TGR3": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00001000",
     },
     "M2PCIe.AG0_AD_CRD_OCCUPANCY0.TGR7": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b10000000",
     },
     "M2PCIe.AG0_AD_CRD_OCCUPANCY0.TGR6": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b01000000",
     },
     "M2PCIe.AG0_AD_CRD_OCCUPANCY0.TGR5": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00100000",
     },
     "M2PCIe.AG0_AD_CRD_OCCUPANCY0.TGR4": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00010000",
     },
     "M2PCIe.AG0_AD_CRD_OCCUPANCY0.TGR2": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000100",
     },
     "M2PCIe.AG0_AD_CRD_OCCUPANCY0.TGR1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000010",
     },
     "M2PCIe.AG0_AD_CRD_OCCUPANCY0.TGR0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000001",
     },
     "M2PCIe.AG0_AD_CRD_OCCUPANCY1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 131,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
     },
     "M2PCIe.AG0_AD_CRD_OCCUPANCY1.TGR9": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 131,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000010",
     },
     "M2PCIe.AG0_AD_CRD_OCCUPANCY1.TGR10": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 131,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000100",
     },
     "M2PCIe.AG0_AD_CRD_OCCUPANCY1.TGR8": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 131,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000001",
     },
     "M2PCIe.AG0_BL_CRD_ACQUIRED0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
     },
     "M2PCIe.AG0_BL_CRD_ACQUIRED0.TGR2": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.AG0_BL_CRD_ACQUIRED0.TGR1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.AG0_BL_CRD_ACQUIRED0.TGR0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.AG0_BL_CRD_ACQUIRED0.TGR7": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2PCIe.AG0_BL_CRD_ACQUIRED0.TGR3": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.AG0_BL_CRD_ACQUIRED0.TGR6": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.AG0_BL_CRD_ACQUIRED0.TGR4": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.AG0_BL_CRD_ACQUIRED0.TGR5": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.AG0_BL_CRD_ACQUIRED1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 137,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M2PCIe.AG0_BL_CRD_ACQUIRED1.TGR8": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 137,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.AG0_BL_CRD_ACQUIRED1.TGR9": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 137,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.AG0_BL_CRD_ACQUIRED1.TGR10": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 137,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.AG0_BL_CRD_OCCUPANCY0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
     },
     "M2PCIe.AG0_BL_CRD_OCCUPANCY0.TGR2": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2PCIe.AG0_BL_CRD_OCCUPANCY0.TGR0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2PCIe.AG0_BL_CRD_OCCUPANCY0.TGR1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2PCIe.AG0_BL_CRD_OCCUPANCY0.TGR6": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2PCIe.AG0_BL_CRD_OCCUPANCY0.TGR7": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2PCIe.AG0_BL_CRD_OCCUPANCY0.TGR3": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2PCIe.AG0_BL_CRD_OCCUPANCY0.TGR4": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2PCIe.AG0_BL_CRD_OCCUPANCY0.TGR5": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00100000",
     },
     "M2PCIe.AG0_BL_CRD_OCCUPANCY1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 139,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M2PCIe.AG0_BL_CRD_OCCUPANCY1.TGR8": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 139,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000001",
     },
     "M2PCIe.AG0_BL_CRD_OCCUPANCY1.TGR10": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 139,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000100",
     },
     "M2PCIe.AG0_BL_CRD_OCCUPANCY1.TGR9": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 139,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000010",
     },
     "M2PCIe.AG1_AD_CRD_ACQUIRED0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
     },
     "M2PCIe.AG1_AD_CRD_ACQUIRED0.TGR7": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "b1xxxxxxx",
     },
     "M2PCIe.AG1_AD_CRD_ACQUIRED0.TGR3": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.AG1_AD_CRD_ACQUIRED0.TGR6": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.AG1_AD_CRD_ACQUIRED0.TGR4": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.AG1_AD_CRD_ACQUIRED0.TGR5": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.AG1_AD_CRD_ACQUIRED0.TGR2": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.AG1_AD_CRD_ACQUIRED0.TGR1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.AG1_AD_CRD_ACQUIRED0.TGR0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.AG1_AD_CRD_ACQUIRED1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 133,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
     },
     "M2PCIe.AG1_AD_CRD_ACQUIRED1.TGR10": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 133,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.AG1_AD_CRD_ACQUIRED1.TGR9": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 133,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.AG1_AD_CRD_ACQUIRED1.TGR8": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 133,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.AG1_AD_CRD_OCCUPANCY0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
     },
     "M2PCIe.AG1_AD_CRD_OCCUPANCY0.TGR5": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00100000",
     },
     "M2PCIe.AG1_AD_CRD_OCCUPANCY0.TGR4": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00010000",
     },
     "M2PCIe.AG1_AD_CRD_OCCUPANCY0.TGR3": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00001000",
     },
     "M2PCIe.AG1_AD_CRD_OCCUPANCY0.TGR7": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b10000000",
     },
     "M2PCIe.AG1_AD_CRD_OCCUPANCY0.TGR6": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b01000000",
     },
     "M2PCIe.AG1_AD_CRD_OCCUPANCY0.TGR1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000010",
     },
     "M2PCIe.AG1_AD_CRD_OCCUPANCY0.TGR0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000001",
     },
     "M2PCIe.AG1_AD_CRD_OCCUPANCY0.TGR2": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000100",
     },
     "M2PCIe.AG1_AD_CRD_OCCUPANCY1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 135,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
     },
     "M2PCIe.AG1_AD_CRD_OCCUPANCY1.TGR10": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 135,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000100",
     },
     "M2PCIe.AG1_AD_CRD_OCCUPANCY1.TGR9": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 135,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000010",
     },
     "M2PCIe.AG1_AD_CRD_OCCUPANCY1.TGR8": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 135,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000001",
     },
     "M2PCIe.AG1_BL_CRD_ACQUIRED0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
     },
     "M2PCIe.AG1_BL_CRD_ACQUIRED0.TGR6": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.AG1_BL_CRD_ACQUIRED0.TGR7": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2PCIe.AG1_BL_CRD_ACQUIRED0.TGR3": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.AG1_BL_CRD_ACQUIRED0.TGR5": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.AG1_BL_CRD_ACQUIRED0.TGR4": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.AG1_BL_CRD_ACQUIRED0.TGR2": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.AG1_BL_CRD_ACQUIRED0.TGR0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.AG1_BL_CRD_ACQUIRED0.TGR1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.AG1_BL_CRD_ACQUIRED1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 141,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M2PCIe.AG1_BL_CRD_ACQUIRED1.TGR8": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 141,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.AG1_BL_CRD_ACQUIRED1.TGR10": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 141,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.AG1_BL_CRD_ACQUIRED1.TGR9": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 141,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.AG1_BL_CRD_OCCUPANCY0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
     },
     "M2PCIe.AG1_BL_CRD_OCCUPANCY0.TGR2": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2PCIe.AG1_BL_CRD_OCCUPANCY0.TGR0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2PCIe.AG1_BL_CRD_OCCUPANCY0.TGR1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2PCIe.AG1_BL_CRD_OCCUPANCY0.TGR6": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2PCIe.AG1_BL_CRD_OCCUPANCY0.TGR3": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2PCIe.AG1_BL_CRD_OCCUPANCY0.TGR7": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2PCIe.AG1_BL_CRD_OCCUPANCY0.TGR5": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00100000",
     },
     "M2PCIe.AG1_BL_CRD_OCCUPANCY0.TGR4": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2PCIe.AG1_BL_CRD_OCCUPANCY1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 143,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M2PCIe.AG1_BL_CRD_OCCUPANCY1.TGR8": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 143,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000001",
     },
     "M2PCIe.AG1_BL_CRD_OCCUPANCY1.TGR10": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 143,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000100",
     },
     "M2PCIe.AG1_BL_CRD_OCCUPANCY1.TGR9": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 143,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000010",
     },
     "M2PCIe.CLOCKTICKS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe UCLK Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of uclks in the M3 uclk domain.  This could be slightly different than the count in the Ubox because of enable/freeze delays.  However, because the M3 is close to the Ubox, they generally should not diverge by more than a handful of cycles.",
	  "Desc": "Clockticks of the mesh to PCI (M2P)",
	  "EvSel": 1,
	  "ExtSel": "",
     },
     "M2PCIe.CMS_CLOCKTICKS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Misc Events",
	  "Desc": "CMS Clockticks",
	  "EvSel": 192,
	  "ExtSel": "",
     },
     "M2PCIe.DISTRESS_ASSERTED": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
     },
     "M2PCIe.DISTRESS_ASSERTED.DPT_STALL_IV": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.DISTRESS_ASSERTED.PMM_LOCAL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.DISTRESS_ASSERTED.DPT_STALL_NOCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2PCIe.DISTRESS_ASSERTED.DPT_LOCAL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.DISTRESS_ASSERTED.HORZ": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2PCIe.DISTRESS_ASSERTED.VERT": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2PCIe.DISTRESS_ASSERTED.DPT_NONLOCAL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.DISTRESS_ASSERTED.PMM_NONLOCAL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.EGRESS_ORDERING": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts number of cycles IV was blocked in the TGR Egress due to SNP/GO Ordering requirements",
	  "Desc": "Egress Blocking due to Ordering requirements",
	  "EvSel": 186,
	  "ExtSel": "",
     },
     "M2PCIe.EGRESS_ORDERING.IV_SNOOPGO_DN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts number of cycles IV was blocked in the TGR Egress due to SNP/GO Ordering requirements",
	  "Desc": "Egress Blocking due to Ordering requirements",
	  "EvSel": 186,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.EGRESS_ORDERING.IV_SNOOPGO_UP": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts number of cycles IV was blocked in the TGR Egress due to SNP/GO Ordering requirements",
	  "Desc": "Egress Blocking due to Ordering requirements",
	  "EvSel": 186,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.HORZ_RING_AD_IN_USE": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
     },
     "M2PCIe.HORZ_RING_AD_IN_USE.RIGHT_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.HORZ_RING_AD_IN_USE.RIGHT_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.HORZ_RING_AD_IN_USE.LEFT_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.HORZ_RING_AD_IN_USE.LEFT_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.HORZ_RING_AKC_IN_USE": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
     },
     "M2PCIe.HORZ_RING_AKC_IN_USE.LEFT_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.HORZ_RING_AKC_IN_USE.LEFT_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.HORZ_RING_AKC_IN_USE.RIGHT_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.HORZ_RING_AKC_IN_USE.RIGHT_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.HORZ_RING_AK_IN_USE": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
     },
     "M2PCIe.HORZ_RING_AK_IN_USE.LEFT_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.HORZ_RING_AK_IN_USE.LEFT_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.HORZ_RING_AK_IN_USE.RIGHT_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.HORZ_RING_AK_IN_USE.RIGHT_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.HORZ_RING_BL_IN_USE": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
     },
     "M2PCIe.HORZ_RING_BL_IN_USE.RIGHT_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.HORZ_RING_BL_IN_USE.LEFT_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.HORZ_RING_BL_IN_USE.LEFT_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.HORZ_RING_BL_IN_USE.RIGHT_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.HORZ_RING_IV_IN_USE": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Horizontal IV Ring in Use",
	  "EvSel": 185,
	  "ExtSel": "",
     },
     "M2PCIe.HORZ_RING_IV_IN_USE.RIGHT": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Horizontal IV Ring in Use",
	  "EvSel": 185,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.HORZ_RING_IV_IN_USE.LEFT": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Horizontal IV Ring in Use",
	  "EvSel": 185,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.IIO_CREDITS_ACQUIRED": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of credits that are acquired in the M2PCIe agent for sending transactions into the IIO on either NCB or NCS are in use.  Transactions from the BL ring going into the IIO Agent must first acquire a credit.  These credits are for either the NCB or NCS message classes.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Credit Acquired",
	  "EvSel": 51,
	  "ExtSel": "",
     },
     "M2PCIe.IIO_CREDITS_ACQUIRED.NCB_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of credits that are acquired in the M2PCIe agent for sending transactions into the IIO on either NCB or NCS are in use.  Transactions from the BL ring going into the IIO Agent must first acquire a credit.  These credits are for either the NCB or NCS message classes.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Credit Acquired",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.IIO_CREDITS_ACQUIRED.NCB_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of credits that are acquired in the M2PCIe agent for sending transactions into the IIO on either NCB or NCS are in use.  Transactions from the BL ring going into the IIO Agent must first acquire a credit.  These credits are for either the NCB or NCS message classes.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Credit Acquired",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.IIO_CREDITS_ACQUIRED.NCS_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of credits that are acquired in the M2PCIe agent for sending transactions into the IIO on either NCB or NCS are in use.  Transactions from the BL ring going into the IIO Agent must first acquire a credit.  These credits are for either the NCB or NCS message classes.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Credit Acquired",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.IIO_CREDITS_ACQUIRED.DRS_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of credits that are acquired in the M2PCIe agent for sending transactions into the IIO on either NCB or NCS are in use.  Transactions from the BL ring going into the IIO Agent must first acquire a credit.  These credits are for either the NCB or NCS message classes.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Credit Acquired",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.IIO_CREDITS_ACQUIRED.NCS_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of credits that are acquired in the M2PCIe agent for sending transactions into the IIO on either NCB or NCS are in use.  Transactions from the BL ring going into the IIO Agent must first acquire a credit.  These credits are for either the NCB or NCS message classes.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Credit Acquired",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.IIO_CREDITS_ACQUIRED.DRS_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of credits that are acquired in the M2PCIe agent for sending transactions into the IIO on either NCB or NCS are in use.  Transactions from the BL ring going into the IIO Agent must first acquire a credit.  These credits are for either the NCB or NCS message classes.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Credit Acquired",
	  "EvSel": 51,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.IIO_CREDITS_REJECT": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times that a request pending in the BL Ingress attempted to acquire either a NCB or NCS credit to transmit into the IIO, but was rejected because no credits were available.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Failed to Acquire a Credit",
	  "EvSel": 52,
	  "ExtSel": "",
     },
     "M2PCIe.IIO_CREDITS_REJECT.DRS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times that a request pending in the BL Ingress attempted to acquire either a NCB or NCS credit to transmit into the IIO, but was rejected because no credits were available.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Failed to Acquire a Credit",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.IIO_CREDITS_REJECT.NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times that a request pending in the BL Ingress attempted to acquire either a NCB or NCS credit to transmit into the IIO, but was rejected because no credits were available.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Failed to Acquire a Credit",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.IIO_CREDITS_REJECT.NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times that a request pending in the BL Ingress attempted to acquire either a NCB or NCS credit to transmit into the IIO, but was rejected because no credits were available.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Failed to Acquire a Credit",
	  "EvSel": 52,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.IIO_CREDITS_USED": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when one or more credits in the M2PCIe agent for sending transactions into the IIO on either NCB or NCS are in use.  Transactions from the BL ring going into the IIO Agent must first acquire a credit.  These credits are for either the NCB or NCS message classes.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Credits in Use",
	  "EvSel": 50,
	  "ExtSel": "",
     },
     "M2PCIe.IIO_CREDITS_USED.DRS_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when one or more credits in the M2PCIe agent for sending transactions into the IIO on either NCB or NCS are in use.  Transactions from the BL ring going into the IIO Agent must first acquire a credit.  These credits are for either the NCB or NCS message classes.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Credits in Use",
	  "EvSel": 50,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.IIO_CREDITS_USED.NCS_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when one or more credits in the M2PCIe agent for sending transactions into the IIO on either NCB or NCS are in use.  Transactions from the BL ring going into the IIO Agent must first acquire a credit.  These credits are for either the NCB or NCS message classes.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Credits in Use",
	  "EvSel": 50,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.IIO_CREDITS_USED.DRS_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when one or more credits in the M2PCIe agent for sending transactions into the IIO on either NCB or NCS are in use.  Transactions from the BL ring going into the IIO Agent must first acquire a credit.  These credits are for either the NCB or NCS message classes.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Credits in Use",
	  "EvSel": 50,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.IIO_CREDITS_USED.NCS_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when one or more credits in the M2PCIe agent for sending transactions into the IIO on either NCB or NCS are in use.  Transactions from the BL ring going into the IIO Agent must first acquire a credit.  These credits are for either the NCB or NCS message classes.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Credits in Use",
	  "EvSel": 50,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.IIO_CREDITS_USED.NCB_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when one or more credits in the M2PCIe agent for sending transactions into the IIO on either NCB or NCS are in use.  Transactions from the BL ring going into the IIO Agent must first acquire a credit.  These credits are for either the NCB or NCS message classes.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Credits in Use",
	  "EvSel": 50,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.IIO_CREDITS_USED.NCB_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe IIO_CREDITS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when one or more credits in the M2PCIe agent for sending transactions into the IIO on either NCB or NCS are in use.  Transactions from the BL ring going into the IIO Agent must first acquire a credit.  These credits are for either the NCB or NCS message classes.  NCB, or non-coherent bypass messages are used to transmit data without coherency (and are common).  NCS is used for reads to PCIe (and should be used sparingly).",
	  "Desc": "M2PCIe IIO Credits in Use",
	  "EvSel": 50,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.LOCAL_DED_P2P_CRD_TAKEN_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Dedicated P2P Credit Taken - 0",
	  "EvSel": 70,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
     },
     "M2PCIe.LOCAL_DED_P2P_CRD_TAKEN_0.M2IOSF0_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Dedicated P2P Credit Taken - 0",
	  "EvSel": 70,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.LOCAL_DED_P2P_CRD_TAKEN_0.M2IOSF0_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Dedicated P2P Credit Taken - 0",
	  "EvSel": 70,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.LOCAL_DED_P2P_CRD_TAKEN_0.M2IOSF2_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Dedicated P2P Credit Taken - 0",
	  "EvSel": 70,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.LOCAL_DED_P2P_CRD_TAKEN_0.M2IOSF3_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Dedicated P2P Credit Taken - 0",
	  "EvSel": 70,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "b1xxxxxxx",
     },
     "M2PCIe.LOCAL_DED_P2P_CRD_TAKEN_0.M2IOSF3_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Dedicated P2P Credit Taken - 0",
	  "EvSel": 70,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.LOCAL_DED_P2P_CRD_TAKEN_0.M2IOSF2_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Dedicated P2P Credit Taken - 0",
	  "EvSel": 70,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.LOCAL_DED_P2P_CRD_TAKEN_0.M2IOSF1_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Dedicated P2P Credit Taken - 0",
	  "EvSel": 70,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.LOCAL_DED_P2P_CRD_TAKEN_0.M2IOSF1_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Dedicated P2P Credit Taken - 0",
	  "EvSel": 70,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.LOCAL_DED_P2P_CRD_TAKEN_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Dedicated P2P Credit Taken - 1",
	  "EvSel": 71,
	  "ExtSel": "",
     },
     "M2PCIe.LOCAL_DED_P2P_CRD_TAKEN_1.M2IOSF5_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Dedicated P2P Credit Taken - 1",
	  "EvSel": 71,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.LOCAL_DED_P2P_CRD_TAKEN_1.M2IOSF4_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Dedicated P2P Credit Taken - 1",
	  "EvSel": 71,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.LOCAL_DED_P2P_CRD_TAKEN_1.M2IOSF5_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Dedicated P2P Credit Taken - 1",
	  "EvSel": 71,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.LOCAL_DED_P2P_CRD_TAKEN_1.M2IOSF4_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Dedicated P2P Credit Taken - 1",
	  "EvSel": 71,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.LOCAL_P2P_DED_RETURNED_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Dedicated Credits Returned - 0",
	  "EvSel": 25,
	  "ExtSel": "",
     },
     "M2PCIe.LOCAL_P2P_DED_RETURNED_0.MS2IOSF0_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Dedicated Credits Returned - 0",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.LOCAL_P2P_DED_RETURNED_0.MS2IOSF0_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Dedicated Credits Returned - 0",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.LOCAL_P2P_DED_RETURNED_0.MS2IOSF1_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Dedicated Credits Returned - 0",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.LOCAL_P2P_DED_RETURNED_0.MS2IOSF3_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Dedicated Credits Returned - 0",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.LOCAL_P2P_DED_RETURNED_0.MS2IOSF2_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Dedicated Credits Returned - 0",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.LOCAL_P2P_DED_RETURNED_0.MS2IOSF1_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Dedicated Credits Returned - 0",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.LOCAL_P2P_DED_RETURNED_0.MS2IOSF2_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Dedicated Credits Returned - 0",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.LOCAL_P2P_DED_RETURNED_0.MS2IOSF3_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Dedicated Credits Returned - 0",
	  "EvSel": 25,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.LOCAL_P2P_DED_RETURNED_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Dedicated Credits Returned - 1",
	  "EvSel": 26,
	  "ExtSel": "",
     },
     "M2PCIe.LOCAL_P2P_DED_RETURNED_1.MS2IOSF4_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Dedicated Credits Returned - 1",
	  "EvSel": 26,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.LOCAL_P2P_DED_RETURNED_1.MS2IOSF5_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Dedicated Credits Returned - 1",
	  "EvSel": 26,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.LOCAL_P2P_DED_RETURNED_1.MS2IOSF4_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Dedicated Credits Returned - 1",
	  "EvSel": 26,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.LOCAL_P2P_DED_RETURNED_1.MS2IOSF5_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Dedicated Credits Returned - 1",
	  "EvSel": 26,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.LOCAL_P2P_SHAR_RETURNED": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Shared Credits Returned",
	  "EvSel": 23,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
     },
     "M2PCIe.LOCAL_P2P_SHAR_RETURNED.AGENT_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Shared Credits Returned",
	  "EvSel": 23,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.LOCAL_P2P_SHAR_RETURNED.AGENT_2": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Shared Credits Returned",
	  "EvSel": 23,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.LOCAL_P2P_SHAR_RETURNED.AGENT_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local P2P Shared Credits Returned",
	  "EvSel": 23,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_RETURNED": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Returned to credit ring",
	  "EvSel": 68,
	  "ExtSel": "",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_RETURNED.AGENT_3": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Returned to credit ring",
	  "EvSel": 68,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_RETURNED.AGENT_2": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Returned to credit ring",
	  "EvSel": 68,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_RETURNED.AGENT_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Returned to credit ring",
	  "EvSel": 68,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_RETURNED.AGENT_4": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Returned to credit ring",
	  "EvSel": 68,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_RETURNED.AGENT_5": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Returned to credit ring",
	  "EvSel": 68,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_RETURNED.AGENT_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Returned to credit ring",
	  "EvSel": 68,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_TAKEN_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Taken - 0",
	  "EvSel": 64,
	  "ExtSel": "",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_TAKEN_0.M2IOSF0_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Taken - 0",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_TAKEN_0.M2IOSF0_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Taken - 0",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_TAKEN_0.M2IOSF2_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Taken - 0",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_TAKEN_0.M2IOSF3_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Taken - 0",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_TAKEN_0.M2IOSF2_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Taken - 0",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_TAKEN_0.M2IOSF3_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Taken - 0",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_TAKEN_0.M2IOSF1_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Taken - 0",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_TAKEN_0.M2IOSF1_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Taken - 0",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_TAKEN_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Taken - 1",
	  "EvSel": 65,
	  "ExtSel": "",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_TAKEN_1.M2IOSF4_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Taken - 1",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_TAKEN_1.M2IOSF5_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Taken - 1",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_TAKEN_1.M2IOSF5_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Taken - 1",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_TAKEN_1.M2IOSF4_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Local Shared P2P Credit Taken - 1",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_WAIT_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Local Shared P2P Credit - 0",
	  "EvSel": 74,
	  "ExtSel": "",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_WAIT_0.M2IOSF0_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Local Shared P2P Credit - 0",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_WAIT_0.M2IOSF0_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Local Shared P2P Credit - 0",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_WAIT_0.M2IOSF3_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Local Shared P2P Credit - 0",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_WAIT_0.M2IOSF2_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Local Shared P2P Credit - 0",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_WAIT_0.M2IOSF3_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Local Shared P2P Credit - 0",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_WAIT_0.M2IOSF2_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Local Shared P2P Credit - 0",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_WAIT_0.M2IOSF1_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Local Shared P2P Credit - 0",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_WAIT_0.M2IOSF1_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Local Shared P2P Credit - 0",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_WAIT_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Local Shared P2P Credit - 1",
	  "EvSel": 75,
	  "ExtSel": "",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_WAIT_1.M2IOSF4_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Local Shared P2P Credit - 1",
	  "EvSel": 75,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_WAIT_1.M2IOSF5_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Local Shared P2P Credit - 1",
	  "EvSel": 75,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_WAIT_1.M2IOSF4_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Local Shared P2P Credit - 1",
	  "EvSel": 75,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.LOCAL_SHAR_P2P_CRD_WAIT_1.M2IOSF5_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Local Shared P2P Credit - 1",
	  "EvSel": 75,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.MISC_EXTERNAL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe External Misc Events (eg. From MS2IDI)",
	  "Desc": "Miscellaneous Events (mostly from MS2IDI)",
	  "EvSel": 230,
	  "ExtSel": "",
	  "Notes": "ONLY relevant to the CHA's CMS",
     },
     "M2PCIe.MISC_EXTERNAL.MBE_INST1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe External Misc Events (eg. From MS2IDI)",
	  "Desc": "Miscellaneous Events (mostly from MS2IDI)",
	  "EvSel": 230,
	  "ExtSel": "",
	  "Notes": "ONLY relevant to the CHA's CMS",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.MISC_EXTERNAL.MBE_INST0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe External Misc Events (eg. From MS2IDI)",
	  "Desc": "Miscellaneous Events (mostly from MS2IDI)",
	  "EvSel": 230,
	  "ExtSel": "",
	  "Notes": "ONLY relevant to the CHA's CMS",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.P2P_CRD_OCCUPANCY": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-1",
	  "Desc": "P2P Credit Occupancy",
	  "EvSel": 20,
	  "ExtSel": "",
	  "MaxIncCyc": 127,
     },
     "M2PCIe.P2P_CRD_OCCUPANCY.ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-1",
	  "Desc": "P2P Credit Occupancy",
	  "EvSel": 20,
	  "ExtSel": "",
	  "MaxIncCyc": 127,
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.P2P_CRD_OCCUPANCY.REMOTE_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-1",
	  "Desc": "P2P Credit Occupancy",
	  "EvSel": 20,
	  "ExtSel": "",
	  "MaxIncCyc": 127,
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.P2P_CRD_OCCUPANCY.LOCAL_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-1",
	  "Desc": "P2P Credit Occupancy",
	  "EvSel": 20,
	  "ExtSel": "",
	  "MaxIncCyc": 127,
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.P2P_CRD_OCCUPANCY.REMOTE_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-1",
	  "Desc": "P2P Credit Occupancy",
	  "EvSel": 20,
	  "ExtSel": "",
	  "MaxIncCyc": 127,
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.P2P_CRD_OCCUPANCY.LOCAL_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-1",
	  "Desc": "P2P Credit Occupancy",
	  "EvSel": 20,
	  "ExtSel": "",
	  "MaxIncCyc": 127,
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.P2P_DED_RECEIVED": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Dedicated Credits Received",
	  "EvSel": 22,
	  "ExtSel": "",
     },
     "M2PCIe.P2P_DED_RECEIVED.LOCAL_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Dedicated Credits Received",
	  "EvSel": 22,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.P2P_DED_RECEIVED.REMOTE_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Dedicated Credits Received",
	  "EvSel": 22,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.P2P_DED_RECEIVED.LOCAL_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Dedicated Credits Received",
	  "EvSel": 22,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.P2P_DED_RECEIVED.ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Dedicated Credits Received",
	  "EvSel": 22,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.P2P_DED_RECEIVED.REMOTE_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Dedicated Credits Received",
	  "EvSel": 22,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.P2P_SHAR_RECEIVED": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Shared Credits  Received",
	  "EvSel": 21,
	  "ExtSel": "",
     },
     "M2PCIe.P2P_SHAR_RECEIVED.REMOTE_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Shared Credits  Received",
	  "EvSel": 21,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.P2P_SHAR_RECEIVED.LOCAL_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Shared Credits  Received",
	  "EvSel": 21,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.P2P_SHAR_RECEIVED.REMOTE_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Shared Credits  Received",
	  "EvSel": 21,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.P2P_SHAR_RECEIVED.ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Shared Credits  Received",
	  "EvSel": 21,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.P2P_SHAR_RECEIVED.LOCAL_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Shared Credits  Received",
	  "EvSel": 21,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.REMOTE_DED_P2P_CRD_TAKEN_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Dedicated P2P Credit Taken - 0",
	  "EvSel": 72,
	  "ExtSel": "",
     },
     "M2PCIe.REMOTE_DED_P2P_CRD_TAKEN_0.UPI0_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Dedicated P2P Credit Taken - 0",
	  "EvSel": 72,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.REMOTE_DED_P2P_CRD_TAKEN_0.UPI0_DRS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Dedicated P2P Credit Taken - 0",
	  "EvSel": 72,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.REMOTE_DED_P2P_CRD_TAKEN_0.UPI1_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Dedicated P2P Credit Taken - 0",
	  "EvSel": 72,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.REMOTE_DED_P2P_CRD_TAKEN_0.UPI1_DRS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Dedicated P2P Credit Taken - 0",
	  "EvSel": 72,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.REMOTE_DED_P2P_CRD_TAKEN_0.UPI0_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Dedicated P2P Credit Taken - 0",
	  "EvSel": 72,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.REMOTE_DED_P2P_CRD_TAKEN_0.UPI1_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Dedicated P2P Credit Taken - 0",
	  "EvSel": 72,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.REMOTE_DED_P2P_CRD_TAKEN_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Dedicated P2P Credit Taken - 1",
	  "EvSel": 73,
	  "ExtSel": "",
     },
     "M2PCIe.REMOTE_DED_P2P_CRD_TAKEN_1.UPI2_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Dedicated P2P Credit Taken - 1",
	  "EvSel": 73,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.REMOTE_DED_P2P_CRD_TAKEN_1.UPI2_DRS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Dedicated P2P Credit Taken - 1",
	  "EvSel": 73,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.REMOTE_DED_P2P_CRD_TAKEN_1.UPI2_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Dedicated P2P Credit Taken - 1",
	  "EvSel": 73,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.REMOTE_P2P_DED_RETURNED": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote P2P Dedicated Credits Returned",
	  "EvSel": 27,
	  "ExtSel": "",
     },
     "M2PCIe.REMOTE_P2P_DED_RETURNED.UPI2_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote P2P Dedicated Credits Returned",
	  "EvSel": 27,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.REMOTE_P2P_DED_RETURNED.UPI1_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote P2P Dedicated Credits Returned",
	  "EvSel": 27,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.REMOTE_P2P_DED_RETURNED.UPI0_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote P2P Dedicated Credits Returned",
	  "EvSel": 27,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.REMOTE_P2P_DED_RETURNED.UPI1_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote P2P Dedicated Credits Returned",
	  "EvSel": 27,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.REMOTE_P2P_DED_RETURNED.UPI0_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote P2P Dedicated Credits Returned",
	  "EvSel": 27,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.REMOTE_P2P_DED_RETURNED.UPI2_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote P2P Dedicated Credits Returned",
	  "EvSel": 27,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.REMOTE_P2P_SHAR_RETURNED": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote P2P Shared Credits Returned",
	  "EvSel": 24,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
     },
     "M2PCIe.REMOTE_P2P_SHAR_RETURNED.AGENT_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote P2P Shared Credits Returned",
	  "EvSel": 24,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.REMOTE_P2P_SHAR_RETURNED.AGENT_2": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote P2P Shared Credits Returned",
	  "EvSel": 24,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.REMOTE_P2P_SHAR_RETURNED.AGENT_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote P2P Shared Credits Returned",
	  "EvSel": 24,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_RETURNED": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Shared P2P Credit Returned to credit ring",
	  "EvSel": 69,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_RETURNED.AGENT_2": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Shared P2P Credit Returned to credit ring",
	  "EvSel": 69,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_RETURNED.AGENT_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Shared P2P Credit Returned to credit ring",
	  "EvSel": 69,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_RETURNED.AGENT_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Shared P2P Credit Returned to credit ring",
	  "EvSel": 69,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_TAKEN_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Shared P2P Credit Taken - 0",
	  "EvSel": 66,
	  "ExtSel": "",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_TAKEN_0.UPI0_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Shared P2P Credit Taken - 0",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_TAKEN_0.UPI0_DRS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Shared P2P Credit Taken - 0",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_TAKEN_0.UPI1_DRS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Shared P2P Credit Taken - 0",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_TAKEN_0.UPI1_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Shared P2P Credit Taken - 0",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_TAKEN_0.UPI0_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Shared P2P Credit Taken - 0",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_TAKEN_0.UPI1_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Shared P2P Credit Taken - 0",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_TAKEN_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Shared P2P Credit Taken - 1",
	  "EvSel": 67,
	  "ExtSel": "",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_TAKEN_1.UPI2_DRS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Shared P2P Credit Taken - 1",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_TAKEN_1.UPI2_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Shared P2P Credit Taken - 1",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_TAKEN_1.UPI2_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Remote Shared P2P Credit Taken - 1",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_WAIT_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Remote Shared P2P Credit - 0",
	  "EvSel": 76,
	  "ExtSel": "",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_WAIT_0.UPI1_DRS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Remote Shared P2P Credit - 0",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_WAIT_0.UPI1_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Remote Shared P2P Credit - 0",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_WAIT_0.UPI0_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Remote Shared P2P Credit - 0",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_WAIT_0.UPI0_DRS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Remote Shared P2P Credit - 0",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_WAIT_0.UPI1_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Remote Shared P2P Credit - 0",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_WAIT_0.UPI0_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Remote Shared P2P Credit - 0",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_WAIT_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Remote Shared P2P Credit - 1",
	  "EvSel": 77,
	  "ExtSel": "",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_WAIT_1.UPI2_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Remote Shared P2P Credit - 1",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_WAIT_1.UPI2_DRS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Remote Shared P2P Credit - 1",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.REMOTE_SHAR_P2P_CRD_WAIT_1.UPI2_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS P2P Credit Events",
	  "Counters": "0-3",
	  "Desc": "Waiting on Remote Shared P2P Credit - 1",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.RING_BOUNCES_HORZ": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
     },
     "M2PCIe.RING_BOUNCES_HORZ.IV": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.RING_BOUNCES_HORZ.BL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.RING_BOUNCES_HORZ.AK": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.RING_BOUNCES_HORZ.AD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.RING_BOUNCES_VERT": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
     },
     "M2PCIe.RING_BOUNCES_VERT.AD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.RING_BOUNCES_VERT.BL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.RING_BOUNCES_VERT.IV": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.RING_BOUNCES_VERT.AKC": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.RING_BOUNCES_VERT.AK": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.RING_SINK_STARVED_HORZ": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
     },
     "M2PCIe.RING_SINK_STARVED_HORZ.AD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.RING_SINK_STARVED_HORZ.BL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.RING_SINK_STARVED_HORZ.IV": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.RING_SINK_STARVED_HORZ.AK": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.RING_SINK_STARVED_HORZ.AK_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.RING_SINK_STARVED_VERT": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
     },
     "M2PCIe.RING_SINK_STARVED_VERT.AD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.RING_SINK_STARVED_VERT.AKC": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.RING_SINK_STARVED_VERT.AK": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.RING_SINK_STARVED_VERT.IV": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.RING_SINK_STARVED_VERT.BL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.RING_SRC_THRTL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Horizontal  RING Events",
	  "Desc": "Source Throttle",
	  "EvSel": 174,
	  "ExtSel": "",
     },
     "M2PCIe.RxC_CYCLES_NE": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Ingress is not empty.",
	  "Desc": "Ingress (from CMS) Queue Cycles Not Empty",
	  "EvSel": 16,
	  "ExtSel": "",
     },
     "M2PCIe.RxC_CYCLES_NE.ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Ingress is not empty.",
	  "Desc": "Ingress (from CMS) Queue Cycles Not Empty",
	  "EvSel": 16,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2PCIe.RxC_CYCLES_NE.CHA_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Ingress is not empty.",
	  "Desc": "Ingress (from CMS) Queue Cycles Not Empty",
	  "EvSel": 16,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.RxC_CYCLES_NE.IIO_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Ingress is not empty.",
	  "Desc": "Ingress (from CMS) Queue Cycles Not Empty",
	  "EvSel": 16,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.RxC_CYCLES_NE.CHA_IDI": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Ingress is not empty.",
	  "Desc": "Ingress (from CMS) Queue Cycles Not Empty",
	  "EvSel": 16,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.RxC_CYCLES_NE.UPI_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Ingress is not empty.",
	  "Desc": "Ingress (from CMS) Queue Cycles Not Empty",
	  "EvSel": 16,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.RxC_CYCLES_NE.CHA_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Ingress is not empty.",
	  "Desc": "Ingress (from CMS) Queue Cycles Not Empty",
	  "EvSel": 16,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.RxC_CYCLES_NE.IIO_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Ingress is not empty.",
	  "Desc": "Ingress (from CMS) Queue Cycles Not Empty",
	  "EvSel": 16,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.RxC_CYCLES_NE.UPI_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Ingress is not empty.",
	  "Desc": "Ingress (from CMS) Queue Cycles Not Empty",
	  "EvSel": 16,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.RxC_INSERTS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries inserted into the M2PCIe Ingress Queue.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue latency.",
	  "Desc": "Ingress (from CMS) Queue Inserts",
	  "EvSel": 17,
	  "ExtSel": "",
     },
     "M2PCIe.RxC_INSERTS.UPI_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries inserted into the M2PCIe Ingress Queue.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue latency.",
	  "Desc": "Ingress (from CMS) Queue Inserts",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.RxC_INSERTS.CHA_IDI": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries inserted into the M2PCIe Ingress Queue.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue latency.",
	  "Desc": "Ingress (from CMS) Queue Inserts",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.RxC_INSERTS.IIO_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries inserted into the M2PCIe Ingress Queue.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue latency.",
	  "Desc": "Ingress (from CMS) Queue Inserts",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.RxC_INSERTS.ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries inserted into the M2PCIe Ingress Queue.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue latency.",
	  "Desc": "Ingress (from CMS) Queue Inserts",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2PCIe.RxC_INSERTS.CHA_NCB": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries inserted into the M2PCIe Ingress Queue.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue latency.",
	  "Desc": "Ingress (from CMS) Queue Inserts",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.RxC_INSERTS.UPI_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries inserted into the M2PCIe Ingress Queue.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue latency.",
	  "Desc": "Ingress (from CMS) Queue Inserts",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.RxC_INSERTS.IIO_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries inserted into the M2PCIe Ingress Queue.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue latency.",
	  "Desc": "Ingress (from CMS) Queue Inserts",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.RxC_INSERTS.CHA_NCS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe INGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of entries inserted into the M2PCIe Ingress Queue.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue latency.",
	  "Desc": "Ingress (from CMS) Queue Inserts",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.RxR_BUSY_STARVED": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
     },
     "M2PCIe.RxR_BUSY_STARVED.BL_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "M2PCIe.RxR_BUSY_STARVED.AD_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "M2PCIe.RxR_BUSY_STARVED.AD_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "M2PCIe.RxR_BUSY_STARVED.BL_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "M2PCIe.RxR_BUSY_STARVED.BL_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000000",
     },
     "M2PCIe.RxR_BUSY_STARVED.AD_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "M2PCIe.RxR_BYPASS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
     },
     "M2PCIe.RxR_BYPASS.IV": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00001000",
     },
     "M2PCIe.RxR_BYPASS.AKC_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b10000000",
     },
     "M2PCIe.RxR_BYPASS.BL_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "M2PCIe.RxR_BYPASS.AD_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "M2PCIe.RxR_BYPASS.BL_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000000",
     },
     "M2PCIe.RxR_BYPASS.AD_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "M2PCIe.RxR_BYPASS.AK": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000010",
     },
     "M2PCIe.RxR_BYPASS.BL_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "M2PCIe.RxR_BYPASS.AD_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "M2PCIe.RxR_CRD_STARVED": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
     },
     "M2PCIe.RxR_CRD_STARVED.BL_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "M2PCIe.RxR_CRD_STARVED.AD_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "M2PCIe.RxR_CRD_STARVED.BL_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b01000000",
     },
     "M2PCIe.RxR_CRD_STARVED.AK": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00000010",
     },
     "M2PCIe.RxR_CRD_STARVED.AD_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "M2PCIe.RxR_CRD_STARVED.IFV": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b10000000",
     },
     "M2PCIe.RxR_CRD_STARVED.AD_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "M2PCIe.RxR_CRD_STARVED.BL_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "M2PCIe.RxR_CRD_STARVED.IV": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00001000",
     },
     "M2PCIe.RxR_CRD_STARVED_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 228,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
     },
     "M2PCIe.RxR_INSERTS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
     },
     "M2PCIe.RxR_INSERTS.BL_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "M2PCIe.RxR_INSERTS.AD_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "M2PCIe.RxR_INSERTS.BL_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000000",
     },
     "M2PCIe.RxR_INSERTS.AD_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "M2PCIe.RxR_INSERTS.AK": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000010",
     },
     "M2PCIe.RxR_INSERTS.AD_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "M2PCIe.RxR_INSERTS.AKC_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b10000000",
     },
     "M2PCIe.RxR_INSERTS.IV": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00001000",
     },
     "M2PCIe.RxR_INSERTS.BL_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "M2PCIe.RxR_OCCUPANCY": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
     },
     "M2PCIe.RxR_OCCUPANCY.BL_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00100000",
     },
     "M2PCIe.RxR_OCCUPANCY.AK": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000010",
     },
     "M2PCIe.RxR_OCCUPANCY.AD_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "M2PCIe.RxR_OCCUPANCY.BL_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "M2PCIe.RxR_OCCUPANCY.AD_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "M2PCIe.RxR_OCCUPANCY.IV": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00001000",
     },
     "M2PCIe.RxR_OCCUPANCY.AKC_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b10000000",
     },
     "M2PCIe.RxR_OCCUPANCY.BL_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "M2PCIe.RxR_OCCUPANCY.AD_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR2": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR7": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR3": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR6": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR4": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR5": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR2": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR5": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR4": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR6": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR3": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR7": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR2": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR3": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR7": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR6": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR4": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR5": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR2": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR6": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR7": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR3": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR4": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR5": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.STALL1_NO_TxR_HORZ_CRD_AD_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 209,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M2PCIe.STALL1_NO_TxR_HORZ_CRD_AD_AG0.TGR10": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 209,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.STALL1_NO_TxR_HORZ_CRD_AD_AG0.TGR9": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 209,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.STALL1_NO_TxR_HORZ_CRD_AD_AG0.TGR8": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 209,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.STALL1_NO_TxR_HORZ_CRD_AD_AG1_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M2PCIe.STALL1_NO_TxR_HORZ_CRD_AD_AG1_1.TGR8": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.STALL1_NO_TxR_HORZ_CRD_AD_AG1_1.TGR10": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.STALL1_NO_TxR_HORZ_CRD_AD_AG1_1.TGR9": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.STALL1_NO_TxR_HORZ_CRD_BL_AG0_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 213,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M2PCIe.STALL1_NO_TxR_HORZ_CRD_BL_AG0_1.TGR8": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 213,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.STALL1_NO_TxR_HORZ_CRD_BL_AG0_1.TGR10": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 213,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.STALL1_NO_TxR_HORZ_CRD_BL_AG0_1.TGR9": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 213,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.STALL1_NO_TxR_HORZ_CRD_BL_AG1_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M2PCIe.STALL1_NO_TxR_HORZ_CRD_BL_AG1_1.TGR10": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.STALL1_NO_TxR_HORZ_CRD_BL_AG1_1.TGR9": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.STALL1_NO_TxR_HORZ_CRD_BL_AG1_1.TGR8": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxC_CREDITS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-1",
	  "EvSel": 45,
	  "ExtSel": "",
	  "MaxIncCyc": 4,
     },
     "M2PCIe.TxC_CREDITS.PMM": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-1",
	  "EvSel": 45,
	  "ExtSel": "",
	  "MaxIncCyc": 4,
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.TxC_CREDITS.PRQ": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-1",
	  "EvSel": 45,
	  "ExtSel": "",
	  "MaxIncCyc": 4,
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxC_CYCLES_FULL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is full.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.",
	  "Desc": "Egress (to CMS) Cycles Full",
	  "EvSel": 37,
	  "ExtSel": "",
     },
     "M2PCIe.TxC_CYCLES_FULL.AD_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is full.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.",
	  "Desc": "Egress (to CMS) Cycles Full",
	  "EvSel": 37,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.TxC_CYCLES_FULL.AD_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is full.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.",
	  "Desc": "Egress (to CMS) Cycles Full",
	  "EvSel": 37,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxC_CYCLES_FULL.PMM_BLOCK_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is full.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.",
	  "Desc": "Egress (to CMS) Cycles Full",
	  "EvSel": 37,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.TxC_CYCLES_FULL.BL_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is full.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.",
	  "Desc": "Egress (to CMS) Cycles Full",
	  "EvSel": 37,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.TxC_CYCLES_FULL.PMM_BLOCK_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is full.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.",
	  "Desc": "Egress (to CMS) Cycles Full",
	  "EvSel": 37,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2PCIe.TxC_CYCLES_FULL.BL_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is full.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.",
	  "Desc": "Egress (to CMS) Cycles Full",
	  "EvSel": 37,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.TxC_CYCLES_FULL.AK_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is full.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.",
	  "Desc": "Egress (to CMS) Cycles Full",
	  "EvSel": 37,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.TxC_CYCLES_FULL.AK_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is full.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.",
	  "Desc": "Egress (to CMS) Cycles Full",
	  "EvSel": 37,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.TxC_CYCLES_NE": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is not empty.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple egress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "Egress (to CMS) Cycles Not Empty",
	  "EvSel": 35,
	  "ExtSel": "",
     },
     "M2PCIe.TxC_CYCLES_NE.PMM_DISTRESS_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is not empty.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple egress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "Egress (to CMS) Cycles Not Empty",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.TxC_CYCLES_NE.AK_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is not empty.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple egress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "Egress (to CMS) Cycles Not Empty",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.TxC_CYCLES_NE.PMM_DISTRESS_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is not empty.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple egress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "Egress (to CMS) Cycles Not Empty",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2PCIe.TxC_CYCLES_NE.AK_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is not empty.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple egress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "Egress (to CMS) Cycles Not Empty",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.TxC_CYCLES_NE.AD_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is not empty.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple egress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "Egress (to CMS) Cycles Not Empty",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.TxC_CYCLES_NE.AD_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is not empty.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple egress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "Egress (to CMS) Cycles Not Empty",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxC_CYCLES_NE.BL_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is not empty.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple egress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "Egress (to CMS) Cycles Not Empty",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.TxC_CYCLES_NE.BL_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-1",
	  "Defn": "Counts the number of cycles when the M2PCIe Egress is not empty.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple egress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "Egress (to CMS) Cycles Not Empty",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.TxC_INSERTS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of number of messages inserted into the  the M2PCIe Egress queue.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue occupancy.",
	  "Desc": "Egress (to CMS) Ingress",
	  "EvSel": 36,
	  "ExtSel": "",
     },
     "M2PCIe.TxC_INSERTS.AD_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of number of messages inserted into the  the M2PCIe Egress queue.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue occupancy.",
	  "Desc": "Egress (to CMS) Ingress",
	  "EvSel": 36,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxC_INSERTS.AD_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of number of messages inserted into the  the M2PCIe Egress queue.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue occupancy.",
	  "Desc": "Egress (to CMS) Ingress",
	  "EvSel": 36,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.TxC_INSERTS.BL_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of number of messages inserted into the  the M2PCIe Egress queue.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue occupancy.",
	  "Desc": "Egress (to CMS) Ingress",
	  "EvSel": 36,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.TxC_INSERTS.BL_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of number of messages inserted into the  the M2PCIe Egress queue.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue occupancy.",
	  "Desc": "Egress (to CMS) Ingress",
	  "EvSel": 36,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.TxC_INSERTS.AK_CRD_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of number of messages inserted into the  the M2PCIe Egress queue.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue occupancy.",
	  "Desc": "Egress (to CMS) Ingress",
	  "EvSel": 36,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M2PCIe.TxC_INSERTS.AK_CRD_0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe EGRESS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of number of messages inserted into the  the M2PCIe Egress queue.  This tracks messages for one of the two CMS ports that are used by the M2PCIe agent.  This can be used in conjunction with the M2PCIe Ingress Occupancy Accumulator event in order to calculate average queue occupancy.",
	  "Desc": "Egress (to CMS) Ingress",
	  "EvSel": 36,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.TxR_HORZ_ADS_USED": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_HORZ_ADS_USED.AD_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M2PCIe.TxR_HORZ_ADS_USED.BL_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2PCIe.TxR_HORZ_ADS_USED.BL_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2PCIe.TxR_HORZ_ADS_USED.AD_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2PCIe.TxR_HORZ_ADS_USED.AD_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2PCIe.TxR_HORZ_ADS_USED.BL_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M2PCIe.TxR_HORZ_BYPASS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_HORZ_BYPASS.BL_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2PCIe.TxR_HORZ_BYPASS.AK": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2PCIe.TxR_HORZ_BYPASS.AD_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M2PCIe.TxR_HORZ_BYPASS.BL_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M2PCIe.TxR_HORZ_BYPASS.AD_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2PCIe.TxR_HORZ_BYPASS.BL_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2PCIe.TxR_HORZ_BYPASS.AKC_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2PCIe.TxR_HORZ_BYPASS.IV": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2PCIe.TxR_HORZ_BYPASS.AD_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2PCIe.TxR_HORZ_CYCLES_FULL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_HORZ_CYCLES_FULL.AD_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2PCIe.TxR_HORZ_CYCLES_FULL.IV": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2PCIe.TxR_HORZ_CYCLES_FULL.AKC_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2PCIe.TxR_HORZ_CYCLES_FULL.BL_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2PCIe.TxR_HORZ_CYCLES_FULL.BL_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M2PCIe.TxR_HORZ_CYCLES_FULL.AD_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2PCIe.TxR_HORZ_CYCLES_FULL.BL_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2PCIe.TxR_HORZ_CYCLES_FULL.AD_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M2PCIe.TxR_HORZ_CYCLES_FULL.AK": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2PCIe.TxR_HORZ_CYCLES_NE": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_HORZ_CYCLES_NE.AD_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2PCIe.TxR_HORZ_CYCLES_NE.IV": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2PCIe.TxR_HORZ_CYCLES_NE.AKC_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2PCIe.TxR_HORZ_CYCLES_NE.BL_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2PCIe.TxR_HORZ_CYCLES_NE.AD_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2PCIe.TxR_HORZ_CYCLES_NE.BL_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M2PCIe.TxR_HORZ_CYCLES_NE.AK": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2PCIe.TxR_HORZ_CYCLES_NE.AD_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M2PCIe.TxR_HORZ_CYCLES_NE.BL_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2PCIe.TxR_HORZ_INSERTS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_HORZ_INSERTS.AD_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2PCIe.TxR_HORZ_INSERTS.AKC_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2PCIe.TxR_HORZ_INSERTS.IV": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2PCIe.TxR_HORZ_INSERTS.BL_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2PCIe.TxR_HORZ_INSERTS.BL_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M2PCIe.TxR_HORZ_INSERTS.AD_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2PCIe.TxR_HORZ_INSERTS.BL_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2PCIe.TxR_HORZ_INSERTS.AD_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M2PCIe.TxR_HORZ_INSERTS.AK": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2PCIe.TxR_HORZ_NACK": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_HORZ_NACK.BL_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M2PCIe.TxR_HORZ_NACK.AD_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2PCIe.TxR_HORZ_NACK.BL_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2PCIe.TxR_HORZ_NACK.AD_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M2PCIe.TxR_HORZ_NACK.AK": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2PCIe.TxR_HORZ_NACK.AD_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2PCIe.TxR_HORZ_NACK.AKC_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2PCIe.TxR_HORZ_NACK.BL_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2PCIe.TxR_HORZ_NACK.IV": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2PCIe.TxR_HORZ_OCCUPANCY": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_HORZ_OCCUPANCY.AD_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M2PCIe.TxR_HORZ_OCCUPANCY.BL_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M2PCIe.TxR_HORZ_OCCUPANCY.AK": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2PCIe.TxR_HORZ_OCCUPANCY.AD_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M2PCIe.TxR_HORZ_OCCUPANCY.BL_CRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M2PCIe.TxR_HORZ_OCCUPANCY.AD_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2PCIe.TxR_HORZ_OCCUPANCY.AKC_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2PCIe.TxR_HORZ_OCCUPANCY.IV": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2PCIe.TxR_HORZ_OCCUPANCY.BL_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2PCIe.TxR_HORZ_STARVED": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_HORZ_STARVED.AK": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M2PCIe.TxR_HORZ_STARVED.AD_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2PCIe.TxR_HORZ_STARVED.BL_ALL": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2PCIe.TxR_HORZ_STARVED.AKC_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M2PCIe.TxR_HORZ_STARVED.IV": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M2PCIe.TxR_HORZ_STARVED.BL_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M2PCIe.TxR_HORZ_STARVED.AD_UNCRD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M2PCIe.TxR_VERT_ADS_USED": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_VERT_ADS_USED.BL_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.TxR_VERT_ADS_USED.AD_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxR_VERT_ADS_USED.BL_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.TxR_VERT_ADS_USED.AD_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.TxR_VERT_BYPASS": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_VERT_BYPASS.BL_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.TxR_VERT_BYPASS.AD_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxR_VERT_BYPASS.AK_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.TxR_VERT_BYPASS.AD_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.TxR_VERT_BYPASS.AK_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.TxR_VERT_BYPASS.IV_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.TxR_VERT_BYPASS.BL_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.TxR_VERT_BYPASS_1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 158,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_VERT_BYPASS_1.AKC_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 158,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxR_VERT_BYPASS_1.AKC_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 158,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.TxR_VERT_CYCLES_FULL0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_VERT_CYCLES_FULL0.AK_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.TxR_VERT_CYCLES_FULL0.AD_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxR_VERT_CYCLES_FULL0.IV_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.TxR_VERT_CYCLES_FULL0.BL_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.TxR_VERT_CYCLES_FULL0.BL_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.TxR_VERT_CYCLES_FULL0.AD_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.TxR_VERT_CYCLES_FULL0.AK_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.TxR_VERT_CYCLES_FULL1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 149,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_VERT_CYCLES_FULL1.AKC_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 149,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxR_VERT_CYCLES_FULL1.AKC_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 149,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.TxR_VERT_CYCLES_NE0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_VERT_CYCLES_NE0.BL_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.TxR_VERT_CYCLES_NE0.AD_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.TxR_VERT_CYCLES_NE0.AK_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.TxR_VERT_CYCLES_NE0.AK_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.TxR_VERT_CYCLES_NE0.AD_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxR_VERT_CYCLES_NE0.IV_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.TxR_VERT_CYCLES_NE0.BL_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.TxR_VERT_CYCLES_NE1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 151,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_VERT_CYCLES_NE1.AKC_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 151,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.TxR_VERT_CYCLES_NE1.AKC_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 151,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxR_VERT_INSERTS0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_VERT_INSERTS0.IV_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.TxR_VERT_INSERTS0.BL_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.TxR_VERT_INSERTS0.AD_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxR_VERT_INSERTS0.AK_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.TxR_VERT_INSERTS0.AD_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.TxR_VERT_INSERTS0.AK_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.TxR_VERT_INSERTS0.BL_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.TxR_VERT_INSERTS1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 147,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_VERT_INSERTS1.AKC_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 147,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.TxR_VERT_INSERTS1.AKC_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 147,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxR_VERT_NACK0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_VERT_NACK0.IV_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.TxR_VERT_NACK0.BL_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.TxR_VERT_NACK0.AK_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.TxR_VERT_NACK0.AD_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxR_VERT_NACK0.AD_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.TxR_VERT_NACK0.AK_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.TxR_VERT_NACK0.BL_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.TxR_VERT_NACK1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 153,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_VERT_NACK1.AKC_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 153,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.TxR_VERT_NACK1.AKC_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 153,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxR_VERT_OCCUPANCY0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_VERT_OCCUPANCY0.BL_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.TxR_VERT_OCCUPANCY0.IV_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.TxR_VERT_OCCUPANCY0.AK_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.TxR_VERT_OCCUPANCY0.AD_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxR_VERT_OCCUPANCY0.AK_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.TxR_VERT_OCCUPANCY0.AD_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.TxR_VERT_OCCUPANCY0.BL_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.TxR_VERT_OCCUPANCY1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 145,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_VERT_OCCUPANCY1.AKC_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 145,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxR_VERT_OCCUPANCY1.AKC_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 145,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.TxR_VERT_STARVED0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_VERT_STARVED0.AD_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxR_VERT_STARVED0.AK_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M2PCIe.TxR_VERT_STARVED0.BL_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.TxR_VERT_STARVED0.IV_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.TxR_VERT_STARVED0.BL_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M2PCIe.TxR_VERT_STARVED0.AD_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M2PCIe.TxR_VERT_STARVED0.AK_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.TxR_VERT_STARVED1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 155,
	  "ExtSel": "",
     },
     "M2PCIe.TxR_VERT_STARVED1.AKC_AG0": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 155,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.TxR_VERT_STARVED1.AKC_AG1": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 155,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.TxR_VERT_STARVED1.TGC": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 155,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.VERT_RING_AD_IN_USE": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
     },
     "M2PCIe.VERT_RING_AD_IN_USE.UP_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.VERT_RING_AD_IN_USE.DN_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.VERT_RING_AD_IN_USE.DN_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.VERT_RING_AD_IN_USE.UP_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.VERT_RING_AKC_IN_USE": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
     },
     "M2PCIe.VERT_RING_AKC_IN_USE.UP_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.VERT_RING_AKC_IN_USE.DN_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.VERT_RING_AKC_IN_USE.DN_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.VERT_RING_AKC_IN_USE.UP_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.VERT_RING_AK_IN_USE": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
     },
     "M2PCIe.VERT_RING_AK_IN_USE.DN_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.VERT_RING_AK_IN_USE.UP_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.VERT_RING_AK_IN_USE.UP_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.VERT_RING_AK_IN_USE.DN_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.VERT_RING_BL_IN_USE": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
     },
     "M2PCIe.VERT_RING_BL_IN_USE.DN_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.VERT_RING_BL_IN_USE.UP_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.VERT_RING_BL_IN_USE.UP_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.VERT_RING_BL_IN_USE.DN_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.VERT_RING_IV_IN_USE": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Vertical IV Ring in Use",
	  "EvSel": 179,
	  "ExtSel": "",
     },
     "M2PCIe.VERT_RING_IV_IN_USE.DN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Vertical IV Ring in Use",
	  "EvSel": 179,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M2PCIe.VERT_RING_IV_IN_USE.UP": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Vertical IV Ring in Use",
	  "EvSel": 179,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.VERT_RING_TGC_IN_USE": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
     },
     "M2PCIe.VERT_RING_TGC_IN_USE.DN_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M2PCIe.VERT_RING_TGC_IN_USE.UP_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M2PCIe.VERT_RING_TGC_IN_USE.UP_ODD": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M2PCIe.VERT_RING_TGC_IN_USE.DN_EVEN": {
	  "Box": "M2PCIe",
	  "Category": "M2PCIe Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },

# UBOX:
     "UBOX.EVENT_MSG": {
	  "Box": "UBOX",
	  "Category": "UBOX EVENT_MSG Events",
	  "Counters": "0-1",
	  "Desc": "Message Received",
	  "EvSel": 66,
	  "ExtSel": "",
     },
     "UBOX.EVENT_MSG.VLW_RCVD": {
	  "Box": "UBOX",
	  "Category": "UBOX EVENT_MSG Events",
	  "Counters": "0-1",
	  "Desc": "Message Received",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "UBOX.EVENT_MSG.INT_PRIO": {
	  "Box": "UBOX",
	  "Category": "UBOX EVENT_MSG Events",
	  "Counters": "0-1",
	  "Desc": "Message Received",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "UBOX.EVENT_MSG.MSI_RCVD": {
	  "Box": "UBOX",
	  "Category": "UBOX EVENT_MSG Events",
	  "Counters": "0-1",
	  "Desc": "Message Received",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "UBOX.EVENT_MSG.DOORBELL_RCVD": {
	  "Box": "UBOX",
	  "Category": "UBOX EVENT_MSG Events",
	  "Counters": "0-1",
	  "Desc": "Message Received",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "UBOX.EVENT_MSG.IPI_RCVD": {
	  "Box": "UBOX",
	  "Category": "UBOX EVENT_MSG Events",
	  "Counters": "0-1",
	  "Desc": "Message Received",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "UBOX.LOCK_CYCLES": {
	  "Box": "UBOX",
	  "Category": "UBOX LOCK Events",
	  "Counters": "0-1",
	  "Defn": "Number of times an IDI Lock/SplitLock sequence was started",
	  "Desc": "IDI Lock/SplitLock Cycles",
	  "EvSel": 68,
	  "ExtSel": "",
     },
     "UBOX.M2U_MISC1": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 77,
	  "ExtSel": "",
     },
     "UBOX.M2U_MISC1.RxC_CYCLES_NE_UPI_NCS": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "UBOX.M2U_MISC1.RxC_CYCLES_NE_CBO_NCS": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "UBOX.M2U_MISC1.TxC_CYCLES_CRD_OVF_CBO_NCS": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "UBOX.M2U_MISC1.TxC_CYCLES_CRD_OVF_UPI_NCS": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "UBOX.M2U_MISC1.RxC_CYCLES_NE_CBO_NCB": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "UBOX.M2U_MISC1.TxC_CYCLES_CRD_OVF_UPI_NCB": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "UBOX.M2U_MISC1.RxC_CYCLES_NE_UPI_NCB": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "UBOX.M2U_MISC1.TxC_CYCLES_CRD_OVF_CBO_NCB": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "UBOX.M2U_MISC2": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 78,
	  "ExtSel": "",
     },
     "UBOX.M2U_MISC2.RxC_CYCLES_EMPTY_BL": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "UBOX.M2U_MISC2.TxC_CYCLES_FULL_BL": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "UBOX.M2U_MISC2.TxC_CYCLES_CRD_OVF_VN0_NCB": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "UBOX.M2U_MISC2.TxC_CYCLES_EMPTY_AK": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "UBOX.M2U_MISC2.TxC_CYCLES_EMPTY_BL": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "UBOX.M2U_MISC2.RxC_CYCLES_FULL_BL": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "UBOX.M2U_MISC2.TxC_CYCLES_CRD_OVF_VN0_NCS": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "UBOX.M2U_MISC2.TxC_CYCLES_EMPTY_AKC": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "UBOX.M2U_MISC3": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 79,
	  "ExtSel": "",
     },
     "UBOX.M2U_MISC3.TxC_CYCLES_FULL_AK": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 79,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "UBOX.M2U_MISC3.TxC_CYCLES_FULL_AKC": {
	  "Box": "UBOX",
	  "Category": "UBOX M2U Events",
	  "EvSel": 79,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "UBOX.PHOLD_CYCLES": {
	  "Box": "UBOX",
	  "Category": "UBOX PHOLD Events",
	  "Counters": "0-1",
	  "Defn": "PHOLD cycles.",
	  "Desc": "Cycles PHOLD Assert to Ack",
	  "EvSel": 69,
	  "ExtSel": "",
     },
     "UBOX.PHOLD_CYCLES.ASSERT_TO_ACK": {
	  "Box": "UBOX",
	  "Category": "UBOX PHOLD Events",
	  "Counters": "0-1",
	  "Defn": "PHOLD cycles.",
	  "Desc": "Cycles PHOLD Assert to Ack",
	  "EvSel": 69,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "UBOX.RACU_DRNG": {
	  "Box": "UBOX",
	  "Category": "UBOX RACU Events",
	  "EvSel": 76,
	  "ExtSel": "",
     },
     "UBOX.RACU_DRNG.PFTCH_BUF_EMPTY": {
	  "Box": "UBOX",
	  "Category": "UBOX RACU Events",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "UBOX.RACU_DRNG.RDSEED": {
	  "Box": "UBOX",
	  "Category": "UBOX RACU Events",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "UBOX.RACU_DRNG.RDRAND": {
	  "Box": "UBOX",
	  "Category": "UBOX RACU Events",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "UBOX.RACU_REQUESTS": {
	  "Box": "UBOX",
	  "Category": "UBOX RACU Events",
	  "Counters": "0-1",
	  "Defn": "Number outstanding register requests within message channel tracker",
	  "Desc": "RACU Request",
	  "EvSel": 70,
	  "ExtSel": "",
	  "Notes": "RACU = Register Access Control Unit",
     },

# M3UPI:
     "M3UPI.AG0_AD_CRD_ACQUIRED0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
     },
     "M3UPI.AG0_AD_CRD_ACQUIRED0.TGR4": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.AG0_AD_CRD_ACQUIRED0.TGR5": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.AG0_AD_CRD_ACQUIRED0.TGR7": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.AG0_AD_CRD_ACQUIRED0.TGR3": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.AG0_AD_CRD_ACQUIRED0.TGR6": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.AG0_AD_CRD_ACQUIRED0.TGR1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.AG0_AD_CRD_ACQUIRED0.TGR0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.AG0_AD_CRD_ACQUIRED0.TGR2": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 128,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.AG0_AD_CRD_ACQUIRED1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 129,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
     },
     "M3UPI.AG0_AD_CRD_ACQUIRED1.TGR8": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 129,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.AG0_AD_CRD_ACQUIRED1.TGR10": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 129,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.AG0_AD_CRD_ACQUIRED1.TGR9": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 AD Credits Acquired",
	  "EvSel": 129,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.AG0_AD_CRD_OCCUPANCY0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
     },
     "M3UPI.AG0_AD_CRD_OCCUPANCY0.TGR1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000010",
     },
     "M3UPI.AG0_AD_CRD_OCCUPANCY0.TGR0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000001",
     },
     "M3UPI.AG0_AD_CRD_OCCUPANCY0.TGR2": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000100",
     },
     "M3UPI.AG0_AD_CRD_OCCUPANCY0.TGR4": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00010000",
     },
     "M3UPI.AG0_AD_CRD_OCCUPANCY0.TGR5": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00100000",
     },
     "M3UPI.AG0_AD_CRD_OCCUPANCY0.TGR3": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00001000",
     },
     "M3UPI.AG0_AD_CRD_OCCUPANCY0.TGR7": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b10000000",
     },
     "M3UPI.AG0_AD_CRD_OCCUPANCY0.TGR6": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b01000000",
     },
     "M3UPI.AG0_AD_CRD_OCCUPANCY1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 131,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
     },
     "M3UPI.AG0_AD_CRD_OCCUPANCY1.TGR8": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 131,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000001",
     },
     "M3UPI.AG0_AD_CRD_OCCUPANCY1.TGR10": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 131,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000100",
     },
     "M3UPI.AG0_AD_CRD_OCCUPANCY1.TGR9": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 AD Credits Occupancy",
	  "EvSel": 131,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000010",
     },
     "M3UPI.AG0_BL_CRD_ACQUIRED0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
     },
     "M3UPI.AG0_BL_CRD_ACQUIRED0.TGR5": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.AG0_BL_CRD_ACQUIRED0.TGR4": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.AG0_BL_CRD_ACQUIRED0.TGR7": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.AG0_BL_CRD_ACQUIRED0.TGR3": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.AG0_BL_CRD_ACQUIRED0.TGR6": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.AG0_BL_CRD_ACQUIRED0.TGR1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.AG0_BL_CRD_ACQUIRED0.TGR0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.AG0_BL_CRD_ACQUIRED0.TGR2": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 136,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.AG0_BL_CRD_ACQUIRED1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 137,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M3UPI.AG0_BL_CRD_ACQUIRED1.TGR9": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 137,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.AG0_BL_CRD_ACQUIRED1.TGR10": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 137,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.AG0_BL_CRD_ACQUIRED1.TGR8": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent0 BL Credits Acquired",
	  "EvSel": 137,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.AG0_BL_CRD_OCCUPANCY0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
     },
     "M3UPI.AG0_BL_CRD_OCCUPANCY0.TGR6": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M3UPI.AG0_BL_CRD_OCCUPANCY0.TGR7": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M3UPI.AG0_BL_CRD_OCCUPANCY0.TGR3": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M3UPI.AG0_BL_CRD_OCCUPANCY0.TGR5": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00100000",
     },
     "M3UPI.AG0_BL_CRD_OCCUPANCY0.TGR4": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M3UPI.AG0_BL_CRD_OCCUPANCY0.TGR2": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M3UPI.AG0_BL_CRD_OCCUPANCY0.TGR0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M3UPI.AG0_BL_CRD_OCCUPANCY0.TGR1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 138,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M3UPI.AG0_BL_CRD_OCCUPANCY1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 139,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M3UPI.AG0_BL_CRD_OCCUPANCY1.TGR9": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 139,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000010",
     },
     "M3UPI.AG0_BL_CRD_OCCUPANCY1.TGR10": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 139,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000100",
     },
     "M3UPI.AG0_BL_CRD_OCCUPANCY1.TGR8": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 0 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent0 BL Credits Occupancy",
	  "EvSel": 139,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000001",
     },
     "M3UPI.AG1_AD_CRD_ACQUIRED0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
     },
     "M3UPI.AG1_AD_CRD_ACQUIRED0.TGR1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.AG1_AD_CRD_ACQUIRED0.TGR0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.AG1_AD_CRD_ACQUIRED0.TGR2": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.AG1_AD_CRD_ACQUIRED0.TGR5": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.AG1_AD_CRD_ACQUIRED0.TGR4": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.AG1_AD_CRD_ACQUIRED0.TGR7": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.AG1_AD_CRD_ACQUIRED0.TGR3": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.AG1_AD_CRD_ACQUIRED0.TGR6": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.AG1_AD_CRD_ACQUIRED1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 133,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
     },
     "M3UPI.AG1_AD_CRD_ACQUIRED1.TGR8": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 133,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.AG1_AD_CRD_ACQUIRED1.TGR9": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 133,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.AG1_AD_CRD_ACQUIRED1.TGR10": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 AD Credits Acquired",
	  "EvSel": 133,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the OR of all selected.   Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.AG1_AD_CRD_OCCUPANCY0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
     },
     "M3UPI.AG1_AD_CRD_OCCUPANCY0.TGR4": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00010000",
     },
     "M3UPI.AG1_AD_CRD_OCCUPANCY0.TGR5": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00100000",
     },
     "M3UPI.AG1_AD_CRD_OCCUPANCY0.TGR7": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b10000000",
     },
     "M3UPI.AG1_AD_CRD_OCCUPANCY0.TGR3": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00001000",
     },
     "M3UPI.AG1_AD_CRD_OCCUPANCY0.TGR6": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b01000000",
     },
     "M3UPI.AG1_AD_CRD_OCCUPANCY0.TGR1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000010",
     },
     "M3UPI.AG1_AD_CRD_OCCUPANCY0.TGR0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000001",
     },
     "M3UPI.AG1_AD_CRD_OCCUPANCY0.TGR2": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected",
	  "Umask": "b00000100",
     },
     "M3UPI.AG1_AD_CRD_OCCUPANCY1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 135,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
     },
     "M3UPI.AG1_AD_CRD_OCCUPANCY1.TGR8": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 135,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000001",
     },
     "M3UPI.AG1_AD_CRD_OCCUPANCY1.TGR9": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 135,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000010",
     },
     "M3UPI.AG1_AD_CRD_OCCUPANCY1.TGR10": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 AD credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 AD Credits Occupancy",
	  "EvSel": 135,
	  "ExtSel": "",
	  "Notes": "If multiple masks are selected, will count the SUM of all selected.  Extension not used by ICX.",
	  "Umask": "b00000100",
     },
     "M3UPI.AG1_BL_CRD_ACQUIRED0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
     },
     "M3UPI.AG1_BL_CRD_ACQUIRED0.TGR3": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.AG1_BL_CRD_ACQUIRED0.TGR7": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.AG1_BL_CRD_ACQUIRED0.TGR6": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.AG1_BL_CRD_ACQUIRED0.TGR4": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.AG1_BL_CRD_ACQUIRED0.TGR5": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.AG1_BL_CRD_ACQUIRED0.TGR2": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.AG1_BL_CRD_ACQUIRED0.TGR1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.AG1_BL_CRD_ACQUIRED0.TGR0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 140,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.AG1_BL_CRD_ACQUIRED1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 141,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M3UPI.AG1_BL_CRD_ACQUIRED1.TGR8": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 141,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.AG1_BL_CRD_ACQUIRED1.TGR9": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 141,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.AG1_BL_CRD_ACQUIRED1.TGR10": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits acquired in a given cycle, per transgress.",
	  "Desc": "CMS Agent1 BL Credits Acquired",
	  "EvSel": 141,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.AG1_BL_CRD_OCCUPANCY0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
     },
     "M3UPI.AG1_BL_CRD_OCCUPANCY0.TGR0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M3UPI.AG1_BL_CRD_OCCUPANCY0.TGR1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M3UPI.AG1_BL_CRD_OCCUPANCY0.TGR2": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M3UPI.AG1_BL_CRD_OCCUPANCY0.TGR5": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00100000",
     },
     "M3UPI.AG1_BL_CRD_OCCUPANCY0.TGR4": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M3UPI.AG1_BL_CRD_OCCUPANCY0.TGR6": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M3UPI.AG1_BL_CRD_OCCUPANCY0.TGR7": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M3UPI.AG1_BL_CRD_OCCUPANCY0.TGR3": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 142,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M3UPI.AG1_BL_CRD_OCCUPANCY1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 143,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M3UPI.AG1_BL_CRD_OCCUPANCY1.TGR8": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 143,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000001",
     },
     "M3UPI.AG1_BL_CRD_OCCUPANCY1.TGR9": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 143,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000010",
     },
     "M3UPI.AG1_BL_CRD_OCCUPANCY1.TGR10": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of CMS Agent 1 BL credits in use in a given cycle, per transgress",
	  "Desc": "CMS Agent1 BL Credits Occupancy",
	  "EvSel": 143,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "b00000100",
     },
     "M3UPI.CHA_AD_CREDITS_EMPTY": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to Cbox on the AD Ring (covers higher CBoxes)",
	  "Desc": "CBox AD Credits Empty",
	  "EvSel": 34,
	  "ExtSel": "",
     },
     "M3UPI.CHA_AD_CREDITS_EMPTY.WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to Cbox on the AD Ring (covers higher CBoxes)",
	  "Desc": "CBox AD Credits Empty",
	  "EvSel": 34,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.CHA_AD_CREDITS_EMPTY.SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to Cbox on the AD Ring (covers higher CBoxes)",
	  "Desc": "CBox AD Credits Empty",
	  "EvSel": 34,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.CHA_AD_CREDITS_EMPTY.REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to Cbox on the AD Ring (covers higher CBoxes)",
	  "Desc": "CBox AD Credits Empty",
	  "EvSel": 34,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.CHA_AD_CREDITS_EMPTY.VNA": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to Cbox on the AD Ring (covers higher CBoxes)",
	  "Desc": "CBox AD Credits Empty",
	  "EvSel": 34,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.CLOCKTICKS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI UCLK Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of uclks in the M3 uclk domain.  This could be slightly different than the count in the Ubox because of enable/freeze delays.  However, because the M3 is close to the Ubox, they generally should not diverge by more than a handful of cycles.",
	  "Desc": "Clockticks of the mesh to UPI (M3UPI)",
	  "EvSel": 1,
	  "ExtSel": "",
     },
     "M3UPI.CMS_CLOCKTICKS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Misc Events",
	  "Desc": "CMS Clockticks",
	  "EvSel": 192,
	  "ExtSel": "",
     },
     "M3UPI.D2C_SENT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Special Egress Events",
	  "Counters": "0-3",
	  "Defn": "Count cases BL sends direct to core",
	  "Desc": "D2C Sent",
	  "EvSel": 43,
	  "ExtSel": "",
     },
     "M3UPI.D2U_SENT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Special Egress Events",
	  "Counters": "0-3",
	  "Defn": "Cases where SMI3 sends D2U command",
	  "Desc": "D2U Sent",
	  "EvSel": 42,
	  "ExtSel": "",
	  "Notes": "NOT required anymore",
     },
     "M3UPI.DISTRESS_ASSERTED": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
     },
     "M3UPI.DISTRESS_ASSERTED.DPT_NONLOCAL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.DISTRESS_ASSERTED.VERT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M3UPI.DISTRESS_ASSERTED.PMM_NONLOCAL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.DISTRESS_ASSERTED.HORZ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M3UPI.DISTRESS_ASSERTED.PMM_LOCAL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.DISTRESS_ASSERTED.DPT_LOCAL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.DISTRESS_ASSERTED.DPT_STALL_NOCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.DISTRESS_ASSERTED.DPT_STALL_IV": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Defn": "Counts the number of cycles either the local or incoming distress signals are asserted.",
	  "Desc": "Distress signal asserted",
	  "EvSel": 175,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.EGRESS_ORDERING": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts number of cycles IV was blocked in the TGR Egress due to SNP/GO Ordering requirements",
	  "Desc": "Egress Blocking due to Ordering requirements",
	  "EvSel": 186,
	  "ExtSel": "",
     },
     "M3UPI.EGRESS_ORDERING.IV_SNOOPGO_UP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts number of cycles IV was blocked in the TGR Egress due to SNP/GO Ordering requirements",
	  "Desc": "Egress Blocking due to Ordering requirements",
	  "EvSel": 186,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.EGRESS_ORDERING.IV_SNOOPGO_DN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts number of cycles IV was blocked in the TGR Egress due to SNP/GO Ordering requirements",
	  "Desc": "Egress Blocking due to Ordering requirements",
	  "EvSel": 186,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.HORZ_RING_AD_IN_USE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
     },
     "M3UPI.HORZ_RING_AD_IN_USE.LEFT_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.HORZ_RING_AD_IN_USE.LEFT_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.HORZ_RING_AD_IN_USE.RIGHT_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.HORZ_RING_AD_IN_USE.RIGHT_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AD Ring In Use",
	  "EvSel": 182,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.HORZ_RING_AKC_IN_USE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
     },
     "M3UPI.HORZ_RING_AKC_IN_USE.RIGHT_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.HORZ_RING_AKC_IN_USE.LEFT_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.HORZ_RING_AKC_IN_USE.LEFT_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.HORZ_RING_AKC_IN_USE.RIGHT_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 187,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.HORZ_RING_AK_IN_USE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
     },
     "M3UPI.HORZ_RING_AK_IN_USE.RIGHT_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.HORZ_RING_AK_IN_USE.LEFT_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.HORZ_RING_AK_IN_USE.LEFT_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.HORZ_RING_AK_IN_USE.RIGHT_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal AK Ring In Use",
	  "EvSel": 183,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.HORZ_RING_BL_IN_USE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
     },
     "M3UPI.HORZ_RING_BL_IN_USE.RIGHT_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.HORZ_RING_BL_IN_USE.LEFT_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.HORZ_RING_BL_IN_USE.LEFT_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.HORZ_RING_BL_IN_USE.RIGHT_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Horizontal BL Ring in Use",
	  "EvSel": 184,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.HORZ_RING_IV_IN_USE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Horizontal IV Ring in Use",
	  "EvSel": 185,
	  "ExtSel": "",
     },
     "M3UPI.HORZ_RING_IV_IN_USE.LEFT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Horizontal IV Ring in Use",
	  "EvSel": 185,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.HORZ_RING_IV_IN_USE.RIGHT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal In Use RING Events",
	  "Defn": "Counts the number of cycles that the Horizontal IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Horizontal IV Ring in Use",
	  "EvSel": 185,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.M2_BL_CREDITS_EMPTY": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No vn0 and vna credits available to send to M2",
	  "Desc": "M2 BL Credits Empty",
	  "EvSel": 35,
	  "ExtSel": "",
     },
     "M3UPI.M2_BL_CREDITS_EMPTY.IIO4_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No vn0 and vna credits available to send to M2",
	  "Desc": "M2 BL Credits Empty",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.M2_BL_CREDITS_EMPTY.IIO5_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No vn0 and vna credits available to send to M2",
	  "Desc": "M2 BL Credits Empty",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.M2_BL_CREDITS_EMPTY.IIO3_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No vn0 and vna credits available to send to M2",
	  "Desc": "M2 BL Credits Empty",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.M2_BL_CREDITS_EMPTY.NCS_SEL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No vn0 and vna credits available to send to M2",
	  "Desc": "M2 BL Credits Empty",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.M2_BL_CREDITS_EMPTY.IIO1_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No vn0 and vna credits available to send to M2",
	  "Desc": "M2 BL Credits Empty",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.M2_BL_CREDITS_EMPTY.NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No vn0 and vna credits available to send to M2",
	  "Desc": "M2 BL Credits Empty",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.M2_BL_CREDITS_EMPTY.UBOX_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No vn0 and vna credits available to send to M2",
	  "Desc": "M2 BL Credits Empty",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.M2_BL_CREDITS_EMPTY.IIO2_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No vn0 and vna credits available to send to M2",
	  "Desc": "M2 BL Credits Empty",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.MISC_EXTERNAL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI External Misc Events (eg. From MS2IDI)",
	  "Desc": "Miscellaneous Events (mostly from MS2IDI)",
	  "EvSel": 230,
	  "ExtSel": "",
	  "Notes": "ONLY relevant to the CHA's CMS",
     },
     "M3UPI.MISC_EXTERNAL.MBE_INST0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI External Misc Events (eg. From MS2IDI)",
	  "Desc": "Miscellaneous Events (mostly from MS2IDI)",
	  "EvSel": 230,
	  "ExtSel": "",
	  "Notes": "ONLY relevant to the CHA's CMS",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.MISC_EXTERNAL.MBE_INST1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI External Misc Events (eg. From MS2IDI)",
	  "Desc": "Miscellaneous Events (mostly from MS2IDI)",
	  "EvSel": 230,
	  "ExtSel": "",
	  "Notes": "ONLY relevant to the CHA's CMS",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.MULTI_SLOT_RCVD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Special Egress Events",
	  "Counters": "0-3",
	  "Defn": "Multi slot flit received - S0, S1 and/or S2 populated (can use AK S0/S1 masks for AK allocations)",
	  "Desc": "Multi Slot Flit Received",
	  "EvSel": 62,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "subevents added to 5b?",
     },
     "M3UPI.MULTI_SLOT_RCVD.AK_SLOT2": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Special Egress Events",
	  "Counters": "0-3",
	  "Defn": "Multi slot flit received - S0, S1 and/or S2 populated (can use AK S0/S1 masks for AK allocations)",
	  "Desc": "Multi Slot Flit Received",
	  "EvSel": 62,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.MULTI_SLOT_RCVD.AD_SLOT0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Special Egress Events",
	  "Counters": "0-3",
	  "Defn": "Multi slot flit received - S0, S1 and/or S2 populated (can use AK S0/S1 masks for AK allocations)",
	  "Desc": "Multi Slot Flit Received",
	  "EvSel": 62,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.MULTI_SLOT_RCVD.BL_SLOT0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Special Egress Events",
	  "Counters": "0-3",
	  "Defn": "Multi slot flit received - S0, S1 and/or S2 populated (can use AK S0/S1 masks for AK allocations)",
	  "Desc": "Multi Slot Flit Received",
	  "EvSel": 62,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.MULTI_SLOT_RCVD.AD_SLOT2": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Special Egress Events",
	  "Counters": "0-3",
	  "Defn": "Multi slot flit received - S0, S1 and/or S2 populated (can use AK S0/S1 masks for AK allocations)",
	  "Desc": "Multi Slot Flit Received",
	  "EvSel": 62,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.MULTI_SLOT_RCVD.AK_SLOT0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Special Egress Events",
	  "Counters": "0-3",
	  "Defn": "Multi slot flit received - S0, S1 and/or S2 populated (can use AK S0/S1 masks for AK allocations)",
	  "Desc": "Multi Slot Flit Received",
	  "EvSel": 62,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.MULTI_SLOT_RCVD.AD_SLOT1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Special Egress Events",
	  "Counters": "0-3",
	  "Defn": "Multi slot flit received - S0, S1 and/or S2 populated (can use AK S0/S1 masks for AK allocations)",
	  "Desc": "Multi Slot Flit Received",
	  "EvSel": 62,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RING_BOUNCES_HORZ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
     },
     "M3UPI.RING_BOUNCES_HORZ.AK": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RING_BOUNCES_HORZ.IV": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RING_BOUNCES_HORZ.BL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RING_BOUNCES_HORZ.AD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Defn": "Number of cycles incoming messages from the Horizontal ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Horizontal Ring.",
	  "EvSel": 172,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RING_BOUNCES_VERT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
     },
     "M3UPI.RING_BOUNCES_VERT.AD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RING_BOUNCES_VERT.AK": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RING_BOUNCES_VERT.AKC": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RING_BOUNCES_VERT.IV": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RING_BOUNCES_VERT.BL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical RING Events",
	  "Defn": "Number of cycles incoming messages from the Vertical ring that were bounced, by ring type.",
	  "Desc": "Messages that bounced on the Vertical Ring.",
	  "EvSel": 170,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RING_SINK_STARVED_HORZ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
     },
     "M3UPI.RING_SINK_STARVED_HORZ.AD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RING_SINK_STARVED_HORZ.AK_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RING_SINK_STARVED_HORZ.AK": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RING_SINK_STARVED_HORZ.IV": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RING_SINK_STARVED_HORZ.BL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Desc": "Sink Starvation on Horizontal Ring",
	  "EvSel": 173,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RING_SINK_STARVED_VERT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
     },
     "M3UPI.RING_SINK_STARVED_VERT.AKC": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RING_SINK_STARVED_VERT.AK": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RING_SINK_STARVED_VERT.IV": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RING_SINK_STARVED_VERT.BL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RING_SINK_STARVED_VERT.AD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical RING Events",
	  "Desc": "Sink Starvation on Vertical Ring",
	  "EvSel": 171,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RING_SRC_THRTL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Horizontal  RING Events",
	  "Desc": "Source Throttle",
	  "EvSel": 174,
	  "ExtSel": "",
     },
     "M3UPI.RxC_ARB_LOST_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message requested but lost arbitration",
	  "Desc": "Lost Arb for VN0",
	  "EvSel": 75,
	  "ExtSel": "",
     },
     "M3UPI.RxC_ARB_LOST_VN0.BL_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message requested but lost arbitration",
	  "Desc": "Lost Arb for VN0",
	  "EvSel": 75,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_ARB_LOST_VN0.BL_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message requested but lost arbitration",
	  "Desc": "Lost Arb for VN0",
	  "EvSel": 75,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_ARB_LOST_VN0.BL_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message requested but lost arbitration",
	  "Desc": "Lost Arb for VN0",
	  "EvSel": 75,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_ARB_LOST_VN0.AD_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message requested but lost arbitration",
	  "Desc": "Lost Arb for VN0",
	  "EvSel": 75,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_ARB_LOST_VN0.AD_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message requested but lost arbitration",
	  "Desc": "Lost Arb for VN0",
	  "EvSel": 75,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_ARB_LOST_VN0.BL_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message requested but lost arbitration",
	  "Desc": "Lost Arb for VN0",
	  "EvSel": 75,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_ARB_LOST_VN0.AD_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message requested but lost arbitration",
	  "Desc": "Lost Arb for VN0",
	  "EvSel": 75,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_ARB_LOST_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message requested but lost arbitration",
	  "Desc": "Lost Arb for VN1",
	  "EvSel": 76,
	  "ExtSel": "",
     },
     "M3UPI.RxC_ARB_LOST_VN1.AD_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message requested but lost arbitration",
	  "Desc": "Lost Arb for VN1",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_ARB_LOST_VN1.AD_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message requested but lost arbitration",
	  "Desc": "Lost Arb for VN1",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_ARB_LOST_VN1.BL_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message requested but lost arbitration",
	  "Desc": "Lost Arb for VN1",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_ARB_LOST_VN1.BL_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message requested but lost arbitration",
	  "Desc": "Lost Arb for VN1",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_ARB_LOST_VN1.BL_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message requested but lost arbitration",
	  "Desc": "Lost Arb for VN1",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_ARB_LOST_VN1.AD_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message requested but lost arbitration",
	  "Desc": "Lost Arb for VN1",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_ARB_LOST_VN1.BL_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message requested but lost arbitration",
	  "Desc": "Lost Arb for VN1",
	  "EvSel": 76,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_ARB_MISC": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Desc": "Arb Miscellaneous",
	  "EvSel": 77,
	  "ExtSel": "",
     },
     "M3UPI.RxC_ARB_MISC.ALL_PARALLEL_WIN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Desc": "Arb Miscellaneous",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.RxC_ARB_MISC.NO_PROG_AD_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Desc": "Arb Miscellaneous",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_ARB_MISC.NO_PROG_AD_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Desc": "Arb Miscellaneous",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_ARB_MISC.ADBL_PARALLEL_WIN_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Desc": "Arb Miscellaneous",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_ARB_MISC.ADBL_PARALLEL_WIN_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Desc": "Arb Miscellaneous",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_ARB_MISC.NO_PROG_BL_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Desc": "Arb Miscellaneous",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_ARB_MISC.VN01_PARALLEL_WIN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Desc": "Arb Miscellaneous",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_ARB_MISC.NO_PROG_BL_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Desc": "Arb Miscellaneous",
	  "EvSel": 77,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_ARB_NOCRD_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message is blocked from requesting arbitration due to lack of remote UPI credits",
	  "Desc": "No Credits to Arb for VN0",
	  "EvSel": 71,
	  "ExtSel": "",
     },
     "M3UPI.RxC_ARB_NOCRD_VN0.AD_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message is blocked from requesting arbitration due to lack of remote UPI credits",
	  "Desc": "No Credits to Arb for VN0",
	  "EvSel": 71,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_ARB_NOCRD_VN0.AD_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message is blocked from requesting arbitration due to lack of remote UPI credits",
	  "Desc": "No Credits to Arb for VN0",
	  "EvSel": 71,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_ARB_NOCRD_VN0.BL_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message is blocked from requesting arbitration due to lack of remote UPI credits",
	  "Desc": "No Credits to Arb for VN0",
	  "EvSel": 71,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_ARB_NOCRD_VN0.BL_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message is blocked from requesting arbitration due to lack of remote UPI credits",
	  "Desc": "No Credits to Arb for VN0",
	  "EvSel": 71,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_ARB_NOCRD_VN0.BL_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message is blocked from requesting arbitration due to lack of remote UPI credits",
	  "Desc": "No Credits to Arb for VN0",
	  "EvSel": 71,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_ARB_NOCRD_VN0.AD_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message is blocked from requesting arbitration due to lack of remote UPI credits",
	  "Desc": "No Credits to Arb for VN0",
	  "EvSel": 71,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_ARB_NOCRD_VN0.BL_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message is blocked from requesting arbitration due to lack of remote UPI credits",
	  "Desc": "No Credits to Arb for VN0",
	  "EvSel": 71,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_ARB_NOCRD_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message is blocked from requesting arbitration due to lack of remote UPI credits",
	  "Desc": "No Credits to Arb for VN1",
	  "EvSel": 72,
	  "ExtSel": "",
     },
     "M3UPI.RxC_ARB_NOCRD_VN1.AD_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message is blocked from requesting arbitration due to lack of remote UPI credits",
	  "Desc": "No Credits to Arb for VN1",
	  "EvSel": 72,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_ARB_NOCRD_VN1.AD_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message is blocked from requesting arbitration due to lack of remote UPI credits",
	  "Desc": "No Credits to Arb for VN1",
	  "EvSel": 72,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_ARB_NOCRD_VN1.BL_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message is blocked from requesting arbitration due to lack of remote UPI credits",
	  "Desc": "No Credits to Arb for VN1",
	  "EvSel": 72,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_ARB_NOCRD_VN1.BL_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message is blocked from requesting arbitration due to lack of remote UPI credits",
	  "Desc": "No Credits to Arb for VN1",
	  "EvSel": 72,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_ARB_NOCRD_VN1.BL_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message is blocked from requesting arbitration due to lack of remote UPI credits",
	  "Desc": "No Credits to Arb for VN1",
	  "EvSel": 72,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_ARB_NOCRD_VN1.AD_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message is blocked from requesting arbitration due to lack of remote UPI credits",
	  "Desc": "No Credits to Arb for VN1",
	  "EvSel": 72,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_ARB_NOCRD_VN1.BL_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message is blocked from requesting arbitration due to lack of remote UPI credits",
	  "Desc": "No Credits to Arb for VN1",
	  "EvSel": 72,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_ARB_NOREQ_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message was not able to request arbitration while some other message won arbitration",
	  "Desc": "Can't Arb for VN0",
	  "EvSel": 73,
	  "ExtSel": "",
     },
     "M3UPI.RxC_ARB_NOREQ_VN0.BL_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message was not able to request arbitration while some other message won arbitration",
	  "Desc": "Can't Arb for VN0",
	  "EvSel": 73,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_ARB_NOREQ_VN0.AD_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message was not able to request arbitration while some other message won arbitration",
	  "Desc": "Can't Arb for VN0",
	  "EvSel": 73,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_ARB_NOREQ_VN0.BL_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message was not able to request arbitration while some other message won arbitration",
	  "Desc": "Can't Arb for VN0",
	  "EvSel": 73,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_ARB_NOREQ_VN0.BL_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message was not able to request arbitration while some other message won arbitration",
	  "Desc": "Can't Arb for VN0",
	  "EvSel": 73,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_ARB_NOREQ_VN0.BL_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message was not able to request arbitration while some other message won arbitration",
	  "Desc": "Can't Arb for VN0",
	  "EvSel": 73,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_ARB_NOREQ_VN0.AD_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message was not able to request arbitration while some other message won arbitration",
	  "Desc": "Can't Arb for VN0",
	  "EvSel": 73,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_ARB_NOREQ_VN0.AD_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN0 message was not able to request arbitration while some other message won arbitration",
	  "Desc": "Can't Arb for VN0",
	  "EvSel": 73,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_ARB_NOREQ_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message was not able to request arbitration while some other message won arbitration",
	  "Desc": "Can't Arb for VN1",
	  "EvSel": 74,
	  "ExtSel": "",
     },
     "M3UPI.RxC_ARB_NOREQ_VN1.AD_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message was not able to request arbitration while some other message won arbitration",
	  "Desc": "Can't Arb for VN1",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_ARB_NOREQ_VN1.BL_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message was not able to request arbitration while some other message won arbitration",
	  "Desc": "Can't Arb for VN1",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_ARB_NOREQ_VN1.AD_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message was not able to request arbitration while some other message won arbitration",
	  "Desc": "Can't Arb for VN1",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_ARB_NOREQ_VN1.AD_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message was not able to request arbitration while some other message won arbitration",
	  "Desc": "Can't Arb for VN1",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_ARB_NOREQ_VN1.BL_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message was not able to request arbitration while some other message won arbitration",
	  "Desc": "Can't Arb for VN1",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_ARB_NOREQ_VN1.BL_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message was not able to request arbitration while some other message won arbitration",
	  "Desc": "Can't Arb for VN1",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_ARB_NOREQ_VN1.BL_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Arbitration Events",
	  "Defn": "VN1 message was not able to request arbitration while some other message won arbitration",
	  "Desc": "Can't Arb for VN1",
	  "EvSel": 74,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_BYPASSED": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Counters": "0-2",
	  "Defn": "Number ot times message is bypassed around the Ingress Queue",
	  "Desc": "Ingress Queue Bypasses",
	  "EvSel": 64,
	  "ExtSel": "",
     },
     "M3UPI.RxC_BYPASSED.AD_S1_BL_SLOT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Counters": "0-2",
	  "Defn": "Number ot times message is bypassed around the Ingress Queue",
	  "Desc": "Ingress Queue Bypasses",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_BYPASSED.AD_S0_BL_ARB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Counters": "0-2",
	  "Defn": "Number ot times message is bypassed around the Ingress Queue",
	  "Desc": "Ingress Queue Bypasses",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_BYPASSED.AD_S0_IDLE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Counters": "0-2",
	  "Defn": "Number ot times message is bypassed around the Ingress Queue",
	  "Desc": "Ingress Queue Bypasses",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_BYPASSED.AD_S2_BL_SLOT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Counters": "0-2",
	  "Defn": "Number ot times message is bypassed around the Ingress Queue",
	  "Desc": "Ingress Queue Bypasses",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_CRD_MISC": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Miscellaneous Credit Events",
	  "EvSel": 95,
	  "ExtSel": "",
     },
     "M3UPI.RxC_CRD_MISC.ANY_BGF_PATH": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Miscellaneous Credit Events",
	  "EvSel": 95,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_CRD_MISC.LT2_FOR_D2K": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Miscellaneous Credit Events",
	  "EvSel": 95,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_CRD_MISC.ANY_BGF_FIFO": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Miscellaneous Credit Events",
	  "EvSel": 95,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_CRD_MISC.LT1_FOR_D2K": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Miscellaneous Credit Events",
	  "EvSel": 95,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_CRD_MISC.VN1_NO_D2K_FOR_ARB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Miscellaneous Credit Events",
	  "EvSel": 95,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_CRD_MISC.VN0_NO_D2K_FOR_ARB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Miscellaneous Credit Events",
	  "EvSel": 95,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_CRD_OCC": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Credit Occupancy",
	  "EvSel": 96,
	  "ExtSel": "",
     },
     "M3UPI.RxC_CRD_OCC.D2K_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Credit Occupancy",
	  "EvSel": 96,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_CRD_OCC.TxQ_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Credit Occupancy",
	  "EvSel": 96,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_CRD_OCC.VNA_IN_USE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Credit Occupancy",
	  "EvSel": 96,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_CRD_OCC.P1P_FIFO": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Credit Occupancy",
	  "EvSel": 96,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_CRD_OCC.P1P_TOTAL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Credit Occupancy",
	  "EvSel": 96,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_CRD_OCC.FLITS_IN_FIFO": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Credit Occupancy",
	  "EvSel": 96,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_CRD_OCC.FLITS_IN_PATH": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Credit Occupancy",
	  "EvSel": 96,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_CRD_OCC.CONSUMED": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Credit Occupancy",
	  "EvSel": 96,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.RxC_CYCLES_NE_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of cycles when the UPI Ingress is not empty.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Cycles Not Empty",
	  "EvSel": 67,
	  "ExtSel": "",
     },
     "M3UPI.RxC_CYCLES_NE_VN0.BL_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of cycles when the UPI Ingress is not empty.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Cycles Not Empty",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_CYCLES_NE_VN0.AD_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of cycles when the UPI Ingress is not empty.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Cycles Not Empty",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_CYCLES_NE_VN0.AD_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of cycles when the UPI Ingress is not empty.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Cycles Not Empty",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_CYCLES_NE_VN0.AD_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of cycles when the UPI Ingress is not empty.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Cycles Not Empty",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_CYCLES_NE_VN0.BL_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of cycles when the UPI Ingress is not empty.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Cycles Not Empty",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_CYCLES_NE_VN0.BL_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of cycles when the UPI Ingress is not empty.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Cycles Not Empty",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_CYCLES_NE_VN0.BL_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of cycles when the UPI Ingress is not empty.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI Ingress Occupancy Accumulator event in order to calculate average queue occupancy.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Cycles Not Empty",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_CYCLES_NE_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI VN1  Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI VN1  Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Cycles Not Empty",
	  "EvSel": 68,
	  "ExtSel": "",
     },
     "M3UPI.RxC_CYCLES_NE_VN1.AD_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI VN1  Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI VN1  Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Cycles Not Empty",
	  "EvSel": 68,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_CYCLES_NE_VN1.BL_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI VN1  Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI VN1  Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Cycles Not Empty",
	  "EvSel": 68,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_CYCLES_NE_VN1.BL_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI VN1  Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI VN1  Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Cycles Not Empty",
	  "EvSel": 68,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_CYCLES_NE_VN1.BL_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI VN1  Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI VN1  Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Cycles Not Empty",
	  "EvSel": 68,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_CYCLES_NE_VN1.BL_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI VN1  Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI VN1  Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Cycles Not Empty",
	  "EvSel": 68,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_CYCLES_NE_VN1.AD_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI VN1  Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI VN1  Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Cycles Not Empty",
	  "EvSel": 68,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_CYCLES_NE_VN1.AD_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI VN1  Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI VN1  Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Cycles Not Empty",
	  "EvSel": 68,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_DATA_FLITS_NOT_SENT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Data flit is ready for transmission but could not be sent",
	  "Desc": "Data Flit Not Sent",
	  "EvSel": 85,
	  "ExtSel": "",
     },
     "M3UPI.RxC_DATA_FLITS_NOT_SENT.NO_BGF": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Data flit is ready for transmission but could not be sent",
	  "Desc": "Data Flit Not Sent",
	  "EvSel": 85,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_DATA_FLITS_NOT_SENT.NO_TXQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Data flit is ready for transmission but could not be sent",
	  "Desc": "Data Flit Not Sent",
	  "EvSel": 85,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_DATA_FLITS_NOT_SENT.TSV_HI": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Data flit is ready for transmission but could not be sent",
	  "Desc": "Data Flit Not Sent",
	  "EvSel": 85,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_DATA_FLITS_NOT_SENT.ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Data flit is ready for transmission but could not be sent",
	  "Desc": "Data Flit Not Sent",
	  "EvSel": 85,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_DATA_FLITS_NOT_SENT.VALID_FOR_FLIT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Data flit is ready for transmission but could not be sent",
	  "Desc": "Data Flit Not Sent",
	  "EvSel": 85,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_FLITS_GEN_BL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Generating BL Data Flit Sequence",
	  "EvSel": 87,
	  "ExtSel": "",
     },
     "M3UPI.RxC_FLITS_GEN_BL.P1P_HOLD_P0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Generating BL Data Flit Sequence",
	  "EvSel": 87,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_FLITS_GEN_BL.P1P_BUSY": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Generating BL Data Flit Sequence",
	  "EvSel": 87,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_FLITS_GEN_BL.P0_WAIT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Generating BL Data Flit Sequence",
	  "EvSel": 87,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_FLITS_GEN_BL.P1P_AT_LIMIT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Generating BL Data Flit Sequence",
	  "EvSel": 87,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_FLITS_GEN_BL.P1_WAIT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Generating BL Data Flit Sequence",
	  "EvSel": 87,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_FLITS_GEN_BL.P1P_TO_LIMBO": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Generating BL Data Flit Sequence",
	  "EvSel": 87,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_FLITS_GEN_BL.P1P_FIFO_FULL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Generating BL Data Flit Sequence",
	  "EvSel": 87,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_FLITS_MISC": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "EvSel": 88,
	  "ExtSel": "",
     },
     "M3UPI.RxC_FLITS_MISC.S2REQ_WITHDRAWN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_FLITS_MISC.S2REQ_RECEIVED": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_FLITS_MISC.S2REQ_IN_SERVICE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_FLITS_MISC.S2REQ_IN_HOLDOFF": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "EvSel": 88,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_FLITS_SLOT_BL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Slotting BL Message Into Header Flit",
	  "EvSel": 86,
	  "ExtSel": "",
     },
     "M3UPI.RxC_FLITS_SLOT_BL.ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Slotting BL Message Into Header Flit",
	  "EvSel": 86,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_FLITS_SLOT_BL.P1_NOT_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Slotting BL Message Into Header Flit",
	  "EvSel": 86,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_FLITS_SLOT_BL.P0_WAIT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Slotting BL Message Into Header Flit",
	  "EvSel": 86,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_FLITS_SLOT_BL.P1_WAIT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Slotting BL Message Into Header Flit",
	  "EvSel": 86,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_FLITS_SLOT_BL.P1_NOT_REQ_BUT_BUBBLE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Slotting BL Message Into Header Flit",
	  "EvSel": 86,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_FLITS_SLOT_BL.NEED_DATA": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Slotting BL Message Into Header Flit",
	  "EvSel": 86,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_FLITS_SLOT_BL.P1_NOT_REQ_NOT_AVAIL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Slotting BL Message Into Header Flit",
	  "EvSel": 86,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_FLIT_GEN_HDR1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Events related to Header Flit Generation - Set 1",
	  "Desc": "Flit Gen - Header 1",
	  "EvSel": 81,
	  "ExtSel": "",
     },
     "M3UPI.RxC_FLIT_GEN_HDR1.ACCUM_WASTED": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Events related to Header Flit Generation - Set 1",
	  "Desc": "Flit Gen - Header 1",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_FLIT_GEN_HDR1.AHEAD_MSG2_SENT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Events related to Header Flit Generation - Set 1",
	  "Desc": "Flit Gen - Header 1",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_FLIT_GEN_HDR1.AHEAD_MSG1_DURING": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Events related to Header Flit Generation - Set 1",
	  "Desc": "Flit Gen - Header 1",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_FLIT_GEN_HDR1.AHEAD_MSG2_AFTER": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Events related to Header Flit Generation - Set 1",
	  "Desc": "Flit Gen - Header 1",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_FLIT_GEN_HDR1.ACCUM": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Events related to Header Flit Generation - Set 1",
	  "Desc": "Flit Gen - Header 1",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_FLIT_GEN_HDR1.ACCUM_READ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Events related to Header Flit Generation - Set 1",
	  "Desc": "Flit Gen - Header 1",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_FLIT_GEN_HDR1.AHEAD_MSG1_AFTER": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Events related to Header Flit Generation - Set 1",
	  "Desc": "Flit Gen - Header 1",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.RxC_FLIT_GEN_HDR1.AHEAD_BLOCKED": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Events related to Header Flit Generation - Set 1",
	  "Desc": "Flit Gen - Header 1",
	  "EvSel": 81,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_FLIT_GEN_HDR2": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Events related to Header Flit Generation - Set 2",
	  "Desc": "Flit Gen - Header 2",
	  "EvSel": 82,
	  "ExtSel": "",
     },
     "M3UPI.RxC_FLIT_GEN_HDR2.PAR": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Events related to Header Flit Generation - Set 2",
	  "Desc": "Flit Gen - Header 2",
	  "EvSel": 82,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_FLIT_GEN_HDR2.PAR_MSG": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Events related to Header Flit Generation - Set 2",
	  "Desc": "Flit Gen - Header 2",
	  "EvSel": 82,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_FLIT_GEN_HDR2.PAR_FLIT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Events related to Header Flit Generation - Set 2",
	  "Desc": "Flit Gen - Header 2",
	  "EvSel": 82,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_FLIT_GEN_HDR2.RMSTALL_NOMSG": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Events related to Header Flit Generation - Set 2",
	  "Desc": "Flit Gen - Header 2",
	  "EvSel": 82,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_FLIT_GEN_HDR2.RMSTALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "Events related to Header Flit Generation - Set 2",
	  "Desc": "Flit Gen - Header 2",
	  "EvSel": 82,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_HDR_FLITS_SENT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Sent Header Flit",
	  "EvSel": 84,
	  "ExtSel": "",
     },
     "M3UPI.RxC_HDR_FLITS_SENT.1_MSG": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Sent Header Flit",
	  "EvSel": 84,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_HDR_FLITS_SENT.2_MSGS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Sent Header Flit",
	  "EvSel": 84,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_HDR_FLITS_SENT.1_MSG_VNX": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Sent Header Flit",
	  "EvSel": 84,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_HDR_FLITS_SENT.SLOTS_3": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Sent Header Flit",
	  "EvSel": 84,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_HDR_FLITS_SENT.SLOTS_2": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Sent Header Flit",
	  "EvSel": 84,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_HDR_FLITS_SENT.3_MSGS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Sent Header Flit",
	  "EvSel": 84,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_HDR_FLITS_SENT.SLOTS_1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Desc": "Sent Header Flit",
	  "EvSel": 84,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_HDR_FLIT_NOT_SENT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "header flit is ready for transmission but could not be sent",
	  "Desc": "Header Not Sent",
	  "EvSel": 83,
	  "ExtSel": "",
     },
     "M3UPI.RxC_HDR_FLIT_NOT_SENT.ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "header flit is ready for transmission but could not be sent",
	  "Desc": "Header Not Sent",
	  "EvSel": 83,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_HDR_FLIT_NOT_SENT.NO_TXQ_NO_MSG": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "header flit is ready for transmission but could not be sent",
	  "Desc": "Header Not Sent",
	  "EvSel": 83,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_HDR_FLIT_NOT_SENT.VALID_FOR_FLIT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "header flit is ready for transmission but could not be sent",
	  "Desc": "Header Not Sent",
	  "EvSel": 83,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_HDR_FLIT_NOT_SENT.NO_BGF_NO_MSG": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "header flit is ready for transmission but could not be sent",
	  "Desc": "Header Not Sent",
	  "EvSel": 83,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_HDR_FLIT_NOT_SENT.NO_BGF_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "header flit is ready for transmission but could not be sent",
	  "Desc": "Header Not Sent",
	  "EvSel": 83,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_HDR_FLIT_NOT_SENT.TSV_HI": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "header flit is ready for transmission but could not be sent",
	  "Desc": "Header Not Sent",
	  "EvSel": 83,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_HDR_FLIT_NOT_SENT.NO_TXQ_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Flit Events",
	  "Defn": "header flit is ready for transmission but could not be sent",
	  "Desc": "Header Not Sent",
	  "EvSel": 83,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_HELD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Desc": "Message Held",
	  "EvSel": 80,
	  "ExtSel": "",
     },
     "M3UPI.RxC_HELD.VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Desc": "Message Held",
	  "EvSel": 80,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_HELD.CANT_SLOT_AD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Desc": "Message Held",
	  "EvSel": 80,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_HELD.VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Desc": "Message Held",
	  "EvSel": 80,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_HELD.PARALLEL_SUCCESS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Desc": "Message Held",
	  "EvSel": 80,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_HELD.PARALLEL_ATTEMPT": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Desc": "Message Held",
	  "EvSel": 80,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_HELD.CANT_SLOT_BL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Desc": "Message Held",
	  "EvSel": 80,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_INSERTS_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Inserts",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
     },
     "M3UPI.RxC_INSERTS_VN0.BL_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Inserts",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_INSERTS_VN0.BL_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Inserts",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_INSERTS_VN0.BL_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Inserts",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_INSERTS_VN0.AD_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Inserts",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_INSERTS_VN0.AD_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Inserts",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_INSERTS_VN0.AD_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Inserts",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_INSERTS_VN0.BL_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Inserts",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_INSERTS_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI VN1  Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI VN1  Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Inserts",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
     },
     "M3UPI.RxC_INSERTS_VN1.BL_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI VN1  Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI VN1  Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Inserts",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_INSERTS_VN1.AD_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI VN1  Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI VN1  Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Inserts",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_INSERTS_VN1.BL_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI VN1  Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI VN1  Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Inserts",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_INSERTS_VN1.BL_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI VN1  Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI VN1  Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Inserts",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_INSERTS_VN1.BL_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI VN1  Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI VN1  Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Inserts",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_INSERTS_VN1.AD_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI VN1  Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI VN1  Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Inserts",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_INSERTS_VN1.AD_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Counts the number of allocations into the UPI VN1  Ingress.  This tracks one of the three rings that are used by the UPI agent.  This can be used in conjunction with the UPI VN1  Ingress Occupancy Accumulator event in order to calculate average queue latency.  Multiple ingress buffers can be tracked at a given time using multiple counters.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Inserts",
	  "EvSel": 66,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_OCCUPANCY_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Accumulates the occupancy of a given UPI VN1  Ingress queue in each cycle.  This tracks one of the three ring Ingress buffers.  This can be used with the UPI VN1  Ingress Not Empty event to calculate average occupancy or the UPI VN1  Ingress Allocations event in order to calculate average queuing latency.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Occupancy",
	  "EvSel": 69,
	  "ExtSel": "",
     },
     "M3UPI.RxC_OCCUPANCY_VN0.AD_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Accumulates the occupancy of a given UPI VN1  Ingress queue in each cycle.  This tracks one of the three ring Ingress buffers.  This can be used with the UPI VN1  Ingress Not Empty event to calculate average occupancy or the UPI VN1  Ingress Allocations event in order to calculate average queuing latency.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Occupancy",
	  "EvSel": 69,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_OCCUPANCY_VN0.BL_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Accumulates the occupancy of a given UPI VN1  Ingress queue in each cycle.  This tracks one of the three ring Ingress buffers.  This can be used with the UPI VN1  Ingress Not Empty event to calculate average occupancy or the UPI VN1  Ingress Allocations event in order to calculate average queuing latency.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Occupancy",
	  "EvSel": 69,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_OCCUPANCY_VN0.BL_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Accumulates the occupancy of a given UPI VN1  Ingress queue in each cycle.  This tracks one of the three ring Ingress buffers.  This can be used with the UPI VN1  Ingress Not Empty event to calculate average occupancy or the UPI VN1  Ingress Allocations event in order to calculate average queuing latency.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Occupancy",
	  "EvSel": 69,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_OCCUPANCY_VN0.BL_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Accumulates the occupancy of a given UPI VN1  Ingress queue in each cycle.  This tracks one of the three ring Ingress buffers.  This can be used with the UPI VN1  Ingress Not Empty event to calculate average occupancy or the UPI VN1  Ingress Allocations event in order to calculate average queuing latency.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Occupancy",
	  "EvSel": 69,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_OCCUPANCY_VN0.BL_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Accumulates the occupancy of a given UPI VN1  Ingress queue in each cycle.  This tracks one of the three ring Ingress buffers.  This can be used with the UPI VN1  Ingress Not Empty event to calculate average occupancy or the UPI VN1  Ingress Allocations event in order to calculate average queuing latency.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Occupancy",
	  "EvSel": 69,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_OCCUPANCY_VN0.AD_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Accumulates the occupancy of a given UPI VN1  Ingress queue in each cycle.  This tracks one of the three ring Ingress buffers.  This can be used with the UPI VN1  Ingress Not Empty event to calculate average occupancy or the UPI VN1  Ingress Allocations event in order to calculate average queuing latency.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Occupancy",
	  "EvSel": 69,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_OCCUPANCY_VN0.AD_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Accumulates the occupancy of a given UPI VN1  Ingress queue in each cycle.  This tracks one of the three ring Ingress buffers.  This can be used with the UPI VN1  Ingress Not Empty event to calculate average occupancy or the UPI VN1  Ingress Allocations event in order to calculate average queuing latency.",
	  "Desc": "VN0 Ingress (from CMS) Queue - Occupancy",
	  "EvSel": 69,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_OCCUPANCY_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Accumulates the occupancy of a given UPI VN1  Ingress queue in each cycle.  This tracks one of the three ring Ingress buffers.  This can be used with the UPI VN1  Ingress Not Empty event to calculate average occupancy or the UPI VN1  Ingress Allocations event in order to calculate average queuing latency.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Occupancy",
	  "EvSel": 70,
	  "ExtSel": "",
     },
     "M3UPI.RxC_OCCUPANCY_VN1.BL_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Accumulates the occupancy of a given UPI VN1  Ingress queue in each cycle.  This tracks one of the three ring Ingress buffers.  This can be used with the UPI VN1  Ingress Not Empty event to calculate average occupancy or the UPI VN1  Ingress Allocations event in order to calculate average queuing latency.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Occupancy",
	  "EvSel": 70,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_OCCUPANCY_VN1.BL_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Accumulates the occupancy of a given UPI VN1  Ingress queue in each cycle.  This tracks one of the three ring Ingress buffers.  This can be used with the UPI VN1  Ingress Not Empty event to calculate average occupancy or the UPI VN1  Ingress Allocations event in order to calculate average queuing latency.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Occupancy",
	  "EvSel": 70,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_OCCUPANCY_VN1.BL_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Accumulates the occupancy of a given UPI VN1  Ingress queue in each cycle.  This tracks one of the three ring Ingress buffers.  This can be used with the UPI VN1  Ingress Not Empty event to calculate average occupancy or the UPI VN1  Ingress Allocations event in order to calculate average queuing latency.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Occupancy",
	  "EvSel": 70,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_OCCUPANCY_VN1.AD_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Accumulates the occupancy of a given UPI VN1  Ingress queue in each cycle.  This tracks one of the three ring Ingress buffers.  This can be used with the UPI VN1  Ingress Not Empty event to calculate average occupancy or the UPI VN1  Ingress Allocations event in order to calculate average queuing latency.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Occupancy",
	  "EvSel": 70,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_OCCUPANCY_VN1.AD_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Accumulates the occupancy of a given UPI VN1  Ingress queue in each cycle.  This tracks one of the three ring Ingress buffers.  This can be used with the UPI VN1  Ingress Not Empty event to calculate average occupancy or the UPI VN1  Ingress Allocations event in order to calculate average queuing latency.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Occupancy",
	  "EvSel": 70,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_OCCUPANCY_VN1.BL_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Accumulates the occupancy of a given UPI VN1  Ingress queue in each cycle.  This tracks one of the three ring Ingress buffers.  This can be used with the UPI VN1  Ingress Not Empty event to calculate average occupancy or the UPI VN1  Ingress Allocations event in order to calculate average queuing latency.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Occupancy",
	  "EvSel": 70,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_OCCUPANCY_VN1.AD_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Events",
	  "Defn": "Accumulates the occupancy of a given UPI VN1  Ingress queue in each cycle.  This tracks one of the three ring Ingress buffers.  This can be used with the UPI VN1  Ingress Not Empty event to calculate average occupancy or the UPI VN1  Ingress Allocations event in order to calculate average queuing latency.",
	  "Desc": "VN1 Ingress (from CMS) Queue - Occupancy",
	  "EvSel": 70,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_PACKING_MISS_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Defn": "Count cases where Ingress has packets to send but did not have time to pack into flit before sending to Agent so slot was left NULL which could have been used.",
	  "Desc": "VN0 message can't slot into flit",
	  "EvSel": 78,
	  "ExtSel": "",
     },
     "M3UPI.RxC_PACKING_MISS_VN0.AD_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Defn": "Count cases where Ingress has packets to send but did not have time to pack into flit before sending to Agent so slot was left NULL which could have been used.",
	  "Desc": "VN0 message can't slot into flit",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_PACKING_MISS_VN0.BL_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Defn": "Count cases where Ingress has packets to send but did not have time to pack into flit before sending to Agent so slot was left NULL which could have been used.",
	  "Desc": "VN0 message can't slot into flit",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_PACKING_MISS_VN0.AD_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Defn": "Count cases where Ingress has packets to send but did not have time to pack into flit before sending to Agent so slot was left NULL which could have been used.",
	  "Desc": "VN0 message can't slot into flit",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_PACKING_MISS_VN0.AD_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Defn": "Count cases where Ingress has packets to send but did not have time to pack into flit before sending to Agent so slot was left NULL which could have been used.",
	  "Desc": "VN0 message can't slot into flit",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_PACKING_MISS_VN0.BL_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Defn": "Count cases where Ingress has packets to send but did not have time to pack into flit before sending to Agent so slot was left NULL which could have been used.",
	  "Desc": "VN0 message can't slot into flit",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_PACKING_MISS_VN0.BL_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Defn": "Count cases where Ingress has packets to send but did not have time to pack into flit before sending to Agent so slot was left NULL which could have been used.",
	  "Desc": "VN0 message can't slot into flit",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_PACKING_MISS_VN0.BL_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Defn": "Count cases where Ingress has packets to send but did not have time to pack into flit before sending to Agent so slot was left NULL which could have been used.",
	  "Desc": "VN0 message can't slot into flit",
	  "EvSel": 78,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_PACKING_MISS_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Defn": "Count cases where Ingress has packets to send but did not have time to pack into flit before sending to Agent so slot was left NULL which could have been used.",
	  "Desc": "VN1 message can't slot into flit",
	  "EvSel": 79,
	  "ExtSel": "",
     },
     "M3UPI.RxC_PACKING_MISS_VN1.BL_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Defn": "Count cases where Ingress has packets to send but did not have time to pack into flit before sending to Agent so slot was left NULL which could have been used.",
	  "Desc": "VN1 message can't slot into flit",
	  "EvSel": 79,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_PACKING_MISS_VN1.BL_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Defn": "Count cases where Ingress has packets to send but did not have time to pack into flit before sending to Agent so slot was left NULL which could have been used.",
	  "Desc": "VN1 message can't slot into flit",
	  "EvSel": 79,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_PACKING_MISS_VN1.BL_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Defn": "Count cases where Ingress has packets to send but did not have time to pack into flit before sending to Agent so slot was left NULL which could have been used.",
	  "Desc": "VN1 message can't slot into flit",
	  "EvSel": 79,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_PACKING_MISS_VN1.AD_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Defn": "Count cases where Ingress has packets to send but did not have time to pack into flit before sending to Agent so slot was left NULL which could have been used.",
	  "Desc": "VN1 message can't slot into flit",
	  "EvSel": 79,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_PACKING_MISS_VN1.AD_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Defn": "Count cases where Ingress has packets to send but did not have time to pack into flit before sending to Agent so slot was left NULL which could have been used.",
	  "Desc": "VN1 message can't slot into flit",
	  "EvSel": 79,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_PACKING_MISS_VN1.AD_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Defn": "Count cases where Ingress has packets to send but did not have time to pack into flit before sending to Agent so slot was left NULL which could have been used.",
	  "Desc": "VN1 message can't slot into flit",
	  "EvSel": 79,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_PACKING_MISS_VN1.BL_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Sloting Events",
	  "Counters": "0-2",
	  "Defn": "Count cases where Ingress has packets to send but did not have time to pack into flit before sending to Agent so slot was left NULL which could have been used.",
	  "Desc": "VN1 message can't slot into flit",
	  "EvSel": 79,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_VNA_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Remote VNA Credits",
	  "EvSel": 90,
	  "ExtSel": "",
     },
     "M3UPI.RxC_VNA_CRD.LT10": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Remote VNA Credits",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_VNA_CRD.ANY_IN_USE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Remote VNA Credits",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_VNA_CRD.CORRECTED": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Remote VNA Credits",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_VNA_CRD.LT1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Remote VNA Credits",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_VNA_CRD.LT5": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Remote VNA Credits",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_VNA_CRD.LT4": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "Desc": "Remote VNA Credits",
	  "EvSel": 90,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxC_VNA_CRD_MISC": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "EvSel": 89,
	  "ExtSel": "",
     },
     "M3UPI.RxC_VNA_CRD_MISC.VN0_JUST_AD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "EvSel": 89,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.RxC_VNA_CRD_MISC.VN1_JUST_AD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "EvSel": 89,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.RxC_VNA_CRD_MISC.VN1_JUST_BL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "EvSel": 89,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.RxC_VNA_CRD_MISC.VN0_JUST_BL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "EvSel": 89,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.RxC_VNA_CRD_MISC.VN1_ONLY": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "EvSel": 89,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.RxC_VNA_CRD_MISC.REQ_VN01_ALLOC_LT10": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "EvSel": 89,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.RxC_VNA_CRD_MISC.REQ_ADBL_ALLOC_L5": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "EvSel": 89,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.RxC_VNA_CRD_MISC.VN0_ONLY": {
	  "Box": "M3UPI",
	  "Category": "M3UPI INGRESS Credit Events",
	  "EvSel": 89,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.RxR_BUSY_STARVED": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
     },
     "M3UPI.RxR_BUSY_STARVED.BL_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "M3UPI.RxR_BUSY_STARVED.BL_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000000",
     },
     "M3UPI.RxR_BUSY_STARVED.AD_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "M3UPI.RxR_BUSY_STARVED.BL_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "M3UPI.RxR_BUSY_STARVED.AD_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "M3UPI.RxR_BUSY_STARVED.AD_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, because a message from the other queue has higher priority",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 229,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "M3UPI.RxR_BYPASS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
     },
     "M3UPI.RxR_BYPASS.AD_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "M3UPI.RxR_BYPASS.IV": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00001000",
     },
     "M3UPI.RxR_BYPASS.AKC_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b10000000",
     },
     "M3UPI.RxR_BYPASS.BL_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "M3UPI.RxR_BYPASS.BL_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "M3UPI.RxR_BYPASS.AD_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "M3UPI.RxR_BYPASS.BL_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000000",
     },
     "M3UPI.RxR_BYPASS.AK": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000010",
     },
     "M3UPI.RxR_BYPASS.AD_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of packets bypassing the CMS Ingress",
	  "Desc": "Transgress Ingress Bypass",
	  "EvSel": 226,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "M3UPI.RxR_CRD_STARVED": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
     },
     "M3UPI.RxR_CRD_STARVED.IFV": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b10000000",
     },
     "M3UPI.RxR_CRD_STARVED.AK": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00000010",
     },
     "M3UPI.RxR_CRD_STARVED.AD_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "M3UPI.RxR_CRD_STARVED.BL_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b01000000",
     },
     "M3UPI.RxR_CRD_STARVED.AD_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "M3UPI.RxR_CRD_STARVED.BL_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "M3UPI.RxR_CRD_STARVED.BL_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "M3UPI.RxR_CRD_STARVED.IV": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00001000",
     },
     "M3UPI.RxR_CRD_STARVED.AD_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 227,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "M3UPI.RxR_CRD_STARVED_1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Counts cycles under injection starvation mode.  This starvation is triggered when the CMS Ingress cannot send a transaction onto the mesh for a long period of time.  In this case, the Ingress is unable to forward to the Egress due to a lack of credit.",
	  "Desc": "Transgress Injection Starvation",
	  "EvSel": 228,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the OR of the two. For this purpose IFV is considered an AK ring type. Selecting multiple ring types NOT supported",
     },
     "M3UPI.RxR_INSERTS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
     },
     "M3UPI.RxR_INSERTS.AD_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "M3UPI.RxR_INSERTS.AK": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000010",
     },
     "M3UPI.RxR_INSERTS.BL_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000000",
     },
     "M3UPI.RxR_INSERTS.AD_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "M3UPI.RxR_INSERTS.BL_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "M3UPI.RxR_INSERTS.IV": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00001000",
     },
     "M3UPI.RxR_INSERTS.AKC_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b10000000",
     },
     "M3UPI.RxR_INSERTS.BL_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "M3UPI.RxR_INSERTS.AD_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Number of allocations into the CMS Ingress  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Allocations",
	  "EvSel": 225,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "M3UPI.RxR_OCCUPANCY": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
     },
     "M3UPI.RxR_OCCUPANCY.BL_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000100",
     },
     "M3UPI.RxR_OCCUPANCY.AKC_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b10000000",
     },
     "M3UPI.RxR_OCCUPANCY.IV": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00001000",
     },
     "M3UPI.RxR_OCCUPANCY.AD_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000001",
     },
     "M3UPI.RxR_OCCUPANCY.AK": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00000010",
     },
     "M3UPI.RxR_OCCUPANCY.AD_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010001",
     },
     "M3UPI.RxR_OCCUPANCY.BL_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00100000",
     },
     "M3UPI.RxR_OCCUPANCY.AD_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b00010000",
     },
     "M3UPI.RxR_OCCUPANCY.BL_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress INGRESS Events",
	  "Defn": "Occupancy event for the Ingress buffers in the CMS  The Ingress is used to queue up requests received from the mesh",
	  "Desc": "Transgress Ingress Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "If both masks are selected for one ring type (ex: AD CRD + BNC), will count the SUM of the two.  Selecting multiple ring types NOT supported",
	  "Umask": "b01000100",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR4": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR5": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR6": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR7": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR3": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG0.TGR2": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 208,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR2": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR7": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR3": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR6": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR4": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_AD_AG1.TGR5": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR6": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR7": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR3": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR5": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR4": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR2": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG0.TGR1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR2": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR7": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR3": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR6": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR5": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.STALL0_NO_TxR_HORZ_CRD_BL_AG1.TGR4": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.STALL1_NO_TxR_HORZ_CRD_AD_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 209,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M3UPI.STALL1_NO_TxR_HORZ_CRD_AD_AG0.TGR8": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 209,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.STALL1_NO_TxR_HORZ_CRD_AD_AG0.TGR9": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 209,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.STALL1_NO_TxR_HORZ_CRD_AD_AG0.TGR10": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent0 Transgress Credits",
	  "EvSel": 209,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.STALL1_NO_TxR_HORZ_CRD_AD_AG1_1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M3UPI.STALL1_NO_TxR_HORZ_CRD_AD_AG1_1.TGR8": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.STALL1_NO_TxR_HORZ_CRD_AD_AG1_1.TGR10": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.STALL1_NO_TxR_HORZ_CRD_AD_AG1_1.TGR9": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the AD Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No AD Agent1 Transgress Credits",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.STALL1_NO_TxR_HORZ_CRD_BL_AG0_1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 213,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M3UPI.STALL1_NO_TxR_HORZ_CRD_BL_AG0_1.TGR9": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 213,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.STALL1_NO_TxR_HORZ_CRD_BL_AG0_1.TGR10": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 213,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.STALL1_NO_TxR_HORZ_CRD_BL_AG0_1.TGR8": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 0 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent0 Transgress Credits",
	  "EvSel": 213,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.STALL1_NO_TxR_HORZ_CRD_BL_AG1_1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
     },
     "M3UPI.STALL1_NO_TxR_HORZ_CRD_BL_AG1_1.TGR8": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.STALL1_NO_TxR_HORZ_CRD_BL_AG1_1.TGR9": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.STALL1_NO_TxR_HORZ_CRD_BL_AG1_1.TGR10": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Transgress Credit Events",
	  "Defn": "Number of cycles the BL Agent 1 Egress Buffer is stalled waiting for a TGR credit to become available, per transgress.",
	  "Desc": "Stall on No BL Agent1 Transgress Credits",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Notes": "Extension not used by ICX.",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxC_AD_ARB_FAIL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "AD arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for AD",
	  "EvSel": 48,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
     },
     "M3UPI.TxC_AD_ARB_FAIL.VN1_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "AD arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for AD",
	  "EvSel": 48,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.TxC_AD_ARB_FAIL.VN0_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "AD arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for AD",
	  "EvSel": 48,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.TxC_AD_ARB_FAIL.VN1_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "AD arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for AD",
	  "EvSel": 48,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.TxC_AD_ARB_FAIL.VN0_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "AD arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for AD",
	  "EvSel": 48,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxC_AD_ARB_FAIL.VN0_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "AD arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for AD",
	  "EvSel": 48,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxC_AD_ARB_FAIL.VN1_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "AD arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for AD",
	  "EvSel": 48,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.TxC_AD_ARB_FAIL.VN0_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "AD arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for AD",
	  "EvSel": 48,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxC_AD_ARB_FAIL.VN1_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "AD arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for AD",
	  "EvSel": 48,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.TxC_AD_FLQ_BYPASS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Special Egress Events",
	  "Counters": "0-3",
	  "Defn": "Counts cases when the AD flowQ is bypassed (S0, S1 and S2 indicate which slot was bypassed with S0 having the highest priority and S2 the least)",
	  "Desc": "AD FlowQ Bypass",
	  "EvSel": 44,
	  "ExtSel": "",
     },
     "M3UPI.TxC_AD_FLQ_BYPASS.AD_SLOT0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Special Egress Events",
	  "Counters": "0-3",
	  "Defn": "Counts cases when the AD flowQ is bypassed (S0, S1 and S2 indicate which slot was bypassed with S0 having the highest priority and S2 the least)",
	  "Desc": "AD FlowQ Bypass",
	  "EvSel": 44,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxC_AD_FLQ_BYPASS.BL_EARLY_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Special Egress Events",
	  "Counters": "0-3",
	  "Defn": "Counts cases when the AD flowQ is bypassed (S0, S1 and S2 indicate which slot was bypassed with S0 having the highest priority and S2 the least)",
	  "Desc": "AD FlowQ Bypass",
	  "EvSel": 44,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.TxC_AD_FLQ_BYPASS.AD_SLOT1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Special Egress Events",
	  "Counters": "0-3",
	  "Defn": "Counts cases when the AD flowQ is bypassed (S0, S1 and S2 indicate which slot was bypassed with S0 having the highest priority and S2 the least)",
	  "Desc": "AD FlowQ Bypass",
	  "EvSel": 44,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxC_AD_FLQ_BYPASS.AD_SLOT2": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Special Egress Events",
	  "Counters": "0-3",
	  "Defn": "Counts cases when the AD flowQ is bypassed (S0, S1 and S2 indicate which slot was bypassed with S0 having the highest priority and S2 the least)",
	  "Desc": "AD FlowQ Bypass",
	  "EvSel": 44,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxC_AD_FLQ_CYCLES_NE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the AD Egress queue is Not Empty",
	  "Desc": "AD Flow Q Not Empty",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
     },
     "M3UPI.TxC_AD_FLQ_CYCLES_NE.VN1_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the AD Egress queue is Not Empty",
	  "Desc": "AD Flow Q Not Empty",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.TxC_AD_FLQ_CYCLES_NE.VN0_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the AD Egress queue is Not Empty",
	  "Desc": "AD Flow Q Not Empty",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxC_AD_FLQ_CYCLES_NE.VN1_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the AD Egress queue is Not Empty",
	  "Desc": "AD Flow Q Not Empty",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.TxC_AD_FLQ_CYCLES_NE.VN0_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the AD Egress queue is Not Empty",
	  "Desc": "AD Flow Q Not Empty",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxC_AD_FLQ_CYCLES_NE.VN0_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the AD Egress queue is Not Empty",
	  "Desc": "AD Flow Q Not Empty",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxC_AD_FLQ_CYCLES_NE.VN1_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the AD Egress queue is Not Empty",
	  "Desc": "AD Flow Q Not Empty",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.TxC_AD_FLQ_CYCLES_NE.VN0_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the AD Egress queue is Not Empty",
	  "Desc": "AD Flow Q Not Empty",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.TxC_AD_FLQ_CYCLES_NE.VN1_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the AD Egress queue is Not Empty",
	  "Desc": "AD Flow Q Not Empty",
	  "EvSel": 39,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.TxC_AD_FLQ_INSERTS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the QPI FlowQ. This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue latency.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Desc": "AD Flow Q Inserts",
	  "EvSel": 45,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
     },
     "M3UPI.TxC_AD_FLQ_INSERTS.VN0_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the QPI FlowQ. This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue latency.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Desc": "AD Flow Q Inserts",
	  "EvSel": 45,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.TxC_AD_FLQ_INSERTS.VN1_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the QPI FlowQ. This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue latency.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Desc": "AD Flow Q Inserts",
	  "EvSel": 45,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.TxC_AD_FLQ_INSERTS.VN1_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the QPI FlowQ. This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue latency.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Desc": "AD Flow Q Inserts",
	  "EvSel": 45,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.TxC_AD_FLQ_INSERTS.VN0_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the QPI FlowQ. This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue latency.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Desc": "AD Flow Q Inserts",
	  "EvSel": 45,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxC_AD_FLQ_INSERTS.VN0_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the QPI FlowQ. This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue latency.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Desc": "AD Flow Q Inserts",
	  "EvSel": 45,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxC_AD_FLQ_INSERTS.VN0_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the QPI FlowQ. This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue latency.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Desc": "AD Flow Q Inserts",
	  "EvSel": 45,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxC_AD_FLQ_INSERTS.VN1_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the QPI FlowQ. This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue latency.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Desc": "AD Flow Q Inserts",
	  "EvSel": 45,
	  "ExtSel": "",
	  "MaxIncCyc": 3,
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.TxC_AD_FLQ_OCCUPANCY": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "AD Flow Q Occupancy",
	  "EvSel": 28,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
     },
     "M3UPI.TxC_AD_FLQ_OCCUPANCY.VN1_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "AD Flow Q Occupancy",
	  "EvSel": 28,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.TxC_AD_FLQ_OCCUPANCY.VN0_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "AD Flow Q Occupancy",
	  "EvSel": 28,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.TxC_AD_FLQ_OCCUPANCY.VN1_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "AD Flow Q Occupancy",
	  "EvSel": 28,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.TxC_AD_FLQ_OCCUPANCY.VN0_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "AD Flow Q Occupancy",
	  "EvSel": 28,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxC_AD_FLQ_OCCUPANCY.VN0_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "AD Flow Q Occupancy",
	  "EvSel": 28,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxC_AD_FLQ_OCCUPANCY.VN0_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "AD Flow Q Occupancy",
	  "EvSel": 28,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxC_AD_FLQ_OCCUPANCY.VN1_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "AD Flow Q Occupancy",
	  "EvSel": 28,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.TxC_AK_FLQ_INSERTS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Desc": "AK Flow Q Inserts",
	  "EvSel": 47,
	  "ExtSel": "",
	  "MaxIncCyc": 2,
     },
     "M3UPI.TxC_AK_FLQ_OCCUPANCY": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "AK Flow Q Occupancy",
	  "EvSel": 30,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
     },
     "M3UPI.TxC_BL_ARB_FAIL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "BL arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for BL",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
     },
     "M3UPI.TxC_BL_ARB_FAIL.VN0_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "BL arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for BL",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxC_BL_ARB_FAIL.VN1_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "BL arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for BL",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.TxC_BL_ARB_FAIL.VN0_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "BL arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for BL",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxC_BL_ARB_FAIL.VN0_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "BL arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for BL",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxC_BL_ARB_FAIL.VN0_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "BL arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for BL",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.TxC_BL_ARB_FAIL.VN1_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "BL arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for BL",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.TxC_BL_ARB_FAIL.VN1_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "BL arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for BL",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.TxC_BL_ARB_FAIL.VN1_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI ARB Events",
	  "Defn": "BL arb but no win; arb request asserted but not won",
	  "Desc": "Failed ARB for BL",
	  "EvSel": 53,
	  "ExtSel": "",
	  "Notes": "subevents added to 5b?",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.TxC_BL_FLQ_CYCLES_NE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the BL Egress queue is Not Empty",
	  "Desc": "BL Flow Q Not Empty",
	  "EvSel": 40,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
     },
     "M3UPI.TxC_BL_FLQ_CYCLES_NE.VN0_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the BL Egress queue is Not Empty",
	  "Desc": "BL Flow Q Not Empty",
	  "EvSel": 40,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxC_BL_FLQ_CYCLES_NE.VN1_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the BL Egress queue is Not Empty",
	  "Desc": "BL Flow Q Not Empty",
	  "EvSel": 40,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.TxC_BL_FLQ_CYCLES_NE.VN0_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the BL Egress queue is Not Empty",
	  "Desc": "BL Flow Q Not Empty",
	  "EvSel": 40,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxC_BL_FLQ_CYCLES_NE.VN1_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the BL Egress queue is Not Empty",
	  "Desc": "BL Flow Q Not Empty",
	  "EvSel": 40,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.TxC_BL_FLQ_CYCLES_NE.VN1_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the BL Egress queue is Not Empty",
	  "Desc": "BL Flow Q Not Empty",
	  "EvSel": 40,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.TxC_BL_FLQ_CYCLES_NE.VN0_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the BL Egress queue is Not Empty",
	  "Desc": "BL Flow Q Not Empty",
	  "EvSel": 40,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.TxC_BL_FLQ_CYCLES_NE.VN1_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the BL Egress queue is Not Empty",
	  "Desc": "BL Flow Q Not Empty",
	  "EvSel": 40,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.TxC_BL_FLQ_CYCLES_NE.VN0_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles the BL Egress queue is Not Empty",
	  "Desc": "BL Flow Q Not Empty",
	  "EvSel": 40,
	  "ExtSel": "",
	  "Notes": "Counts the number of cycles when the QPI FlowQ is not empty.  This tracks one of the three rings that are used by the QPI agent.  This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue occupancy.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxC_BL_FLQ_INSERTS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the QPI FlowQ. This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue latency.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Desc": "BL Flow Q Inserts",
	  "EvSel": 46,
	  "ExtSel": "",
     },
     "M3UPI.TxC_BL_FLQ_INSERTS.VN0_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the QPI FlowQ. This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue latency.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Desc": "BL Flow Q Inserts",
	  "EvSel": 46,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.TxC_BL_FLQ_INSERTS.VN0_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the QPI FlowQ. This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue latency.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Desc": "BL Flow Q Inserts",
	  "EvSel": 46,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxC_BL_FLQ_INSERTS.VN1_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the QPI FlowQ. This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue latency.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Desc": "BL Flow Q Inserts",
	  "EvSel": 46,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.TxC_BL_FLQ_INSERTS.VN0_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the QPI FlowQ. This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue latency.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Desc": "BL Flow Q Inserts",
	  "EvSel": 46,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxC_BL_FLQ_INSERTS.VN1_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the QPI FlowQ. This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue latency.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Desc": "BL Flow Q Inserts",
	  "EvSel": 46,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.TxC_BL_FLQ_INSERTS.VN1_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the QPI FlowQ. This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue latency.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Desc": "BL Flow Q Inserts",
	  "EvSel": 46,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.TxC_BL_FLQ_INSERTS.VN1_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the QPI FlowQ. This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue latency.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Desc": "BL Flow Q Inserts",
	  "EvSel": 46,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.TxC_BL_FLQ_INSERTS.VN0_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the QPI FlowQ. This can be used in conjunction with the QPI FlowQ Occupancy Accumulator event in order to calculate average queue latency.  Only a single FlowQ queue can be tracked at any given time.  It is not possible to filter based on direction or polarity.",
	  "Desc": "BL Flow Q Inserts",
	  "EvSel": 46,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxC_BL_FLQ_OCCUPANCY": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "BL Flow Q Occupancy",
	  "EvSel": 29,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
     },
     "M3UPI.TxC_BL_FLQ_OCCUPANCY.VN1_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "BL Flow Q Occupancy",
	  "EvSel": 29,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.TxC_BL_FLQ_OCCUPANCY.VN0_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "BL Flow Q Occupancy",
	  "EvSel": 29,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.TxC_BL_FLQ_OCCUPANCY.VN1_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "BL Flow Q Occupancy",
	  "EvSel": 29,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.TxC_BL_FLQ_OCCUPANCY.VN1_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "BL Flow Q Occupancy",
	  "EvSel": 29,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.TxC_BL_FLQ_OCCUPANCY.VN0_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "BL Flow Q Occupancy",
	  "EvSel": 29,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxC_BL_FLQ_OCCUPANCY.VN1_NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "BL Flow Q Occupancy",
	  "EvSel": 29,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.TxC_BL_FLQ_OCCUPANCY.VN0_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "BL Flow Q Occupancy",
	  "EvSel": 29,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxC_BL_FLQ_OCCUPANCY.VN0_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "BL Flow Q Occupancy",
	  "EvSel": 29,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxC_BL_WB_FLQ_OCCUPANCY": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "BL Flow Q Occupancy",
	  "EvSel": 31,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
     },
     "M3UPI.TxC_BL_WB_FLQ_OCCUPANCY.VN1_THROUGH": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "BL Flow Q Occupancy",
	  "EvSel": 31,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "b00100000",
     },
     "M3UPI.TxC_BL_WB_FLQ_OCCUPANCY.VN0_THROUGH": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "BL Flow Q Occupancy",
	  "EvSel": 31,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "b00000010",
     },
     "M3UPI.TxC_BL_WB_FLQ_OCCUPANCY.VN0_LOCAL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "BL Flow Q Occupancy",
	  "EvSel": 31,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "b00000001",
     },
     "M3UPI.TxC_BL_WB_FLQ_OCCUPANCY.VN1_LOCAL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "BL Flow Q Occupancy",
	  "EvSel": 31,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "b00010000",
     },
     "M3UPI.TxC_BL_WB_FLQ_OCCUPANCY.VN0_WRPULL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "BL Flow Q Occupancy",
	  "EvSel": 31,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "b00000100",
     },
     "M3UPI.TxC_BL_WB_FLQ_OCCUPANCY.VN1_WRPULL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI FlowQ Events",
	  "Counters": 0,
	  "Desc": "BL Flow Q Occupancy",
	  "EvSel": 31,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "b01000000",
     },
     "M3UPI.TxR_HORZ_ADS_USED": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
     },
     "M3UPI.TxR_HORZ_ADS_USED.BL_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M3UPI.TxR_HORZ_ADS_USED.AD_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M3UPI.TxR_HORZ_ADS_USED.AD_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M3UPI.TxR_HORZ_ADS_USED.BL_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M3UPI.TxR_HORZ_ADS_USED.BL_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M3UPI.TxR_HORZ_ADS_USED.AD_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets using the Horizontal Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal ADS Used",
	  "EvSel": 166,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M3UPI.TxR_HORZ_BYPASS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
     },
     "M3UPI.TxR_HORZ_BYPASS.AD_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M3UPI.TxR_HORZ_BYPASS.BL_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M3UPI.TxR_HORZ_BYPASS.AK": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M3UPI.TxR_HORZ_BYPASS.AD_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M3UPI.TxR_HORZ_BYPASS.BL_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M3UPI.TxR_HORZ_BYPASS.AD_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M3UPI.TxR_HORZ_BYPASS.AKC_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M3UPI.TxR_HORZ_BYPASS.BL_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M3UPI.TxR_HORZ_BYPASS.IV": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of packets bypassing the Horizontal Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Horizontal Bypass Used",
	  "EvSel": 167,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M3UPI.TxR_HORZ_CYCLES_FULL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
     },
     "M3UPI.TxR_HORZ_CYCLES_FULL.BL_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M3UPI.TxR_HORZ_CYCLES_FULL.AD_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M3UPI.TxR_HORZ_CYCLES_FULL.BL_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M3UPI.TxR_HORZ_CYCLES_FULL.AD_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M3UPI.TxR_HORZ_CYCLES_FULL.AK": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M3UPI.TxR_HORZ_CYCLES_FULL.AD_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M3UPI.TxR_HORZ_CYCLES_FULL.BL_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M3UPI.TxR_HORZ_CYCLES_FULL.AKC_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M3UPI.TxR_HORZ_CYCLES_FULL.IV": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Full.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Full",
	  "EvSel": 162,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M3UPI.TxR_HORZ_CYCLES_NE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
     },
     "M3UPI.TxR_HORZ_CYCLES_NE.AK": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M3UPI.TxR_HORZ_CYCLES_NE.AD_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M3UPI.TxR_HORZ_CYCLES_NE.BL_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M3UPI.TxR_HORZ_CYCLES_NE.AD_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M3UPI.TxR_HORZ_CYCLES_NE.BL_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M3UPI.TxR_HORZ_CYCLES_NE.IV": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M3UPI.TxR_HORZ_CYCLES_NE.AKC_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M3UPI.TxR_HORZ_CYCLES_NE.BL_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M3UPI.TxR_HORZ_CYCLES_NE.AD_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Cycles the Transgress buffers in the Common Mesh Stop are Not-Empty.  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "Cycles CMS Horizontal Egress Queue is Not Empty",
	  "EvSel": 163,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M3UPI.TxR_HORZ_INSERTS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
     },
     "M3UPI.TxR_HORZ_INSERTS.BL_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M3UPI.TxR_HORZ_INSERTS.AD_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M3UPI.TxR_HORZ_INSERTS.BL_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M3UPI.TxR_HORZ_INSERTS.AK": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M3UPI.TxR_HORZ_INSERTS.AD_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M3UPI.TxR_HORZ_INSERTS.AD_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M3UPI.TxR_HORZ_INSERTS.AKC_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M3UPI.TxR_HORZ_INSERTS.IV": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M3UPI.TxR_HORZ_INSERTS.BL_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Number of allocations into the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Inserts",
	  "EvSel": 161,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M3UPI.TxR_HORZ_NACK": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
     },
     "M3UPI.TxR_HORZ_NACK.AD_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M3UPI.TxR_HORZ_NACK.BL_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M3UPI.TxR_HORZ_NACK.AKC_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M3UPI.TxR_HORZ_NACK.IV": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M3UPI.TxR_HORZ_NACK.BL_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M3UPI.TxR_HORZ_NACK.AD_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M3UPI.TxR_HORZ_NACK.BL_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M3UPI.TxR_HORZ_NACK.AK": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M3UPI.TxR_HORZ_NACK.AD_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Horizontal Ring",
	  "Desc": "CMS Horizontal Egress NACKs",
	  "EvSel": 164,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M3UPI.TxR_HORZ_OCCUPANCY": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
     },
     "M3UPI.TxR_HORZ_OCCUPANCY.BL_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b01000100",
     },
     "M3UPI.TxR_HORZ_OCCUPANCY.AD_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00010000",
     },
     "M3UPI.TxR_HORZ_OCCUPANCY.BL_CRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b01000000",
     },
     "M3UPI.TxR_HORZ_OCCUPANCY.AD_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00010001",
     },
     "M3UPI.TxR_HORZ_OCCUPANCY.AK": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M3UPI.TxR_HORZ_OCCUPANCY.AD_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M3UPI.TxR_HORZ_OCCUPANCY.IV": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M3UPI.TxR_HORZ_OCCUPANCY.AKC_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M3UPI.TxR_HORZ_OCCUPANCY.BL_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Occupancy event for the Transgress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Horizontal Ring on the Mesh.",
	  "Desc": "CMS Horizontal Egress Occupancy",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M3UPI.TxR_HORZ_STARVED": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
     },
     "M3UPI.TxR_HORZ_STARVED.IV": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00001000",
     },
     "M3UPI.TxR_HORZ_STARVED.AKC_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b10000000",
     },
     "M3UPI.TxR_HORZ_STARVED.BL_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M3UPI.TxR_HORZ_STARVED.AD_UNCRD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M3UPI.TxR_HORZ_STARVED.AD_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000001",
     },
     "M3UPI.TxR_HORZ_STARVED.AK": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000010",
     },
     "M3UPI.TxR_HORZ_STARVED.BL_ALL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Horizontal EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Transgress buffer cannot send a transaction onto the Horizontal ring for a long period of time.",
	  "Desc": "CMS Horizontal Egress Injection Starvation",
	  "EvSel": 165,
	  "ExtSel": "",
	  "Umask": "b00000100",
     },
     "M3UPI.TxR_VERT_ADS_USED": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
     },
     "M3UPI.TxR_VERT_ADS_USED.AD_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.TxR_VERT_ADS_USED.BL_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxR_VERT_ADS_USED.AD_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxR_VERT_ADS_USED.BL_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of packets using the Vertical Anti-Deadlock Slot, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 156,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.TxR_VERT_BYPASS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
     },
     "M3UPI.TxR_VERT_BYPASS.IV_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.TxR_VERT_BYPASS.BL_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.TxR_VERT_BYPASS.AK_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxR_VERT_BYPASS.AD_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.TxR_VERT_BYPASS.AK_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.TxR_VERT_BYPASS.AD_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxR_VERT_BYPASS.BL_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 157,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxR_VERT_BYPASS_1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 158,
	  "ExtSel": "",
     },
     "M3UPI.TxR_VERT_BYPASS_1.AKC_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 158,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxR_VERT_BYPASS_1.AKC_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of packets bypassing the Vertical Egress, broken down by ring type and CMS Agent.",
	  "Desc": "CMS Vertical ADS Used",
	  "EvSel": 158,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxR_VERT_CYCLES_FULL0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
     },
     "M3UPI.TxR_VERT_CYCLES_FULL0.BL_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.TxR_VERT_CYCLES_FULL0.AD_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.TxR_VERT_CYCLES_FULL0.AK_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxR_VERT_CYCLES_FULL0.AD_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxR_VERT_CYCLES_FULL0.AK_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.TxR_VERT_CYCLES_FULL0.BL_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxR_VERT_CYCLES_FULL0.IV_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 148,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.TxR_VERT_CYCLES_FULL1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 149,
	  "ExtSel": "",
     },
     "M3UPI.TxR_VERT_CYCLES_FULL1.AKC_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 149,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxR_VERT_CYCLES_FULL1.AKC_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Full.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Full",
	  "EvSel": 149,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxR_VERT_CYCLES_NE0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
     },
     "M3UPI.TxR_VERT_CYCLES_NE0.IV_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.TxR_VERT_CYCLES_NE0.BL_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxR_VERT_CYCLES_NE0.AK_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.TxR_VERT_CYCLES_NE0.AD_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxR_VERT_CYCLES_NE0.AD_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.TxR_VERT_CYCLES_NE0.AK_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxR_VERT_CYCLES_NE0.BL_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 150,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.TxR_VERT_CYCLES_NE1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 151,
	  "ExtSel": "",
     },
     "M3UPI.TxR_VERT_CYCLES_NE1.AKC_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 151,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxR_VERT_CYCLES_NE1.AKC_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of cycles the Common Mesh Stop Egress was Not Empty.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "Cycles CMS Vertical Egress Queue Is Not Empty",
	  "EvSel": 151,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxR_VERT_INSERTS0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
     },
     "M3UPI.TxR_VERT_INSERTS0.AD_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxR_VERT_INSERTS0.AK_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.TxR_VERT_INSERTS0.IV_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.TxR_VERT_INSERTS0.BL_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxR_VERT_INSERTS0.BL_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.TxR_VERT_INSERTS0.AK_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxR_VERT_INSERTS0.AD_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.TxR_VERT_INSERTS1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 147,
	  "ExtSel": "",
     },
     "M3UPI.TxR_VERT_INSERTS1.AKC_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 147,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxR_VERT_INSERTS1.AKC_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Number of allocations into the Common Mesh Stop Egress.  The Egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Allocations",
	  "EvSel": 147,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxR_VERT_NACK0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
     },
     "M3UPI.TxR_VERT_NACK0.AD_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.TxR_VERT_NACK0.AK_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxR_VERT_NACK0.BL_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.TxR_VERT_NACK0.IV_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.TxR_VERT_NACK0.BL_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxR_VERT_NACK0.AK_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.TxR_VERT_NACK0.AD_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 152,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxR_VERT_NACK1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 153,
	  "ExtSel": "",
     },
     "M3UPI.TxR_VERT_NACK1.AKC_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 153,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxR_VERT_NACK1.AKC_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts number of Egress packets NACK'ed on to the Vertical Ring",
	  "Desc": "CMS Vertical Egress NACKs",
	  "EvSel": 153,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxR_VERT_OCCUPANCY0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
     },
     "M3UPI.TxR_VERT_OCCUPANCY0.AK_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxR_VERT_OCCUPANCY0.AD_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.TxR_VERT_OCCUPANCY0.BL_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.TxR_VERT_OCCUPANCY0.IV_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.TxR_VERT_OCCUPANCY0.BL_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxR_VERT_OCCUPANCY0.AK_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.TxR_VERT_OCCUPANCY0.AD_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxR_VERT_OCCUPANCY1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 145,
	  "ExtSel": "",
     },
     "M3UPI.TxR_VERT_OCCUPANCY1.AKC_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 145,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxR_VERT_OCCUPANCY1.AKC_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Occupancy event for the Egress buffers in the Common Mesh Stop  The egress is used to queue up requests destined for the Vertical Ring on the Mesh.",
	  "Desc": "CMS Vert Egress Occupancy",
	  "EvSel": 145,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxR_VERT_STARVED0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
     },
     "M3UPI.TxR_VERT_STARVED0.BL_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.TxR_VERT_STARVED0.AD_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.TxR_VERT_STARVED0.AK_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxR_VERT_STARVED0.AK_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.TxR_VERT_STARVED0.AD_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.TxR_VERT_STARVED0.BL_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxR_VERT_STARVED0.IV_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 154,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.TxR_VERT_STARVED1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 155,
	  "ExtSel": "",
     },
     "M3UPI.TxR_VERT_STARVED1.TGC": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 155,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.TxR_VERT_STARVED1.AKC_AG1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 155,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.TxR_VERT_STARVED1.AKC_AG0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI CMS Vertical EGRESS Events",
	  "Defn": "Counts injection starvation.  This starvation is triggered when the CMS Egress cannot send a transaction onto the Vertical ring for a long period of time.",
	  "Desc": "CMS Vertical Egress Injection Starvation",
	  "EvSel": 155,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.UPI_PEER_AD_CREDITS_EMPTY": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to UPIs on the AD Ring",
	  "Desc": "UPI0 AD Credits Empty",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Notes": "2 cases for non-smi3 mode and 3 cases for smi3 mode",
     },
     "M3UPI.UPI_PEER_AD_CREDITS_EMPTY.VNA": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to UPIs on the AD Ring",
	  "Desc": "UPI0 AD Credits Empty",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Notes": "2 cases for non-smi3 mode and 3 cases for smi3 mode",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.UPI_PEER_AD_CREDITS_EMPTY.VN1_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to UPIs on the AD Ring",
	  "Desc": "UPI0 AD Credits Empty",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Notes": "2 cases for non-smi3 mode and 3 cases for smi3 mode",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.UPI_PEER_AD_CREDITS_EMPTY.VN0_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to UPIs on the AD Ring",
	  "Desc": "UPI0 AD Credits Empty",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Notes": "2 cases for non-smi3 mode and 3 cases for smi3 mode",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.UPI_PEER_AD_CREDITS_EMPTY.VN1_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to UPIs on the AD Ring",
	  "Desc": "UPI0 AD Credits Empty",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Notes": "2 cases for non-smi3 mode and 3 cases for smi3 mode",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.UPI_PEER_AD_CREDITS_EMPTY.VN0_SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to UPIs on the AD Ring",
	  "Desc": "UPI0 AD Credits Empty",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Notes": "2 cases for non-smi3 mode and 3 cases for smi3 mode",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.UPI_PEER_AD_CREDITS_EMPTY.VN0_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to UPIs on the AD Ring",
	  "Desc": "UPI0 AD Credits Empty",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Notes": "2 cases for non-smi3 mode and 3 cases for smi3 mode",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.UPI_PEER_AD_CREDITS_EMPTY.VN1_REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to UPIs on the AD Ring",
	  "Desc": "UPI0 AD Credits Empty",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Notes": "2 cases for non-smi3 mode and 3 cases for smi3 mode",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.UPI_PEER_BL_CREDITS_EMPTY": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to UPI on the BL Ring (diff between non-SMI and SMI mode)",
	  "Desc": "UPI0 BL Credits Empty",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Notes": "smi and non-smi modes",
     },
     "M3UPI.UPI_PEER_BL_CREDITS_EMPTY.VN0_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to UPI on the BL Ring (diff between non-SMI and SMI mode)",
	  "Desc": "UPI0 BL Credits Empty",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Notes": "smi and non-smi modes",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.UPI_PEER_BL_CREDITS_EMPTY.VN1_RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to UPI on the BL Ring (diff between non-SMI and SMI mode)",
	  "Desc": "UPI0 BL Credits Empty",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Notes": "smi and non-smi modes",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.UPI_PEER_BL_CREDITS_EMPTY.VN0_NCS_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to UPI on the BL Ring (diff between non-SMI and SMI mode)",
	  "Desc": "UPI0 BL Credits Empty",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Notes": "smi and non-smi modes",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.UPI_PEER_BL_CREDITS_EMPTY.VNA": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to UPI on the BL Ring (diff between non-SMI and SMI mode)",
	  "Desc": "UPI0 BL Credits Empty",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Notes": "smi and non-smi modes",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.UPI_PEER_BL_CREDITS_EMPTY.VN1_NCS_NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to UPI on the BL Ring (diff between non-SMI and SMI mode)",
	  "Desc": "UPI0 BL Credits Empty",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Notes": "smi and non-smi modes",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.UPI_PEER_BL_CREDITS_EMPTY.VN1_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to UPI on the BL Ring (diff between non-SMI and SMI mode)",
	  "Desc": "UPI0 BL Credits Empty",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Notes": "smi and non-smi modes",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.UPI_PEER_BL_CREDITS_EMPTY.VN0_WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI EGRESS Credit Events",
	  "Counters": "0-3",
	  "Defn": "No credits available to send to UPI on the BL Ring (diff between non-SMI and SMI mode)",
	  "Desc": "UPI0 BL Credits Empty",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Notes": "smi and non-smi modes",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.UPI_PREFETCH_SPAWN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Special Egress Events",
	  "Counters": "0-3",
	  "Defn": "Count cases where FlowQ causes spawn of Prefetch to iMC/SMI3 target",
	  "Desc": "FlowQ Generated Prefetch",
	  "EvSel": 41,
	  "ExtSel": "",
     },
     "M3UPI.VERT_RING_AD_IN_USE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
     },
     "M3UPI.VERT_RING_AD_IN_USE.DN_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.VERT_RING_AD_IN_USE.UP_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.VERT_RING_AD_IN_USE.UP_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.VERT_RING_AD_IN_USE.DN_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  We really have two rings  -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AD Ring In Use",
	  "EvSel": 176,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.VERT_RING_AKC_IN_USE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
     },
     "M3UPI.VERT_RING_AKC_IN_USE.DN_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.VERT_RING_AKC_IN_USE.UP_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.VERT_RING_AKC_IN_USE.UP_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.VERT_RING_AKC_IN_USE.DN_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AKC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AKC Ring In Use",
	  "EvSel": 180,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.VERT_RING_AK_IN_USE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
     },
     "M3UPI.VERT_RING_AK_IN_USE.DN_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.VERT_RING_AK_IN_USE.UP_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.VERT_RING_AK_IN_USE.UP_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.VERT_RING_AK_IN_USE.DN_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical AK Ring In Use",
	  "EvSel": 177,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.VERT_RING_BL_IN_USE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
     },
     "M3UPI.VERT_RING_BL_IN_USE.UP_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.VERT_RING_BL_IN_USE.DN_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.VERT_RING_BL_IN_USE.DN_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.VERT_RING_BL_IN_USE.UP_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical BL Ring in Use",
	  "EvSel": 178,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.VERT_RING_IV_IN_USE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Vertical IV Ring in Use",
	  "EvSel": 179,
	  "ExtSel": "",
     },
     "M3UPI.VERT_RING_IV_IN_USE.UP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Vertical IV Ring in Use",
	  "EvSel": 179,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.VERT_RING_IV_IN_USE.DN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical IV ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.  There is only 1 IV ring.  Therefore, if one wants to monitor the \"Even\" ring, they should select both UP_EVEN and DN_EVEN.  To monitor the \"Odd\" ring, they should select both UP_ODD and DN_ODD.",
	  "Desc": "Vertical IV Ring in Use",
	  "EvSel": 179,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.VERT_RING_TGC_IN_USE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
     },
     "M3UPI.VERT_RING_TGC_IN_USE.UP_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.VERT_RING_TGC_IN_USE.DN_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.VERT_RING_TGC_IN_USE.DN_ODD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.VERT_RING_TGC_IN_USE.UP_EVEN": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Vertical In Use RING Events",
	  "Defn": "Counts the number of cycles that the Vertical TGC ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the \"UP\" direction is on the clockwise ring and \"DN\" is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
	  "Desc": "Vertical TGC Ring In Use",
	  "EvSel": 181,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.VN0_CREDITS_USED": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of times a VN0 credit was used on the DRS message channel.  In order for a request to be transferred across UPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This counts the number of times a VN0 credit was used.  Note that a single VN0 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN0 will only count a single credit even though it may use multiple buffers.",
	  "Desc": "VN0 Credit Used",
	  "EvSel": 91,
	  "ExtSel": "",
     },
     "M3UPI.VN0_CREDITS_USED.SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of times a VN0 credit was used on the DRS message channel.  In order for a request to be transferred across UPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This counts the number of times a VN0 credit was used.  Note that a single VN0 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN0 will only count a single credit even though it may use multiple buffers.",
	  "Desc": "VN0 Credit Used",
	  "EvSel": 91,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.VN0_CREDITS_USED.WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of times a VN0 credit was used on the DRS message channel.  In order for a request to be transferred across UPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This counts the number of times a VN0 credit was used.  Note that a single VN0 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN0 will only count a single credit even though it may use multiple buffers.",
	  "Desc": "VN0 Credit Used",
	  "EvSel": 91,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.VN0_CREDITS_USED.NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of times a VN0 credit was used on the DRS message channel.  In order for a request to be transferred across UPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This counts the number of times a VN0 credit was used.  Note that a single VN0 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN0 will only count a single credit even though it may use multiple buffers.",
	  "Desc": "VN0 Credit Used",
	  "EvSel": 91,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.VN0_CREDITS_USED.NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of times a VN0 credit was used on the DRS message channel.  In order for a request to be transferred across UPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This counts the number of times a VN0 credit was used.  Note that a single VN0 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN0 will only count a single credit even though it may use multiple buffers.",
	  "Desc": "VN0 Credit Used",
	  "EvSel": 91,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.VN0_CREDITS_USED.REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of times a VN0 credit was used on the DRS message channel.  In order for a request to be transferred across UPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This counts the number of times a VN0 credit was used.  Note that a single VN0 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN0 will only count a single credit even though it may use multiple buffers.",
	  "Desc": "VN0 Credit Used",
	  "EvSel": 91,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.VN0_CREDITS_USED.RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of times a VN0 credit was used on the DRS message channel.  In order for a request to be transferred across UPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN0.  VNA is a shared pool used to achieve high performance.  The VN0 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN0 if they fail.  This counts the number of times a VN0 credit was used.  Note that a single VN0 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN0 will only count a single credit even though it may use multiple buffers.",
	  "Desc": "VN0 Credit Used",
	  "EvSel": 91,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.VN0_NO_CREDITS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of Cycles there were no VN0 Credits",
	  "Desc": "VN0 No Credits",
	  "EvSel": 93,
	  "ExtSel": "",
     },
     "M3UPI.VN0_NO_CREDITS.SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of Cycles there were no VN0 Credits",
	  "Desc": "VN0 No Credits",
	  "EvSel": 93,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.VN0_NO_CREDITS.WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of Cycles there were no VN0 Credits",
	  "Desc": "VN0 No Credits",
	  "EvSel": 93,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.VN0_NO_CREDITS.NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of Cycles there were no VN0 Credits",
	  "Desc": "VN0 No Credits",
	  "EvSel": 93,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.VN0_NO_CREDITS.NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of Cycles there were no VN0 Credits",
	  "Desc": "VN0 No Credits",
	  "EvSel": 93,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.VN0_NO_CREDITS.REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of Cycles there were no VN0 Credits",
	  "Desc": "VN0 No Credits",
	  "EvSel": 93,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.VN0_NO_CREDITS.RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of Cycles there were no VN0 Credits",
	  "Desc": "VN0 No Credits",
	  "EvSel": 93,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.VN1_CREDITS_USED": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of times a VN1 credit was used on the WB message channel.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN1.  VNA is a shared pool used to achieve high performance.  The VN1 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN1 if they fail.  This counts the number of times a VN1 credit was used.  Note that a single VN1 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN1 will only count a single credit even though it may use multiple buffers.",
	  "Desc": "VN1 Credit Used",
	  "EvSel": 92,
	  "ExtSel": "",
     },
     "M3UPI.VN1_CREDITS_USED.SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of times a VN1 credit was used on the WB message channel.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN1.  VNA is a shared pool used to achieve high performance.  The VN1 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN1 if they fail.  This counts the number of times a VN1 credit was used.  Note that a single VN1 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN1 will only count a single credit even though it may use multiple buffers.",
	  "Desc": "VN1 Credit Used",
	  "EvSel": 92,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.VN1_CREDITS_USED.WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of times a VN1 credit was used on the WB message channel.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN1.  VNA is a shared pool used to achieve high performance.  The VN1 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN1 if they fail.  This counts the number of times a VN1 credit was used.  Note that a single VN1 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN1 will only count a single credit even though it may use multiple buffers.",
	  "Desc": "VN1 Credit Used",
	  "EvSel": 92,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.VN1_CREDITS_USED.NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of times a VN1 credit was used on the WB message channel.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN1.  VNA is a shared pool used to achieve high performance.  The VN1 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN1 if they fail.  This counts the number of times a VN1 credit was used.  Note that a single VN1 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN1 will only count a single credit even though it may use multiple buffers.",
	  "Desc": "VN1 Credit Used",
	  "EvSel": 92,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.VN1_CREDITS_USED.NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of times a VN1 credit was used on the WB message channel.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN1.  VNA is a shared pool used to achieve high performance.  The VN1 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN1 if they fail.  This counts the number of times a VN1 credit was used.  Note that a single VN1 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN1 will only count a single credit even though it may use multiple buffers.",
	  "Desc": "VN1 Credit Used",
	  "EvSel": 92,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.VN1_CREDITS_USED.REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of times a VN1 credit was used on the WB message channel.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN1.  VNA is a shared pool used to achieve high performance.  The VN1 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN1 if they fail.  This counts the number of times a VN1 credit was used.  Note that a single VN1 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN1 will only count a single credit even though it may use multiple buffers.",
	  "Desc": "VN1 Credit Used",
	  "EvSel": 92,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.VN1_CREDITS_USED.RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of times a VN1 credit was used on the WB message channel.  In order for a request to be transferred across QPI, it must be guaranteed to have a flit buffer on the remote socket to sink into.  There are two credit pools, VNA and VN1.  VNA is a shared pool used to achieve high performance.  The VN1 pool has reserved entries for each message class and is used to prevent deadlock.  Requests first attempt to acquire a VNA credit, and then fall back to VN1 if they fail.  This counts the number of times a VN1 credit was used.  Note that a single VN1 credit holds access to potentially multiple flit buffers.  For example, a transfer that uses VNA could use 9 flit buffers and in that case uses 9 credits.  A transfer on VN1 will only count a single credit even though it may use multiple buffers.",
	  "Desc": "VN1 Credit Used",
	  "EvSel": 92,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.VN1_NO_CREDITS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of Cycles there were no VN1 Credits",
	  "Desc": "VN1 No Credits",
	  "EvSel": 94,
	  "ExtSel": "",
     },
     "M3UPI.VN1_NO_CREDITS.WB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of Cycles there were no VN1 Credits",
	  "Desc": "VN1 No Credits",
	  "EvSel": 94,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.VN1_NO_CREDITS.SNP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of Cycles there were no VN1 Credits",
	  "Desc": "VN1 No Credits",
	  "EvSel": 94,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.VN1_NO_CREDITS.NCB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of Cycles there were no VN1 Credits",
	  "Desc": "VN1 No Credits",
	  "EvSel": 94,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.VN1_NO_CREDITS.REQ": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of Cycles there were no VN1 Credits",
	  "Desc": "VN1 No Credits",
	  "EvSel": 94,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.VN1_NO_CREDITS.NCS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of Cycles there were no VN1 Credits",
	  "Desc": "VN1 No Credits",
	  "EvSel": 94,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.VN1_NO_CREDITS.RSP": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Link VN Credit Events",
	  "Defn": "Number of Cycles there were no VN1 Credits",
	  "Desc": "VN1 No Credits",
	  "EvSel": 94,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.WB_OCC_COMPARE": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 126,
	  "ExtSel": "",
     },
     "M3UPI.WB_OCC_COMPARE.BOTHNONZERO_RT_GT_LOCALDEST_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 126,
	  "ExtSel": "",
	  "Umask": "b1xxxxxx1",
     },
     "M3UPI.WB_OCC_COMPARE.BOTHNONZERO_RT_GT_LOCALDEST_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 126,
	  "ExtSel": "",
	  "Umask": "b1xx1xxxx",
     },
     "M3UPI.WB_OCC_COMPARE.BOTHNONZERO_RT_LT_LOCALDEST_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 126,
	  "ExtSel": "",
	  "Umask": "b11xxxxxx",
     },
     "M3UPI.WB_OCC_COMPARE.RT_LT_LOCALDEST_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 126,
	  "ExtSel": "",
	  "Umask": "b0xxxx1xx",
     },
     "M3UPI.WB_OCC_COMPARE.RT_GT_LOCALDEST_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 126,
	  "ExtSel": "",
	  "Umask": "b0xxxxxx1",
     },
     "M3UPI.WB_OCC_COMPARE.BOTHNONZERO_RT_EQ_LOCALDEST_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 126,
	  "ExtSel": "",
	  "Umask": "b1x1xxxxx",
     },
     "M3UPI.WB_OCC_COMPARE.RT_LT_LOCALDEST_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 126,
	  "ExtSel": "",
	  "Umask": "b01xxxxxx",
     },
     "M3UPI.WB_OCC_COMPARE.RT_GT_LOCALDEST_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 126,
	  "ExtSel": "",
	  "Umask": "b0xx1xxxx",
     },
     "M3UPI.WB_OCC_COMPARE.BOTHNONZERO_RT_LT_LOCALDEST_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 126,
	  "ExtSel": "",
	  "Umask": "b1xxxx1xx",
     },
     "M3UPI.WB_OCC_COMPARE.BOTHNONZERO_RT_EQ_LOCALDEST_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 126,
	  "ExtSel": "",
	  "Umask": "b1xxxxx1x",
     },
     "M3UPI.WB_OCC_COMPARE.RT_EQ_LOCALDEST_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 126,
	  "ExtSel": "",
	  "Umask": "b0xxxxx1x",
     },
     "M3UPI.WB_OCC_COMPARE.RT_EQ_LOCALDEST_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 126,
	  "ExtSel": "",
	  "Umask": "b0x1xxxxx",
     },
     "M3UPI.WB_PENDING": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 125,
	  "ExtSel": "",
     },
     "M3UPI.WB_PENDING.LOCAL_AND_RT_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 125,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "M3UPI.WB_PENDING.WAITING4PULL_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 125,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "M3UPI.WB_PENDING.WAITING4PULL_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 125,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.WB_PENDING.LOCAL_AND_RT_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 125,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "M3UPI.WB_PENDING.LOCALDEST_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 125,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.WB_PENDING.ROUTETHRU_VN0": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 125,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.WB_PENDING.ROUTETHRU_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 125,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.WB_PENDING.LOCALDEST_VN1": {
	  "Box": "M3UPI",
	  "Category": "M3UPI Writeback Events",
	  "EvSel": 125,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.XPT_PFTCH": {
	  "Box": "M3UPI",
	  "Category": "M3UPI XPT Events",
	  "EvSel": 97,
	  "ExtSel": "",
     },
     "M3UPI.XPT_PFTCH.LOST_QFULL": {
	  "Box": "M3UPI",
	  "Category": "M3UPI XPT Events",
	  "EvSel": 97,
	  "ExtSel": "",
	  "Umask": "bx1xxxxx",
     },
     "M3UPI.XPT_PFTCH.LOST_ARB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI XPT Events",
	  "EvSel": 97,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "M3UPI.XPT_PFTCH.BYPASS": {
	  "Box": "M3UPI",
	  "Category": "M3UPI XPT Events",
	  "EvSel": 97,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "M3UPI.XPT_PFTCH.ARRIVED": {
	  "Box": "M3UPI",
	  "Category": "M3UPI XPT Events",
	  "EvSel": 97,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "M3UPI.XPT_PFTCH.LOST_OLD": {
	  "Box": "M3UPI",
	  "Category": "M3UPI XPT Events",
	  "EvSel": 97,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "M3UPI.XPT_PFTCH.FLITTED": {
	  "Box": "M3UPI",
	  "Category": "M3UPI XPT Events",
	  "EvSel": 97,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "M3UPI.XPT_PFTCH.ARB": {
	  "Box": "M3UPI",
	  "Category": "M3UPI XPT Events",
	  "EvSel": 97,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },

# IIO:
     "IIO.CLOCKTICKS": {
	  "Box": "IIO",
	  "Category": "IIO CLOCK Events",
	  "Counters": "0-3",
	  "Defn": "Increments counter once every Traffic Controller clock, the LSCLK (500MHz)",
	  "Desc": "Clockticks of the integrated IO (IIO) traffic controller",
	  "EvSel": 129,
	  "ExtSel": "",
     },
     "IIO.COMP_BUF_INSERTS": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "0-3",
	  "Desc": "PCIe Completion Buffer Inserts",
	  "EvSel": 194,
	  "ExtSel": "",
	  "Notes": "aka OTC_ENQ.PREALLOC?  (May need to redo)",
     },
     "IIO.COMP_BUF_INSERTS.CMPD.PART4": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "0-3",
	  "Desc": "PCIe Completion Buffer Inserts",
	  "EvSel": 194,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "Notes": "aka OTC_ENQ.PREALLOC?  (May need to redo )",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxxxxx11",
     },
     "IIO.COMP_BUF_INSERTS.CMPD.PART7": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "0-3",
	  "Desc": "PCIe Completion Buffer Inserts",
	  "EvSel": 194,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "Notes": "aka OTC_ENQ.PREALLOC?  (May need to redo )",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxxxxx11",
     },
     "IIO.COMP_BUF_INSERTS.CMPD.PART1": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "0-3",
	  "Desc": "PCIe Completion Buffer Inserts",
	  "EvSel": 194,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "Notes": "aka OTC_ENQ.PREALLOC?  (May need to redo )",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxxxxx11",
     },
     "IIO.COMP_BUF_INSERTS.CMPD.PART5": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "0-3",
	  "Desc": "PCIe Completion Buffer Inserts",
	  "EvSel": 194,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "Notes": "aka OTC_ENQ.PREALLOC?  (May need to redo )",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxxxxx11",
     },
     "IIO.COMP_BUF_INSERTS.CMPD.PART3": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "0-3",
	  "Desc": "PCIe Completion Buffer Inserts",
	  "EvSel": 194,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "Notes": "aka OTC_ENQ.PREALLOC?  (May need to redo )",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxxxxx11",
     },
     "IIO.COMP_BUF_INSERTS.CMPD.PART0": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "0-3",
	  "Desc": "PCIe Completion Buffer Inserts",
	  "EvSel": 194,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "Notes": "aka OTC_ENQ.PREALLOC?  (May need to redo )",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxxxxx11",
     },
     "IIO.COMP_BUF_INSERTS.CMPD.PART2": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "0-3",
	  "Desc": "PCIe Completion Buffer Inserts",
	  "EvSel": 194,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "Notes": "aka OTC_ENQ.PREALLOC?  (May need to redo )",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxxxxx11",
     },
     "IIO.COMP_BUF_INSERTS.CMPD.PART6": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "0-3",
	  "Desc": "PCIe Completion Buffer Inserts",
	  "EvSel": 194,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "Notes": "aka OTC_ENQ.PREALLOC?  (May need to redo )",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxxxxx11",
     },
     "IIO.COMP_BUF_INSERTS.CMPD.ALL": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "0-3",
	  "Desc": "PCIe Completion Buffer Inserts",
	  "EvSel": 194,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "Notes": "aka OTC_ENQ.PREALLOC?  (May need to redo )",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxxx11",
     },
     "IIO.COMP_BUF_OCCUPANCY": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "2-3",
	  "Desc": "PCIe Completion Buffer Occupancy",
	  "EvSel": 213,
	  "ExtSel": "",
     },
     "IIO.COMP_BUF_OCCUPANCY.CMPD.PART4": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "2-3",
	  "Desc": "PCIe Completion Buffer Occupancy",
	  "EvSel": 213,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "PortMask": "bxxxxxxxxxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.COMP_BUF_OCCUPANCY.CMPD.PART7": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "2-3",
	  "Desc": "PCIe Completion Buffer Occupancy",
	  "EvSel": 213,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "PortMask": "bxxxxxxxxxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.COMP_BUF_OCCUPANCY.CMPD.PART1": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "2-3",
	  "Desc": "PCIe Completion Buffer Occupancy",
	  "EvSel": 213,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "PortMask": "bxxxxxxxxxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.COMP_BUF_OCCUPANCY.CMPD.PART3": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "2-3",
	  "Desc": "PCIe Completion Buffer Occupancy",
	  "EvSel": 213,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "PortMask": "bxxxxxxxxxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.COMP_BUF_OCCUPANCY.CMPD.PART5": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "2-3",
	  "Desc": "PCIe Completion Buffer Occupancy",
	  "EvSel": 213,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "PortMask": "bxxxxxxxxxxxx",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.COMP_BUF_OCCUPANCY.CMPD.PART6": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "2-3",
	  "Desc": "PCIe Completion Buffer Occupancy",
	  "EvSel": 213,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "PortMask": "bxxxxxxxxxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.COMP_BUF_OCCUPANCY.CMPD.PART0": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "2-3",
	  "Desc": "PCIe Completion Buffer Occupancy",
	  "EvSel": 213,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "PortMask": "bxxxxxxxxxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.COMP_BUF_OCCUPANCY.CMPD.PART2": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "2-3",
	  "Desc": "PCIe Completion Buffer Occupancy",
	  "EvSel": 213,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "PortMask": "bxxxxxxxxxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.COMP_BUF_OCCUPANCY.CMPD.ALL": {
	  "Box": "IIO",
	  "Category": "IIO PCIe Completion Buffer Events",
	  "Counters": "2-3",
	  "Desc": "PCIe Completion Buffer Occupancy",
	  "EvSel": 213,
	  "FCMask": "b100",
	  "ExtSel": "",
	  "PortMask": "bxxxxxxxxxxxx",
	  "Umask": "b11111111",
     },
     "IIO.DATA_REQ_BY_CPU": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_READ.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_BY_CPU.IO_READ.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_WRITE.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_READ.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_READ.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.IO_WRITE.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_WRITE.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_READ.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_BY_CPU.IO_READ.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_READ.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_WRITE.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_WRITE.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_BY_CPU.IO_WRITE.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_READ.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_BY_CPU.IO_WRITE.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_READ.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_BY_CPU.IO_WRITE.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_READ.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_WRITE.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_WRITE.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_WRITE.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_READ.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_READ.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_WRITE.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_WRITE.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_WRITE.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_READ.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_READ.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_READ.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_WRITE.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_BY_CPU.IO_WRITE.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_READ.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_WRITE.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_WRITE.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_READ.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_WRITE.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_READ.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_BY_CPU.IO_WRITE.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.IO_READ.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_WRITE.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_WRITE.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_WRITE.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_READ.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_WRITE.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_WRITE.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_READ.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_READ.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.IO_READ.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_READ.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_WRITE.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_BY_CPU.IO_WRITE.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_WRITE.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_READ.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_WRITE.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_WRITE.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_READ.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_BY_CPU.IO_READ.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_READ.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.IO_READ.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_WRITE.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_READ.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_READ.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_WRITE.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_BY_CPU.IO_WRITE.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_WRITE.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_READ.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_BY_CPU.IO_READ.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_WRITE.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_WRITE.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_BY_CPU.IO_READ.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.IO_WRITE.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_READ.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_BY_CPU.PEER_READ.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_WRITE.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_READ.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.IO_READ.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.CFG_WRITE.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_BY_CPU.IO_READ.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_BY_CPU.MEM_READ.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_BY_CPU.IO_WRITE.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "2-3",
	  "Defn": "Number of DWs (4 bytes) requested by the main die.  Includes all requests initiated by the main die, including reads and writes.",
	  "Desc": "Data requested by the CPU",
	  "EvSel": 192,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.DATA_REQ_OF_CPU": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_READ.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_READ.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_OF_CPU.ATOMIC.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_OF_CPU.CMPD.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_WRITE.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_OF_CPU.CMPD.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.ATOMIC.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_OF_CPU.MSG.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.MSG.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.CMPD.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_READ.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_WRITE.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_OF_CPU.MSG.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.ATOMIC.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_READ.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_WRITE.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_WRITE.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_WRITE.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_READ.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_READ.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_READ.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_OF_CPU.CMPD.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_WRITE.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_WRITE.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_READ.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_OF_CPU.ATOMIC.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_WRITE.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_OF_CPU.ATOMIC.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_WRITE.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_READ.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_OF_CPU.MSG.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_WRITE.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_WRITE.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_READ.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_WRITE.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_OF_CPU.CMPD.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_READ.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_WRITE.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_OF_CPU.ATOMIC.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_OF_CPU.MSG.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.CMPD.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_READ.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_OF_CPU.ATOMIC.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_WRITE.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_READ.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_WRITE.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_OF_CPU.ATOMIC.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_OF_CPU.CMPD.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_WRITE.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_READ.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_OF_CPU.MSG.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.MSG.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.MSG.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_READ.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_OF_CPU.ATOMIC.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_OF_CPU.CMPD.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.CMPD.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_READ.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_READ.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_WRITE.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_OF_CPU.ATOMIC.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.DATA_REQ_OF_CPU.MSG.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_WRITE.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.DATA_REQ_OF_CPU.CMPD.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.MEM_READ.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_WRITE.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_READ.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_READ.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.DATA_REQ_OF_CPU.MSG.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.DATA_REQ_OF_CPU.PEER_WRITE.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Payload Events",
	  "Counters": "0-1",
	  "Defn": "Number of DWs (4 bytes) the card requests of the main die.    Includes all requests initiated by the Card, including reads and writes.",
	  "Desc": "Data requested of the CPU",
	  "EvSel": 131,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 1024,
	  "Notes": "Multiply value by 4 to convert to number of Bytes.   Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.   Counts are incremented on the request path rather than the completion path.    Expect to change back on next prodcut.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.INBOUND_ARB_REQ": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "How often different queues (e.g. channel / fc) ask to send request into pipeline",
	  "Desc": "Incoming arbitration requests",
	  "EvSel": 134,
	  "ExtSel": "",
     },
     "IIO.INBOUND_ARB_REQ.DATA": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "How often different queues (e.g. channel / fc) ask to send request into pipeline",
	  "Desc": "Incoming arbitration requests",
	  "EvSel": 134,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.INBOUND_ARB_REQ.IOMMU_HIT": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "How often different queues (e.g. channel / fc) ask to send request into pipeline",
	  "Desc": "Incoming arbitration requests",
	  "EvSel": 134,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.INBOUND_ARB_REQ.REQ_OWN": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "How often different queues (e.g. channel / fc) ask to send request into pipeline",
	  "Desc": "Incoming arbitration requests",
	  "EvSel": 134,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.INBOUND_ARB_REQ.WR": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "How often different queues (e.g. channel / fc) ask to send request into pipeline",
	  "Desc": "Incoming arbitration requests",
	  "EvSel": 134,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.INBOUND_ARB_REQ.IOMMU_REQ": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "How often different queues (e.g. channel / fc) ask to send request into pipeline",
	  "Desc": "Incoming arbitration requests",
	  "EvSel": 134,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.INBOUND_ARB_REQ.FINAL_RD_WR": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "How often different queues (e.g. channel / fc) ask to send request into pipeline",
	  "Desc": "Incoming arbitration requests",
	  "EvSel": 134,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.INBOUND_ARB_WON": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "How often different queues (e.g. channel / fc) are allowed to send request into pipeline",
	  "Desc": "Incoming arbitration requests granted",
	  "EvSel": 135,
	  "ExtSel": "",
     },
     "IIO.INBOUND_ARB_WON.IOMMU_HIT": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "How often different queues (e.g. channel / fc) are allowed to send request into pipeline",
	  "Desc": "Incoming arbitration requests granted",
	  "EvSel": 135,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.INBOUND_ARB_WON.REQ_OWN": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "How often different queues (e.g. channel / fc) are allowed to send request into pipeline",
	  "Desc": "Incoming arbitration requests granted",
	  "EvSel": 135,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.INBOUND_ARB_WON.DATA": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "How often different queues (e.g. channel / fc) are allowed to send request into pipeline",
	  "Desc": "Incoming arbitration requests granted",
	  "EvSel": 135,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.INBOUND_ARB_WON.FINAL_RD_WR": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "How often different queues (e.g. channel / fc) are allowed to send request into pipeline",
	  "Desc": "Incoming arbitration requests granted",
	  "EvSel": 135,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.INBOUND_ARB_WON.IOMMU_REQ": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "How often different queues (e.g. channel / fc) are allowed to send request into pipeline",
	  "Desc": "Incoming arbitration requests granted",
	  "EvSel": 135,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.INBOUND_ARB_WON.WR": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "How often different queues (e.g. channel / fc) are allowed to send request into pipeline",
	  "Desc": "Incoming arbitration requests granted",
	  "EvSel": 135,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 64,
	  "ExtSel": "",
     },
     "IIO.IOMMU0.4K_HITS": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.IOMMU0.1G_HITS": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.IOMMU0.2M_HITS": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.IOMMU0.MISSES": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.IOMMU0.CTXT_CACHE_LOOKUPS": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.IOMMU0.CTXT_CACHE_HITS": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.IOMMU0.ALL_LOOKUPS": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.IOMMU0.FIRST_LOOKUPS": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 64,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 65,
	  "ExtSel": "",
     },
     "IIO.IOMMU1.PWC_1G_HITS": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.IOMMU1.CYC_PWT_FULL": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.IOMMU1.NUM_MEM_ACCESSES": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.IOMMU1.PWC_2M_HITS": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.IOMMU1.PWT_CACHE_LOOKUPS": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.IOMMU1.PWC_512G_HITS": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.IOMMU1.PWC_4K_HITS": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.IOMMU1.PWC_CACHE_FILLS": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 65,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.IOMMU3": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 67,
	  "ExtSel": "",
     },
     "IIO.IOMMU3.NUM_INVAL_PAGE": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.IOMMU3.NUM_CTXT_CACHE_INVAL_GBL": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.IOMMU3.NUM_CTXT_CACHE_INVAL_DEVICE": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.IOMMU3.NUM_CTXT_CACHE_INVAL_DOMAIN": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.IOMMU3.INT_CACHE_HITS": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.IOMMU3.INT_CACHE_LOOKUPS": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.IOMMU3.NUM_INVAL_DOMAIN": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.IOMMU3.NUM_INVAL_GBL": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "EvSel": 67,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.MASK_MATCH_AND": {
	  "Box": "IIO",
	  "Category": "IIO Debug Events",
	  "Counters": "0-1",
	  "Defn": "Asserted if all bits specified by mask match",
	  "Desc": "AND Mask/match for debug bus",
	  "EvSel": 2,
	  "ExtSel": "",
     },
     "IIO.MASK_MATCH_AND.NOT_BUS0_NOT_BUS1": {
	  "Box": "IIO",
	  "Category": "IIO Debug Events",
	  "Counters": "0-1",
	  "Defn": "Asserted if all bits specified by mask match",
	  "Desc": "AND Mask/match for debug bus",
	  "EvSel": 2,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.MASK_MATCH_AND.BUS0_NOT_BUS1": {
	  "Box": "IIO",
	  "Category": "IIO Debug Events",
	  "Counters": "0-1",
	  "Defn": "Asserted if all bits specified by mask match",
	  "Desc": "AND Mask/match for debug bus",
	  "EvSel": 2,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.MASK_MATCH_AND.BUS0_BUS1": {
	  "Box": "IIO",
	  "Category": "IIO Debug Events",
	  "Counters": "0-1",
	  "Defn": "Asserted if all bits specified by mask match",
	  "Desc": "AND Mask/match for debug bus",
	  "EvSel": 2,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.MASK_MATCH_AND.BUS1": {
	  "Box": "IIO",
	  "Category": "IIO Debug Events",
	  "Counters": "0-1",
	  "Defn": "Asserted if all bits specified by mask match",
	  "Desc": "AND Mask/match for debug bus",
	  "EvSel": 2,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.MASK_MATCH_AND.BUS0": {
	  "Box": "IIO",
	  "Category": "IIO Debug Events",
	  "Counters": "0-1",
	  "Defn": "Asserted if all bits specified by mask match",
	  "Desc": "AND Mask/match for debug bus",
	  "EvSel": 2,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.MASK_MATCH_AND.NOT_BUS0_BUS1": {
	  "Box": "IIO",
	  "Category": "IIO Debug Events",
	  "Counters": "0-1",
	  "Defn": "Asserted if all bits specified by mask match",
	  "Desc": "AND Mask/match for debug bus",
	  "EvSel": 2,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.MASK_MATCH_OR": {
	  "Box": "IIO",
	  "Category": "IIO Debug Events",
	  "Counters": "0-1",
	  "Defn": "Asserted if any bits specified by mask match",
	  "Desc": "OR Mask/match for debug bus",
	  "EvSel": 3,
	  "ExtSel": "",
     },
     "IIO.MASK_MATCH_OR.NOT_BUS0_BUS1": {
	  "Box": "IIO",
	  "Category": "IIO Debug Events",
	  "Counters": "0-1",
	  "Defn": "Asserted if any bits specified by mask match",
	  "Desc": "OR Mask/match for debug bus",
	  "EvSel": 3,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.MASK_MATCH_OR.BUS0": {
	  "Box": "IIO",
	  "Category": "IIO Debug Events",
	  "Counters": "0-1",
	  "Defn": "Asserted if any bits specified by mask match",
	  "Desc": "OR Mask/match for debug bus",
	  "EvSel": 3,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.MASK_MATCH_OR.BUS1": {
	  "Box": "IIO",
	  "Category": "IIO Debug Events",
	  "Counters": "0-1",
	  "Defn": "Asserted if any bits specified by mask match",
	  "Desc": "OR Mask/match for debug bus",
	  "EvSel": 3,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.MASK_MATCH_OR.NOT_BUS0_NOT_BUS1": {
	  "Box": "IIO",
	  "Category": "IIO Debug Events",
	  "Counters": "0-1",
	  "Defn": "Asserted if any bits specified by mask match",
	  "Desc": "OR Mask/match for debug bus",
	  "EvSel": 3,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.MASK_MATCH_OR.BUS0_NOT_BUS1": {
	  "Box": "IIO",
	  "Category": "IIO Debug Events",
	  "Counters": "0-1",
	  "Defn": "Asserted if any bits specified by mask match",
	  "Desc": "OR Mask/match for debug bus",
	  "EvSel": 3,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.MASK_MATCH_OR.BUS0_BUS1": {
	  "Box": "IIO",
	  "Category": "IIO Debug Events",
	  "Counters": "0-1",
	  "Defn": "Asserted if any bits specified by mask match",
	  "Desc": "OR Mask/match for debug bus",
	  "EvSel": 3,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.NOTHING": {
	  "Box": "IIO",
	  "Category": "IIO CLOCK Events",
	  "Counters": "0-3",
	  "Desc": "Counting disabled",
	  "EvSel": 128,
	  "ExtSel": "",
     },
     "IIO.NUM_OUSTANDING_REQ_FROM_CPU": {
	  "Box": "IIO",
	  "Category": "IIO OTC Events",
	  "Counters": "2-3",
	  "Defn": "Counts number of outbound requests/completions IIO is currently processing",
	  "Desc": "Occupancy of outbound request queue",
	  "EvSel": 197,
	  "ExtSel": "",
	  "MaxIncCyc": 256,
	  "Notes": "Only 1 bit each of the fc_mask and ch_mask can be set",
     },
     "IIO.NUM_OUSTANDING_REQ_FROM_CPU.TO_IO": {
	  "Box": "IIO",
	  "Category": "IIO OTC Events",
	  "Counters": "2-3",
	  "Defn": "Counts number of outbound requests/completions IIO is currently processing",
	  "Desc": "Occupancy of outbound request queue",
	  "EvSel": 197,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 256,
	  "Notes": "Only 1 bit each of the fc_mask and ch_mask can be set",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.NUM_OUTSTANDING_REQ_OF_CPU": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "2-3",
	  "EvSel": 136,
	  "ExtSel": "",
	  "MaxIncCyc": 512,
     },
     "IIO.NUM_OUTSTANDING_REQ_OF_CPU.FINAL_RD_WR": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "2-3",
	  "EvSel": 136,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 512,
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.NUM_OUTSTANDING_REQ_OF_CPU.IOMMU_REQ": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "2-3",
	  "EvSel": 136,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 512,
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.NUM_OUTSTANDING_REQ_OF_CPU.WR": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "2-3",
	  "EvSel": 136,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 512,
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.NUM_OUTSTANDING_REQ_OF_CPU.IOMMU_HIT": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "2-3",
	  "EvSel": 136,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 512,
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.NUM_OUTSTANDING_REQ_OF_CPU.REQ_OWN": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "2-3",
	  "EvSel": 136,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 512,
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.NUM_OUTSTANDING_REQ_OF_CPU.DATA": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "2-3",
	  "EvSel": 136,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "MaxIncCyc": 512,
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.NUM_REQ_FROM_CPU": {
	  "Box": "IIO",
	  "Category": "IIO OTC Events",
	  "Counters": "0-3",
	  "Desc": "Number requests sent to PCIe from main die",
	  "EvSel": 194,
	  "ExtSel": "",
     },
     "IIO.NUM_REQ_FROM_CPU.PREALLOC": {
	  "Box": "IIO",
	  "Category": "IIO OTC Events",
	  "Counters": "0-3",
	  "Desc": "Number requests sent to PCIe from main die",
	  "EvSel": 194,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.NUM_REQ_FROM_CPU.IRP": {
	  "Box": "IIO",
	  "Category": "IIO OTC Events",
	  "Counters": "0-3",
	  "Desc": "Number requests sent to PCIe from main die",
	  "EvSel": 194,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.NUM_REQ_FROM_CPU.ITC": {
	  "Box": "IIO",
	  "Category": "IIO OTC Events",
	  "Counters": "0-3",
	  "Desc": "Number requests sent to PCIe from main die",
	  "EvSel": 194,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.NUM_REQ_OF_CPU": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Counts full PCIe requests before they're broken into a series of cache-line size requests as measured by DATA_REQ_OF_CPU and TXN_REQ_OF_CPU.",
	  "Desc": "Number requests PCIe makes of the main die",
	  "EvSel": 133,
	  "ExtSel": "",
     },
     "IIO.NUM_REQ_OF_CPU.ALL.DROP": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Counts full PCIe requests before they're broken into a series of cache-line size requests as measured by DATA_REQ_OF_CPU and TXN_REQ_OF_CPU.",
	  "Desc": "Number requests PCIe makes of the main die",
	  "EvSel": 133,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.NUM_REQ_OF_CPU.COMMIT.ALL": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Counts full PCIe requests before they're broken into a series of cache-line size requests as measured by DATA_REQ_OF_CPU and TXN_REQ_OF_CPU.",
	  "Desc": "Number requests PCIe makes of the main die",
	  "EvSel": 133,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.NUM_REQ_OF_CPU_BY_TGT": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Desc": "Num requests sent by PCIe - by target",
	  "EvSel": 142,
	  "ExtSel": "",
     },
     "IIO.NUM_REQ_OF_CPU_BY_TGT.CONFINED_P2P": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Desc": "Num requests sent by PCIe - by target",
	  "EvSel": 142,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.NUM_REQ_OF_CPU_BY_TGT.MCAST": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Desc": "Num requests sent by PCIe - by target",
	  "EvSel": 142,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.NUM_REQ_OF_CPU_BY_TGT.ABORT": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Desc": "Num requests sent by PCIe - by target",
	  "EvSel": 142,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.NUM_REQ_OF_CPU_BY_TGT.UBOX": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Desc": "Num requests sent by PCIe - by target",
	  "EvSel": 142,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.NUM_REQ_OF_CPU_BY_TGT.MSGB": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Desc": "Num requests sent by PCIe - by target",
	  "EvSel": 142,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.NUM_REQ_OF_CPU_BY_TGT.LOC_P2P": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Desc": "Num requests sent by PCIe - by target",
	  "EvSel": 142,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.NUM_REQ_OF_CPU_BY_TGT.REM_P2P": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Desc": "Num requests sent by PCIe - by target",
	  "EvSel": 142,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.NUM_REQ_OF_CPU_BY_TGT.MEM": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Desc": "Num requests sent by PCIe - by target",
	  "EvSel": 142,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.NUM_TGT_MATCHED_REQ_OF_CPU": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Desc": "ITC address map 1",
	  "EvSel": 143,
	  "ExtSel": "",
     },
     "IIO.OUTBOUND_CL_REQS_ISSUED": {
	  "Box": "IIO",
	  "Category": "IIO OTC Events",
	  "Counters": "0-3",
	  "Defn": "Each outbound cacheline granular request may need to make multiple passes through the pipeline.  Each time a cacheline completes all its passes it advances line",
	  "Desc": "Outbound cacheline requests issued",
	  "EvSel": 208,
	  "ExtSel": "",
     },
     "IIO.OUTBOUND_CL_REQS_ISSUED.TO_IO": {
	  "Box": "IIO",
	  "Category": "IIO OTC Events",
	  "Counters": "0-3",
	  "Defn": "Each outbound cacheline granular request may need to make multiple passes through the pipeline.  Each time a cacheline completes all its passes it advances line",
	  "Desc": "Outbound cacheline requests issued",
	  "EvSel": 208,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.OUTBOUND_TLP_REQS_ISSUED": {
	  "Box": "IIO",
	  "Category": "IIO OTC Events",
	  "Counters": "0-3",
	  "Defn": "Each time an outbound completes all its passes it advances the pointer",
	  "Desc": "Outbound TLP (transaction layer packet) requests issued",
	  "EvSel": 209,
	  "ExtSel": "",
     },
     "IIO.OUTBOUND_TLP_REQS_ISSUED.TO_IO": {
	  "Box": "IIO",
	  "Category": "IIO OTC Events",
	  "Counters": "0-3",
	  "Defn": "Each time an outbound completes all its passes it advances the pointer",
	  "Desc": "Outbound TLP (transaction layer packet) requests issued",
	  "EvSel": 209,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.PWT_OCCUPANCY": {
	  "Box": "IIO",
	  "Category": "IIO IOMMU Events",
	  "Defn": "Indicates how many page walks are outstanding at any point in time.",
	  "Desc": "PWT occupancy",
	  "EvSel": 66,
	  "ExtSel": "",
     },
     "IIO.REQ_FROM_PCIE_CL_CMPL": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Each PCIe request is broken down into a series of cacheline granular requests and each cacheline size request may need to make multiple passes through the pipeline (e.g. for posted interrupts or multi-cast).   Each time a cacheline completes all its passes (e.g. finishes posting writes to all multi-cast targets) it advances line",
	  "Desc": "PCIe Request - cacheline complete",
	  "EvSel": 145,
	  "ExtSel": "",
	  "Notes": "For a normal write (no posted interrupt, no multi-cast) advance line = advance state.   For a PCIe request of <= cacheline, advance pointer = advance line",
     },
     "IIO.REQ_FROM_PCIE_CL_CMPL.DATA": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Each PCIe request is broken down into a series of cacheline granular requests and each cacheline size request may need to make multiple passes through the pipeline (e.g. for posted interrupts or multi-cast).   Each time a cacheline completes all its passes (e.g. finishes posting writes to all multi-cast targets) it advances line",
	  "Desc": "PCIe Request - cacheline complete",
	  "EvSel": 145,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "For a normal write (no posted interrupt, no multi-cast) advance line = advance state.   For a PCIe request of <= cacheline, advance pointer = advance line",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.REQ_FROM_PCIE_CL_CMPL.WR": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Each PCIe request is broken down into a series of cacheline granular requests and each cacheline size request may need to make multiple passes through the pipeline (e.g. for posted interrupts or multi-cast).   Each time a cacheline completes all its passes (e.g. finishes posting writes to all multi-cast targets) it advances line",
	  "Desc": "PCIe Request - cacheline complete",
	  "EvSel": 145,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "For a normal write (no posted interrupt, no multi-cast) advance line = advance state.   For a PCIe request of <= cacheline, advance pointer = advance line",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.REQ_FROM_PCIE_CL_CMPL.REQ_OWN": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Each PCIe request is broken down into a series of cacheline granular requests and each cacheline size request may need to make multiple passes through the pipeline (e.g. for posted interrupts or multi-cast).   Each time a cacheline completes all its passes (e.g. finishes posting writes to all multi-cast targets) it advances line",
	  "Desc": "PCIe Request - cacheline complete",
	  "EvSel": 145,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "For a normal write (no posted interrupt, no multi-cast) advance line = advance state.   For a PCIe request of <= cacheline, advance pointer = advance line",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.REQ_FROM_PCIE_CL_CMPL.FINAL_RD_WR": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Each PCIe request is broken down into a series of cacheline granular requests and each cacheline size request may need to make multiple passes through the pipeline (e.g. for posted interrupts or multi-cast).   Each time a cacheline completes all its passes (e.g. finishes posting writes to all multi-cast targets) it advances line",
	  "Desc": "PCIe Request - cacheline complete",
	  "EvSel": 145,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "For a normal write (no posted interrupt, no multi-cast) advance line = advance state.   For a PCIe request of <= cacheline, advance pointer = advance line",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.REQ_FROM_PCIE_CMPL": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Each PCIe request is broken down into a series of cacheline granular requests and each cacheline size request may need to make multiple passes through the pipeline (e.g. for posted interrupts or multi-cast).   Each time a single PCIe request completes all its cacheline granular requests, it advances pointer.",
	  "Desc": "PCIe Request complete",
	  "EvSel": 146,
	  "ExtSel": "",
	  "Notes": "For a PCIe request of <= cacheline, advance pointer = advance line",
     },
     "IIO.REQ_FROM_PCIE_CMPL.IOMMU_HIT": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Each PCIe request is broken down into a series of cacheline granular requests and each cacheline size request may need to make multiple passes through the pipeline (e.g. for posted interrupts or multi-cast).   Each time a single PCIe request completes all its cacheline granular requests, it advances pointer.",
	  "Desc": "PCIe Request complete",
	  "EvSel": 146,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "For a PCIe request of <= cacheline, advance pointer = advance line",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.REQ_FROM_PCIE_CMPL.REQ_OWN": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Each PCIe request is broken down into a series of cacheline granular requests and each cacheline size request may need to make multiple passes through the pipeline (e.g. for posted interrupts or multi-cast).   Each time a single PCIe request completes all its cacheline granular requests, it advances pointer.",
	  "Desc": "PCIe Request complete",
	  "EvSel": 146,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "For a PCIe request of <= cacheline, advance pointer = advance line",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.REQ_FROM_PCIE_CMPL.DATA": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Each PCIe request is broken down into a series of cacheline granular requests and each cacheline size request may need to make multiple passes through the pipeline (e.g. for posted interrupts or multi-cast).   Each time a single PCIe request completes all its cacheline granular requests, it advances pointer.",
	  "Desc": "PCIe Request complete",
	  "EvSel": 146,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "For a PCIe request of <= cacheline, advance pointer = advance line",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.REQ_FROM_PCIE_CMPL.FINAL_RD_WR": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Each PCIe request is broken down into a series of cacheline granular requests and each cacheline size request may need to make multiple passes through the pipeline (e.g. for posted interrupts or multi-cast).   Each time a single PCIe request completes all its cacheline granular requests, it advances pointer.",
	  "Desc": "PCIe Request complete",
	  "EvSel": 146,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "For a PCIe request of <= cacheline, advance pointer = advance line",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.REQ_FROM_PCIE_CMPL.IOMMU_REQ": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Each PCIe request is broken down into a series of cacheline granular requests and each cacheline size request may need to make multiple passes through the pipeline (e.g. for posted interrupts or multi-cast).   Each time a single PCIe request completes all its cacheline granular requests, it advances pointer.",
	  "Desc": "PCIe Request complete",
	  "EvSel": 146,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "For a PCIe request of <= cacheline, advance pointer = advance line",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.REQ_FROM_PCIE_CMPL.WR": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Each PCIe request is broken down into a series of cacheline granular requests and each cacheline size request may need to make multiple passes through the pipeline (e.g. for posted interrupts or multi-cast).   Each time a single PCIe request completes all its cacheline granular requests, it advances pointer.",
	  "Desc": "PCIe Request complete",
	  "EvSel": 146,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "For a PCIe request of <= cacheline, advance pointer = advance line",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.REQ_FROM_PCIE_PASS_CMPL": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Each PCIe request is broken down into a series of cacheline granular requests and each cacheline size request may need to make multiple passes through the pipeline (e.g. for posted interrupts or multi-cast).   Each time a cacheline completes a single pass (e.g. posts a write to single multi-cast target) it advances state",
	  "Desc": "PCIe Request - pass complete",
	  "EvSel": 144,
	  "ExtSel": "",
	  "Notes": "For a normal write (no posted interrupt, no multi-cast) advance line = advance state",
     },
     "IIO.REQ_FROM_PCIE_PASS_CMPL.FINAL_RD_WR": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Each PCIe request is broken down into a series of cacheline granular requests and each cacheline size request may need to make multiple passes through the pipeline (e.g. for posted interrupts or multi-cast).   Each time a cacheline completes a single pass (e.g. posts a write to single multi-cast target) it advances state",
	  "Desc": "PCIe Request - pass complete",
	  "EvSel": 144,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "For a normal write (no posted interrupt, no multi-cast) advance line = advance state",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.REQ_FROM_PCIE_PASS_CMPL.WR": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Each PCIe request is broken down into a series of cacheline granular requests and each cacheline size request may need to make multiple passes through the pipeline (e.g. for posted interrupts or multi-cast).   Each time a cacheline completes a single pass (e.g. posts a write to single multi-cast target) it advances state",
	  "Desc": "PCIe Request - pass complete",
	  "EvSel": 144,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "For a normal write (no posted interrupt, no multi-cast) advance line = advance state",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.REQ_FROM_PCIE_PASS_CMPL.DATA": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Each PCIe request is broken down into a series of cacheline granular requests and each cacheline size request may need to make multiple passes through the pipeline (e.g. for posted interrupts or multi-cast).   Each time a cacheline completes a single pass (e.g. posts a write to single multi-cast target) it advances state",
	  "Desc": "PCIe Request - pass complete",
	  "EvSel": 144,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "For a normal write (no posted interrupt, no multi-cast) advance line = advance state",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.REQ_FROM_PCIE_PASS_CMPL.REQ_OWN": {
	  "Box": "IIO",
	  "Category": "IIO ITC Events",
	  "Counters": "0-3",
	  "Defn": "Each PCIe request is broken down into a series of cacheline granular requests and each cacheline size request may need to make multiple passes through the pipeline (e.g. for posted interrupts or multi-cast).   Each time a cacheline completes a single pass (e.g. posts a write to single multi-cast target) it advances state",
	  "Desc": "PCIe Request - pass complete",
	  "EvSel": 144,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "For a normal write (no posted interrupt, no multi-cast) advance line = advance state",
	  "PortMask": "bxxxx11111111",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.SYMBOL_TIMES": {
	  "Box": "IIO",
	  "Category": "IIO Miscellaneous Events",
	  "Defn": "Gen1 - increment once every 4nS, Gen2 - increment once every 2nS, Gen3 - increment once every 1nS",
	  "Desc": "Symbol Times on Link",
	  "EvSel": 130,
	  "ExtSel": "",
     },
     "IIO.TXN_REQ_BY_CPU": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
     },
     "IIO.TXN_REQ_BY_CPU.IO_READ.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_WRITE.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_READ.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_READ.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.IO_WRITE.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_READ.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_WRITE.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_WRITE.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_WRITE.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_READ.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_WRITE.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_READ.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_WRITE.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_BY_CPU.IO_READ.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_WRITE.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_READ.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_WRITE.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_READ.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_WRITE.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_WRITE.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_READ.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_READ.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_BY_CPU.IO_READ.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_WRITE.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_BY_CPU.IO_READ.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_WRITE.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_BY_CPU.IO_WRITE.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.IO_READ.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_READ.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_WRITE.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_BY_CPU.IO_READ.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.IO_READ.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_READ.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_WRITE.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_READ.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_BY_CPU.IO_WRITE.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.IO_WRITE.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_READ.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_READ.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_WRITE.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_READ.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_READ.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_BY_CPU.IO_READ.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_WRITE.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_WRITE.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_READ.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_BY_CPU.IO_READ.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_WRITE.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_READ.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.IO_WRITE.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_WRITE.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_READ.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_BY_CPU.IO_WRITE.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_WRITE.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_READ.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_BY_CPU.IO_WRITE.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_READ.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_BY_CPU.IO_WRITE.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_READ.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_WRITE.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_WRITE.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_READ.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_READ.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_READ.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_WRITE.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_WRITE.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_READ.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_READ.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_WRITE.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_WRITE.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_READ.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_BY_CPU.IO_WRITE.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.IO_READ.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_WRITE.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_READ.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.CFG_WRITE.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_BY_CPU.IO_WRITE.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxx1xxxxx",
     },
     "IIO.TXN_REQ_BY_CPU.MEM_READ.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_BY_CPU.PEER_WRITE.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Outbound.  Number of requests initiated by the main die, including reads and writes.",
	  "Desc": "Number Transactions requested by the CPU",
	  "EvSel": 193,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions.  Peer R/W subevents do not include confined P2P traffic.   Peer R/W subevents are also counted as Mem R/W subevents.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_OF_CPU": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_WRITE.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_READ.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_OF_CPU.MSG.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_READ.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_WRITE.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_WRITE.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_OF_CPU.ATOMIC.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_WRITE.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_OF_CPU.ATOMIC.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_WRITE.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_READ.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_OF_CPU.CMPD.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_READ.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_WRITE.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_READ.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_WRITE.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_WRITE.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_READ.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_WRITE.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_OF_CPU.ATOMIC.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_READ.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_WRITE.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_OF_CPU.MSG.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_READ.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_OF_CPU.MSG.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.CMPD.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.MSG.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_WRITE.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_OF_CPU.ATOMIC.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_OF_CPU.CMPD.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_READ.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_READ.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_OF_CPU.CMPD.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.ATOMIC.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_OF_CPU.MSG.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_WRITE.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_READ.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_WRITE.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_READ.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_OF_CPU.ATOMIC.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_OF_CPU.CMPD.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_WRITE.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_READ.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_OF_CPU.MSG.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_WRITE.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_READ.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_OF_CPU.ATOMIC.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_OF_CPU.CMPD.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.CMPD.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_READ.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_READ.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_OF_CPU.MSG.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.MSG.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_READ.PART5": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxx1xxxxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_OF_CPU.MSG.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_WRITE.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_OF_CPU.ATOMIC.PART6": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxx1xxxxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_OF_CPU.CMPD.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_WRITE.IOMMU1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxx1xxxxxxxxx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_WRITE.PART7": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxx1xxxxxxx",
	  "Umask": "bxxxxxxx1",
     },
     "IIO.TXN_REQ_OF_CPU.ATOMIC.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_READ.PART3": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxx1xxx",
	  "Umask": "bxxxxx1xx",
     },
     "IIO.TXN_REQ_OF_CPU.CMPD.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.MSG.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bx1xxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_READ.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "bxxxx1xxx",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_WRITE.PART0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxxxx1",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_OF_CPU.ATOMIC.PART4": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxx1xxxx",
	  "Umask": "bxxx1xxxx",
     },
     "IIO.TXN_REQ_OF_CPU.CMPD.IOMMU0": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxx1xxxxxxxx",
	  "Umask": "b1xxxxxxx",
     },
     "IIO.TXN_REQ_OF_CPU.PEER_WRITE.PART2": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxx1xx",
	  "Umask": "bxxxxxx1x",
     },
     "IIO.TXN_REQ_OF_CPU.MEM_READ.PART1": {
	  "Box": "IIO",
	  "Category": "IIO Transaction Events",
	  "Counters": "0-3",
	  "Defn": "Also known as Inbound.  Number of 64B cache line requests initiated by the Card, including reads and writes.",
	  "Desc": "Number Transactions requested of the CPU",
	  "EvSel": 132,
	  "FCMask": "b111",
	  "ExtSel": "",
	  "Notes": "Unlike free running counters, Mem Read and Peer read subevents count requests not completions. Unlike the *_BY_CPU.PEER* events, peer R/W subevents do include confined P2P traffic.",
	  "PortMask": "bxxxxxxxxxx1x",
	  "Umask": "bxxxxx1xx",
     },

# iMC:
     "iMC.ACT_COUNT": {
	  "Box": "iMC",
	  "Category": "iMC ACT Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of DRAM Activate commands sent on this channel.  Activate commands are issued to open up a page on the DRAM devices so that it can be read or written to with a CAS.  One can calculate the number of Page Misses by subtracting the number of Page Miss precharges from the number of Activates.",
	  "Desc": "DRAM Activate Count",
	  "EvSel": 1,
	  "ExtSel": "",
     },
     "iMC.ACT_COUNT.ALL": {
	  "Box": "iMC",
	  "Category": "iMC ACT Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of DRAM Activate commands sent on this channel.  Activate commands are issued to open up a page on the DRAM devices so that it can be read or written to with a CAS.  One can calculate the number of Page Misses by subtracting the number of Page Miss precharges from the number of Activates.",
	  "Desc": "DRAM Activate Count",
	  "EvSel": 1,
	  "ExtSel": "",
	  "Umask": "b00001011",
     },
     "iMC.ACT_COUNT.BYP": {
	  "Box": "iMC",
	  "Category": "iMC ACT Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of DRAM Activate commands sent on this channel.  Activate commands are issued to open up a page on the DRAM devices so that it can be read or written to with a CAS.  One can calculate the number of Page Misses by subtracting the number of Page Miss precharges from the number of Activates.",
	  "Desc": "DRAM Activate Count",
	  "EvSel": 1,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "iMC.CAS_COUNT": {
	  "Box": "iMC",
	  "Category": "iMC CAS Events",
	  "Counters": "0-3",
	  "Defn": "DRAM RD_CAS and WR_CAS Commands",
	  "Desc": "DRAM RD_CAS and WR_CAS Commands.",
	  "EvSel": 4,
	  "ExtSel": "",
     },
     "iMC.CAS_COUNT.RD": {
	  "Box": "iMC",
	  "Category": "iMC CAS Events",
	  "Counters": "0-3",
	  "Defn": "DRAM RD_CAS and WR_CAS Commands",
	  "Desc": "DRAM RD_CAS and WR_CAS Commands.",
	  "EvSel": 4,
	  "ExtSel": "",
	  "Umask": "b00001111",
     },
     "iMC.CAS_COUNT.RD_REG": {
	  "Box": "iMC",
	  "Category": "iMC CAS Events",
	  "Counters": "0-3",
	  "Defn": "DRAM RD_CAS and WR_CAS Commands",
	  "Desc": "DRAM RD_CAS and WR_CAS Commands.",
	  "EvSel": 4,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.CAS_COUNT.WR": {
	  "Box": "iMC",
	  "Category": "iMC CAS Events",
	  "Counters": "0-3",
	  "Defn": "DRAM RD_CAS and WR_CAS Commands",
	  "Desc": "DRAM RD_CAS and WR_CAS Commands.",
	  "EvSel": 4,
	  "ExtSel": "",
	  "Umask": "b00110000",
     },
     "iMC.CAS_COUNT.RD_PRE_REG": {
	  "Box": "iMC",
	  "Category": "iMC CAS Events",
	  "Counters": "0-3",
	  "Defn": "DRAM RD_CAS and WR_CAS Commands",
	  "Desc": "DRAM RD_CAS and WR_CAS Commands.",
	  "EvSel": 4,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.CAS_COUNT.RD_UNDERFILL": {
	  "Box": "iMC",
	  "Category": "iMC CAS Events",
	  "Counters": "0-3",
	  "Defn": "DRAM RD_CAS and WR_CAS Commands",
	  "Desc": "DRAM RD_CAS and WR_CAS Commands.",
	  "EvSel": 4,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.CAS_COUNT.ALL": {
	  "Box": "iMC",
	  "Category": "iMC CAS Events",
	  "Counters": "0-3",
	  "Defn": "DRAM RD_CAS and WR_CAS Commands",
	  "Desc": "DRAM RD_CAS and WR_CAS Commands.",
	  "EvSel": 4,
	  "ExtSel": "",
	  "Umask": "b00111111",
     },
     "iMC.CAS_COUNT.RD_PRE_UNDERFILL": {
	  "Box": "iMC",
	  "Category": "iMC CAS Events",
	  "Counters": "0-3",
	  "Defn": "DRAM RD_CAS and WR_CAS Commands",
	  "Desc": "DRAM RD_CAS and WR_CAS Commands.",
	  "EvSel": 4,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "iMC.CAS_COUNT.WR_NONPRE": {
	  "Box": "iMC",
	  "Category": "iMC CAS Events",
	  "Counters": "0-3",
	  "Defn": "DRAM RD_CAS and WR_CAS Commands",
	  "Desc": "DRAM RD_CAS and WR_CAS Commands.",
	  "EvSel": 4,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "iMC.CAS_COUNT.WR_PRE": {
	  "Box": "iMC",
	  "Category": "iMC CAS Events",
	  "Counters": "0-3",
	  "Defn": "DRAM RD_CAS and WR_CAS Commands",
	  "Desc": "DRAM RD_CAS and WR_CAS Commands.",
	  "EvSel": 4,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "iMC.CLOCKTICKS": {
	  "Box": "iMC",
	  "Category": "iMC DCLK Events",
	  "Counters": "0-3",
	  "Desc": "DRAM Clockticks",
	  "EvSel": 0,
	  "ExtSel": "",
     },
     "iMC.DRAM_PRE_ALL": {
	  "Box": "iMC",
	  "Category": "iMC DRAM_PRE_ALL Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times that the precharge all command was sent.",
	  "Desc": "DRAM Precharge All Commands",
	  "EvSel": 68,
	  "ExtSel": "",
     },
     "iMC.DRAM_REFRESH": {
	  "Box": "iMC",
	  "Category": "iMC DRAM_REFRESH Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of refreshes issued.",
	  "Desc": "Number of DRAM Refreshes Issued",
	  "EvSel": 69,
	  "ExtSel": "",
     },
     "iMC.DRAM_REFRESH.PANIC": {
	  "Box": "iMC",
	  "Category": "iMC DRAM_REFRESH Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of refreshes issued.",
	  "Desc": "Number of DRAM Refreshes Issued",
	  "EvSel": 69,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.DRAM_REFRESH.HIGH": {
	  "Box": "iMC",
	  "Category": "iMC DRAM_REFRESH Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of refreshes issued.",
	  "Desc": "Number of DRAM Refreshes Issued",
	  "EvSel": 69,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.DRAM_REFRESH.OPPORTUNISTIC": {
	  "Box": "iMC",
	  "Category": "iMC DRAM_REFRESH Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of refreshes issued.",
	  "Desc": "Number of DRAM Refreshes Issued",
	  "EvSel": 69,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.PARITY_ERRORS": {
	  "Box": "iMC",
	  "Category": "iMC Error Events",
	  "EvSel": 44,
	  "ExtSel": "",
     },
     "iMC.PCLS": {
	  "Box": "iMC",
	  "Category": "iMC Debug Events",
	  "EvSel": 160,
	  "ExtSel": "",
     },
     "iMC.PCLS.WR": {
	  "Box": "iMC",
	  "Category": "iMC Debug Events",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.PCLS.RD": {
	  "Box": "iMC",
	  "Category": "iMC Debug Events",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.PCLS.TOTAL": {
	  "Box": "iMC",
	  "Category": "iMC Debug Events",
	  "EvSel": 160,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.PMM_CMD1": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands",
	  "EvSel": 234,
	  "ExtSel": "",
     },
     "iMC.PMM_CMD1.RD": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands",
	  "EvSel": 234,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.PMM_CMD1.RPQ_GNTS": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands",
	  "EvSel": 234,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "iMC.PMM_CMD1.MISC_GNT": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands",
	  "EvSel": 234,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "iMC.PMM_CMD1.WR": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands",
	  "EvSel": 234,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.PMM_CMD1.ALL": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands",
	  "EvSel": 234,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.PMM_CMD1.MISC": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands",
	  "EvSel": 234,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "iMC.PMM_CMD1.WPQ_GNTS": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands",
	  "EvSel": 234,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "iMC.PMM_CMD1.UFILL_RD": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands",
	  "EvSel": 234,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "iMC.PMM_CMD2": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands - Part 2",
	  "EvSel": 235,
	  "ExtSel": "",
     },
     "iMC.PMM_CMD2.NODATA_EXP": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands - Part 2",
	  "EvSel": 235,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.PMM_CMD2.REQS_SLOT0": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands - Part 2",
	  "EvSel": 235,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "iMC.PMM_CMD2.PMM_ERID_ERROR": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands - Part 2",
	  "EvSel": 235,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "iMC.PMM_CMD2.NODATA_UNEXP": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands - Part 2",
	  "EvSel": 235,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.PMM_CMD2.PMM_ECC_ERROR": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands - Part 2",
	  "EvSel": 235,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "iMC.PMM_CMD2.REQS_SLOT1": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands - Part 2",
	  "EvSel": 235,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "iMC.PMM_CMD2.OPP_RD": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands - Part 2",
	  "EvSel": 235,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.PMM_CMD2.PMM_ERID_STARVED": {
	  "Box": "iMC",
	  "Category": "iMC PMM CMD Events",
	  "Desc": "PMM Commands - Part 2",
	  "EvSel": 235,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "iMC.PMM_RPQ_CYCLES_FULL": {
	  "Box": "iMC",
	  "Category": "iMC PMM RPQ Events",
	  "Desc": "PMM Read Queue Cycles Full",
	  "EvSel": 226,
	  "ExtSel": "",
     },
     "iMC.PMM_RPQ_CYCLES_NE": {
	  "Box": "iMC",
	  "Category": "iMC PMM RPQ Events",
	  "Desc": "PMM Read Queue Cycles Not Empty",
	  "EvSel": 225,
	  "ExtSel": "",
     },
     "iMC.PMM_RPQ_INSERTS": {
	  "Box": "iMC",
	  "Category": "iMC PMM RPQ Events",
	  "Defn": "Counts number of read requests allocated in the PMM Read Pending Queue.   This includes both ISOCH and non-ISOCH requests.",
	  "Desc": "PMM Read Queue Inserts",
	  "EvSel": 227,
	  "ExtSel": "",
     },
     "iMC.PMM_RPQ_OCCUPANCY": {
	  "Box": "iMC",
	  "Category": "iMC PMM RPQ Events",
	  "Defn": "Accumulates the per cycle occupancy of the PMM Read Pending Queue.",
	  "Desc": "PMM Read Pending Queue Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "Dividing by Inserts provides the average latency entries were resident in the queue.  The HA must acquire a credit from the iMC to ensure the request will be accepted and queued.  The credit must be received by the HA before sending the request. The read queue entry is deallocated once the data has been transferred from the IXP DIMM",
     },
     "iMC.PMM_RPQ_OCCUPANCY.NO_GNT": {
	  "Box": "iMC",
	  "Category": "iMC PMM RPQ Events",
	  "Defn": "Accumulates the per cycle occupancy of the PMM Read Pending Queue.",
	  "Desc": "PMM Read Pending Queue Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "Dividing by Inserts provides the average latency entries were resident in the queue.  The HA must acquire a credit from the iMC to ensure the request will be accepted and queued.  The credit must be received by the HA before sending the request. The read queue entry is deallocated once the data has been transferred from the IXP DIMM",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.PMM_RPQ_OCCUPANCY.GNT_WAIT": {
	  "Box": "iMC",
	  "Category": "iMC PMM RPQ Events",
	  "Defn": "Accumulates the per cycle occupancy of the PMM Read Pending Queue.",
	  "Desc": "PMM Read Pending Queue Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "Dividing by Inserts provides the average latency entries were resident in the queue.  The HA must acquire a credit from the iMC to ensure the request will be accepted and queued.  The credit must be received by the HA before sending the request. The read queue entry is deallocated once the data has been transferred from the IXP DIMM",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.PMM_RPQ_OCCUPANCY.ALL": {
	  "Box": "iMC",
	  "Category": "iMC PMM RPQ Events",
	  "Defn": "Accumulates the per cycle occupancy of the PMM Read Pending Queue.",
	  "Desc": "PMM Read Pending Queue Occupancy",
	  "EvSel": 224,
	  "ExtSel": "",
	  "Notes": "Dividing by Inserts provides the average latency entries were resident in the queue.  The HA must acquire a credit from the iMC to ensure the request will be accepted and queued.  The credit must be received by the HA before sending the request. The read queue entry is deallocated once the data has been transferred from the IXP DIMM",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.PMM_WPQ_CYCLES_FULL": {
	  "Box": "iMC",
	  "Category": "iMC PMM WPQ Events",
	  "Desc": "PMM Write Queue Cycles Full",
	  "EvSel": 230,
	  "ExtSel": "",
     },
     "iMC.PMM_WPQ_CYCLES_NE": {
	  "Box": "iMC",
	  "Category": "iMC PMM WPQ Events",
	  "Desc": "PMM Write Queue Cycles Not Empty",
	  "EvSel": 229,
	  "ExtSel": "",
     },
     "iMC.PMM_WPQ_FLUSH": {
	  "Box": "iMC",
	  "Category": "iMC PMM WPQ Events",
	  "EvSel": 232,
	  "ExtSel": "",
     },
     "iMC.PMM_WPQ_FLUSH_CYC": {
	  "Box": "iMC",
	  "Category": "iMC PMM WPQ Events",
	  "EvSel": 233,
	  "ExtSel": "",
     },
     "iMC.PMM_WPQ_INSERTS": {
	  "Box": "iMC",
	  "Category": "iMC PMM WPQ Events",
	  "Defn": "Counts number of  write requests allocated in the PMM Write Pending Queue.",
	  "Desc": "PMM Write Queue Inserts",
	  "EvSel": 231,
	  "ExtSel": "",
     },
     "iMC.PMM_WPQ_OCCUPANCY": {
	  "Box": "iMC",
	  "Category": "iMC PMM WPQ Events",
	  "Defn": "Accumulates the per cycle occupancy of the PMM Write Pending Queue.",
	  "Desc": "PMM Write Pending Queue Occupancy",
	  "EvSel": 228,
	  "ExtSel": "",
	  "Notes": "Dividing by Inserts provides the average latency entries were resident in the queue.  The HA must acquire a credit from the iMC to ensure the request will be accepted and queued.  The credit must be received by the HA before sending the request. The write queue entry is deallocated once the iMC has ensured the data was transferred to the IXP DIMM.",
     },
     "iMC.PMM_WPQ_OCCUPANCY.ALL": {
	  "Box": "iMC",
	  "Category": "iMC PMM WPQ Events",
	  "Defn": "Accumulates the per cycle occupancy of the PMM Write Pending Queue.",
	  "Desc": "PMM Write Pending Queue Occupancy",
	  "EvSel": 228,
	  "ExtSel": "",
	  "Notes": "Dividing by Inserts provides the average latency entries were resident in the queue.  The HA must acquire a credit from the iMC to ensure the request will be accepted and queued.  The credit must be received by the HA before sending the request. The write queue entry is deallocated once the iMC has ensured the data was transferred to the IXP DIMM.",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.PMM_WPQ_OCCUPANCY.CAS": {
	  "Box": "iMC",
	  "Category": "iMC PMM WPQ Events",
	  "Defn": "Accumulates the per cycle occupancy of the PMM Write Pending Queue.",
	  "Desc": "PMM Write Pending Queue Occupancy",
	  "EvSel": 228,
	  "ExtSel": "",
	  "Notes": "Dividing by Inserts provides the average latency entries were resident in the queue.  The HA must acquire a credit from the iMC to ensure the request will be accepted and queued.  The credit must be received by the HA before sending the request. The write queue entry is deallocated once the iMC has ensured the data was transferred to the IXP DIMM.",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.PMM_WPQ_OCCUPANCY.PWR": {
	  "Box": "iMC",
	  "Category": "iMC PMM WPQ Events",
	  "Defn": "Accumulates the per cycle occupancy of the PMM Write Pending Queue.",
	  "Desc": "PMM Write Pending Queue Occupancy",
	  "EvSel": 228,
	  "ExtSel": "",
	  "Notes": "Dividing by Inserts provides the average latency entries were resident in the queue.  The HA must acquire a credit from the iMC to ensure the request will be accepted and queued.  The credit must be received by the HA before sending the request. The write queue entry is deallocated once the iMC has ensured the data was transferred to the IXP DIMM.",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.POWER_CHANNEL_PPD": {
	  "Box": "iMC",
	  "Category": "iMC POWER Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles when all the ranks in the channel are in PPD mode.  If IBT=off is enabled, then this can be used to count those cycles.  If it is not enabled, then this can count the number of cycles when that could have been taken advantage of.",
	  "Desc": "Channel PPD Cycles",
	  "EvSel": 133,
	  "ExtSel": "",
	  "MaxIncCyc": 4,
	  "Notes": "IBT = Input Buffer Termination = On",
     },
     "iMC.POWER_CKE_CYCLES": {
	  "Box": "iMC",
	  "Category": "iMC POWER Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles spent in CKE ON mode.  The filter allows you to select a rank to monitor.  If multiple ranks are in CKE ON mode at one time, the counter will ONLY increment by one rather than doing accumulation.  Multiple counters will need to be used to track multiple ranks simultaneously.  There is no distinction between the different CKE modes (APD, PPDS, PPDF).  This can be determined based on the system programming.  These events should commonly be used with Invert to get the number of cycles in power saving mode.  Edge Detect is also useful here.  Make sure that you do NOT use Invert with Edge Detect (this just confuses the system and is not necessary).",
	  "Desc": "CKE_ON_CYCLES by Rank",
	  "EvSel": 71,
	  "ExtSel": "",
	  "MaxIncCyc": 16,
     },
     "iMC.POWER_CKE_CYCLES.LOW_3": {
	  "Box": "iMC",
	  "Category": "iMC POWER Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles spent in CKE ON mode.  The filter allows you to select a rank to monitor.  If multiple ranks are in CKE ON mode at one time, the counter will ONLY increment by one rather than doing accumulation.  Multiple counters will need to be used to track multiple ranks simultaneously.  There is no distinction between the different CKE modes (APD, PPDS, PPDF).  This can be determined based on the system programming.  These events should commonly be used with Invert to get the number of cycles in power saving mode.  Edge Detect is also useful here.  Make sure that you do NOT use Invert with Edge Detect (this just confuses the system and is not necessary).",
	  "Desc": "CKE_ON_CYCLES by Rank",
	  "EvSel": 71,
	  "ExtSel": "",
	  "MaxIncCyc": 16,
	  "Umask": "b00001000",
     },
     "iMC.POWER_CKE_CYCLES.LOW_2": {
	  "Box": "iMC",
	  "Category": "iMC POWER Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles spent in CKE ON mode.  The filter allows you to select a rank to monitor.  If multiple ranks are in CKE ON mode at one time, the counter will ONLY increment by one rather than doing accumulation.  Multiple counters will need to be used to track multiple ranks simultaneously.  There is no distinction between the different CKE modes (APD, PPDS, PPDF).  This can be determined based on the system programming.  These events should commonly be used with Invert to get the number of cycles in power saving mode.  Edge Detect is also useful here.  Make sure that you do NOT use Invert with Edge Detect (this just confuses the system and is not necessary).",
	  "Desc": "CKE_ON_CYCLES by Rank",
	  "EvSel": 71,
	  "ExtSel": "",
	  "MaxIncCyc": 16,
	  "Umask": "b00000100",
     },
     "iMC.POWER_CKE_CYCLES.LOW_0": {
	  "Box": "iMC",
	  "Category": "iMC POWER Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles spent in CKE ON mode.  The filter allows you to select a rank to monitor.  If multiple ranks are in CKE ON mode at one time, the counter will ONLY increment by one rather than doing accumulation.  Multiple counters will need to be used to track multiple ranks simultaneously.  There is no distinction between the different CKE modes (APD, PPDS, PPDF).  This can be determined based on the system programming.  These events should commonly be used with Invert to get the number of cycles in power saving mode.  Edge Detect is also useful here.  Make sure that you do NOT use Invert with Edge Detect (this just confuses the system and is not necessary).",
	  "Desc": "CKE_ON_CYCLES by Rank",
	  "EvSel": 71,
	  "ExtSel": "",
	  "MaxIncCyc": 16,
	  "Umask": "b00000001",
     },
     "iMC.POWER_CKE_CYCLES.LOW_1": {
	  "Box": "iMC",
	  "Category": "iMC POWER Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles spent in CKE ON mode.  The filter allows you to select a rank to monitor.  If multiple ranks are in CKE ON mode at one time, the counter will ONLY increment by one rather than doing accumulation.  Multiple counters will need to be used to track multiple ranks simultaneously.  There is no distinction between the different CKE modes (APD, PPDS, PPDF).  This can be determined based on the system programming.  These events should commonly be used with Invert to get the number of cycles in power saving mode.  Edge Detect is also useful here.  Make sure that you do NOT use Invert with Edge Detect (this just confuses the system and is not necessary).",
	  "Desc": "CKE_ON_CYCLES by Rank",
	  "EvSel": 71,
	  "ExtSel": "",
	  "MaxIncCyc": 16,
	  "Umask": "b00000010",
     },
     "iMC.POWER_CRIT_THROTTLE_CYCLES": {
	  "Box": "iMC",
	  "Category": "iMC POWER Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles while the iMC is being throttled by either thermal constraints or by the PCU throttling.  It is not possible to distinguish between the two.  This can be filtered by rank.  If multiple ranks are selected and are being throttled at the same time, the counter will only increment by 1.",
	  "Desc": "Throttle Cycles for Rank 0",
	  "EvSel": 134,
	  "ExtSel": "",
     },
     "iMC.POWER_CRIT_THROTTLE_CYCLES.SLOT0": {
	  "Box": "iMC",
	  "Category": "iMC POWER Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles while the iMC is being throttled by either thermal constraints or by the PCU throttling.  It is not possible to distinguish between the two.  This can be filtered by rank.  If multiple ranks are selected and are being throttled at the same time, the counter will only increment by 1.",
	  "Desc": "Throttle Cycles for Rank 0",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.POWER_CRIT_THROTTLE_CYCLES.SLOT1": {
	  "Box": "iMC",
	  "Category": "iMC POWER Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles while the iMC is being throttled by either thermal constraints or by the PCU throttling.  It is not possible to distinguish between the two.  This can be filtered by rank.  If multiple ranks are selected and are being throttled at the same time, the counter will only increment by 1.",
	  "Desc": "Throttle Cycles for Rank 0",
	  "EvSel": 134,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.POWER_SELF_REFRESH": {
	  "Box": "iMC",
	  "Category": "iMC POWER Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the iMC is in self-refresh and the iMC still has a clock.  This happens in some package C-states.  For example, the PCU may ask the iMC to enter self-refresh even though some of the cores are still processing.  One use of this is for Monroe technology.  Self-refresh is required during package C3 and C6, but there is no clock in the iMC at this time, so it is not possible to count these cases.",
	  "Desc": "Clock-Enabled Self-Refresh",
	  "EvSel": 67,
	  "ExtSel": "",
     },
     "iMC.POWER_THROTTLE_CYCLES": {
	  "Box": "iMC",
	  "Category": "iMC POWER Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles while the iMC is being throttled by either thermal constraints or by the PCU throttling.  It is not possible to distinguish between the two.  This can be filtered by rank.  If multiple ranks are selected and are being throttled at the same time, the counter will only increment by 1.",
	  "Desc": "Throttle Cycles for Rank 0",
	  "EvSel": 70,
	  "ExtSel": "",
     },
     "iMC.POWER_THROTTLE_CYCLES.SLOT0": {
	  "Box": "iMC",
	  "Category": "iMC POWER Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles while the iMC is being throttled by either thermal constraints or by the PCU throttling.  It is not possible to distinguish between the two.  This can be filtered by rank.  If multiple ranks are selected and are being throttled at the same time, the counter will only increment by 1.",
	  "Desc": "Throttle Cycles for Rank 0",
	  "EvSel": 70,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.POWER_THROTTLE_CYCLES.SLOT1": {
	  "Box": "iMC",
	  "Category": "iMC POWER Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles while the iMC is being throttled by either thermal constraints or by the PCU throttling.  It is not possible to distinguish between the two.  This can be filtered by rank.  If multiple ranks are selected and are being throttled at the same time, the counter will only increment by 1.",
	  "Desc": "Throttle Cycles for Rank 0",
	  "EvSel": 70,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.PRE_COUNT": {
	  "Box": "iMC",
	  "Category": "iMC PRE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of DRAM Precharge commands sent on this channel.",
	  "Desc": "DRAM Precharge commands.",
	  "EvSel": 2,
	  "ExtSel": "",
     },
     "iMC.PRE_COUNT.PAGE_MISS": {
	  "Box": "iMC",
	  "Category": "iMC PRE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of DRAM Precharge commands sent on this channel.",
	  "Desc": "DRAM Precharge commands.",
	  "EvSel": 2,
	  "ExtSel": "",
	  "Umask": "bxxxx11xx",
     },
     "iMC.PRE_COUNT.RD": {
	  "Box": "iMC",
	  "Category": "iMC PRE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of DRAM Precharge commands sent on this channel.",
	  "Desc": "DRAM Precharge commands.",
	  "EvSel": 2,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.PRE_COUNT.WR": {
	  "Box": "iMC",
	  "Category": "iMC PRE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of DRAM Precharge commands sent on this channel.",
	  "Desc": "DRAM Precharge commands.",
	  "EvSel": 2,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "iMC.PRE_COUNT.PGT": {
	  "Box": "iMC",
	  "Category": "iMC PRE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of DRAM Precharge commands sent on this channel.",
	  "Desc": "DRAM Precharge commands.",
	  "EvSel": 2,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "iMC.PRE_COUNT.ALL": {
	  "Box": "iMC",
	  "Category": "iMC PRE Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of DRAM Precharge commands sent on this channel.",
	  "Desc": "DRAM Precharge commands.",
	  "EvSel": 2,
	  "ExtSel": "",
	  "Umask": "b00011100",
     },
     "iMC.RDB_FULL": {
	  "Box": "iMC",
	  "Category": "iMC RDB Events",
	  "Counters": "0-3",
	  "Desc": "Read Data Buffer Full",
	  "EvSel": 25,
	  "ExtSel": "",
     },
     "iMC.RDB_INSERTS": {
	  "Box": "iMC",
	  "Category": "iMC RDB Events",
	  "Counters": "0-3",
	  "Desc": "Read Data Buffer Inserts",
	  "EvSel": 23,
	  "ExtSel": "",
     },
     "iMC.RDB_NOT_EMPTY": {
	  "Box": "iMC",
	  "Category": "iMC RDB Events",
	  "Counters": "0-3",
	  "Desc": "Read Data Buffer Not Empty",
	  "EvSel": 24,
	  "ExtSel": "",
     },
     "iMC.RDB_OCCUPANCY": {
	  "Box": "iMC",
	  "Category": "iMC RDB Events",
	  "Counters": "0-3",
	  "Desc": "Read Data Buffer Occupancy",
	  "EvSel": 26,
	  "ExtSel": "",
     },
     "iMC.RPQ_CYCLES_FULL_PCH0": {
	  "Box": "iMC",
	  "Category": "iMC RPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the Read Pending Queue is full.  When the RPQ is full, the HA will not be able to issue any additional read requests into the iMC.  This count should be similar count in the HA which tracks the number of cycles that the HA has no RPQ credits, just somewhat smaller to account for the credit return overhead.  We generally do not expect to see RPQ become full except for potentially during Write Major Mode or while running with slow DRAM.  This event only tracks non-ISOC queue entries.",
	  "Desc": "Read Pending Queue Full Cycles",
	  "EvSel": 18,
	  "ExtSel": "",
     },
     "iMC.RPQ_CYCLES_FULL_PCH1": {
	  "Box": "iMC",
	  "Category": "iMC RPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the Read Pending Queue is full.  When the RPQ is full, the HA will not be able to issue any additional read requests into the iMC.  This count should be similar count in the HA which tracks the number of cycles that the HA has no RPQ credits, just somewhat smaller to account for the credit return overhead.  We generally do not expect to see RPQ become full except for potentially during Write Major Mode or while running with slow DRAM.  This event only tracks non-ISOC queue entries.",
	  "Desc": "Read Pending Queue Full Cycles",
	  "EvSel": 21,
	  "ExtSel": "",
     },
     "iMC.RPQ_CYCLES_NE": {
	  "Box": "iMC",
	  "Category": "iMC RPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles that the Read Pending Queue is not empty.  This can then be used to calculate the average occupancy (in conjunction with the Read Pending Queue Occupancy count).  The RPQ is used to schedule reads out to the memory controller and to track the requests.  Requests allocate into the RPQ soon after they enter the memory controller, and need credits for an entry in this buffer before being sent from the HA to the iMC.  They deallocate after the CAS command has been issued to memory.  This filter is to be used in conjunction with the occupancy filter so that one can correctly track the average occupancies for schedulable entries and scheduled requests.",
	  "Desc": "Read Pending Queue Not Empty",
	  "EvSel": 17,
	  "ExtSel": "",
     },
     "iMC.RPQ_CYCLES_NE.PCH1": {
	  "Box": "iMC",
	  "Category": "iMC RPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles that the Read Pending Queue is not empty.  This can then be used to calculate the average occupancy (in conjunction with the Read Pending Queue Occupancy count).  The RPQ is used to schedule reads out to the memory controller and to track the requests.  Requests allocate into the RPQ soon after they enter the memory controller, and need credits for an entry in this buffer before being sent from the HA to the iMC.  They deallocate after the CAS command has been issued to memory.  This filter is to be used in conjunction with the occupancy filter so that one can correctly track the average occupancies for schedulable entries and scheduled requests.",
	  "Desc": "Read Pending Queue Not Empty",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.RPQ_CYCLES_NE.PCH0": {
	  "Box": "iMC",
	  "Category": "iMC RPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles that the Read Pending Queue is not empty.  This can then be used to calculate the average occupancy (in conjunction with the Read Pending Queue Occupancy count).  The RPQ is used to schedule reads out to the memory controller and to track the requests.  Requests allocate into the RPQ soon after they enter the memory controller, and need credits for an entry in this buffer before being sent from the HA to the iMC.  They deallocate after the CAS command has been issued to memory.  This filter is to be used in conjunction with the occupancy filter so that one can correctly track the average occupancies for schedulable entries and scheduled requests.",
	  "Desc": "Read Pending Queue Not Empty",
	  "EvSel": 17,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.RPQ_INSERTS": {
	  "Box": "iMC",
	  "Category": "iMC RPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the Read Pending Queue.  This queue is used to schedule reads out to the memory controller and to track the requests.  Requests allocate into the RPQ soon after they enter the memory controller, and need credits for an entry in this buffer before being sent from the HA to the iMC.  They deallocate after the CAS command has been issued to memory.  This includes both ISOCH and non-ISOCH requests.",
	  "Desc": "Read Pending Queue Allocations",
	  "EvSel": 16,
	  "ExtSel": "",
     },
     "iMC.RPQ_INSERTS.PCH0": {
	  "Box": "iMC",
	  "Category": "iMC RPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the Read Pending Queue.  This queue is used to schedule reads out to the memory controller and to track the requests.  Requests allocate into the RPQ soon after they enter the memory controller, and need credits for an entry in this buffer before being sent from the HA to the iMC.  They deallocate after the CAS command has been issued to memory.  This includes both ISOCH and non-ISOCH requests.",
	  "Desc": "Read Pending Queue Allocations",
	  "EvSel": 16,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.RPQ_INSERTS.PCH1": {
	  "Box": "iMC",
	  "Category": "iMC RPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the Read Pending Queue.  This queue is used to schedule reads out to the memory controller and to track the requests.  Requests allocate into the RPQ soon after they enter the memory controller, and need credits for an entry in this buffer before being sent from the HA to the iMC.  They deallocate after the CAS command has been issued to memory.  This includes both ISOCH and non-ISOCH requests.",
	  "Desc": "Read Pending Queue Allocations",
	  "EvSel": 16,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.RPQ_OCCUPANCY_PCH0": {
	  "Box": "iMC",
	  "Category": "iMC RPQ Events",
	  "Counters": "0-3",
	  "Defn": "Accumulates the occupancies of the Read Pending Queue each cycle.  This can then be used to calculate both the average occupancy (in conjunction with the number of cycles not empty) and the average latency (in conjunction with the number of allocations).  The RPQ is used to schedule reads out to the memory controller and to track the requests.  Requests allocate into the RPQ soon after they enter the memory controller, and need credits for an entry in this buffer before being sent from the HA to the iMC. They deallocate after the CAS command has been issued to memory.",
	  "Desc": "Read Pending Queue Occupancy",
	  "EvSel": 128,
	  "ExtSel": "",
	  "MaxIncCyc": 22,
     },
     "iMC.RPQ_OCCUPANCY_PCH1": {
	  "Box": "iMC",
	  "Category": "iMC RPQ Events",
	  "Counters": "0-3",
	  "Defn": "Accumulates the occupancies of the Read Pending Queue each cycle.  This can then be used to calculate both the average occupancy (in conjunction with the number of cycles not empty) and the average latency (in conjunction with the number of allocations).  The RPQ is used to schedule reads out to the memory controller and to track the requests.  Requests allocate into the RPQ soon after they enter the memory controller, and need credits for an entry in this buffer before being sent from the HA to the iMC. They deallocate after the CAS command has been issued to memory.",
	  "Desc": "Read Pending Queue Occupancy",
	  "EvSel": 129,
	  "ExtSel": "",
	  "MaxIncCyc": 22,
     },
     "iMC.SB_ACCESSES": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Accesses",
	  "EvSel": 210,
	  "ExtSel": "",
     },
     "iMC.SB_ACCESSES.FM_WR_CMPS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Accesses",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "iMC.SB_ACCESSES.REJECTS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Accesses",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "b00001010",
     },
     "iMC.SB_ACCESSES.ACCEPTS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Accesses",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "b00000101",
     },
     "iMC.SB_ACCESSES.NM_RD_CMPS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Accesses",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "iMC.SB_ACCESSES.WR_ACCEPTS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Accesses",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.SB_ACCESSES.NM_WR_CMPS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Accesses",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "iMC.SB_ACCESSES.RD_REJECTS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Accesses",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.SB_ACCESSES.RD_ACCEPTS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Accesses",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.SB_ACCESSES.FM_RD_CMPS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Accesses",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "iMC.SB_ACCESSES.WR_REJECTS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Accesses",
	  "EvSel": 210,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "iMC.SB_CANARY": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 217,
	  "ExtSel": "",
     },
     "iMC.SB_CANARY.ALLOC": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 217,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.SB_CANARY.FM_RD_STARVED": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 217,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "iMC.SB_CANARY.NM_WR_STARVED": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 217,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "iMC.SB_CANARY.FM_TGR_WR_STARVED": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 217,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "iMC.SB_CANARY.VLD": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 217,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.SB_CANARY.NM_RD_STARVED": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 217,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "iMC.SB_CANARY.FM_WR_STARVED": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 217,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "iMC.SB_CANARY.DEALLOC": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 217,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.SB_CYCLES_FULL": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Cycles Full",
	  "EvSel": 209,
	  "ExtSel": "",
     },
     "iMC.SB_CYCLES_NE": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Cycles Not-Empty",
	  "EvSel": 208,
	  "ExtSel": "",
     },
     "iMC.SB_INSERTS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Inserts",
	  "EvSel": 214,
	  "ExtSel": "",
     },
     "iMC.SB_INSERTS.RDS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Inserts",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.SB_INSERTS.PMM_RDS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Inserts",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.SB_INSERTS.WRS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Inserts",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.SB_INSERTS.PMM_WRS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Inserts",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "iMC.SB_INSERTS.BLOCK_WRS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Inserts",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "iMC.SB_INSERTS.BLOCK_RDS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Inserts",
	  "EvSel": 214,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "iMC.SB_OCCUPANCY": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Occupancy",
	  "EvSel": 213,
	  "ExtSel": "",
	  "MaxIncCyc": 128,
     },
     "iMC.SB_OCCUPANCY.PMM_WRS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Occupancy",
	  "EvSel": 213,
	  "ExtSel": "",
	  "MaxIncCyc": 128,
	  "Umask": "bxxxx1xxx",
     },
     "iMC.SB_OCCUPANCY.BLOCK_RDS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Occupancy",
	  "EvSel": 213,
	  "ExtSel": "",
	  "MaxIncCyc": 128,
	  "Umask": "bxx1xxxxx",
     },
     "iMC.SB_OCCUPANCY.BLOCK_WRS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Occupancy",
	  "EvSel": 213,
	  "ExtSel": "",
	  "MaxIncCyc": 128,
	  "Umask": "bx1xxxxxx",
     },
     "iMC.SB_OCCUPANCY.PMM_RDS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Occupancy",
	  "EvSel": 213,
	  "ExtSel": "",
	  "MaxIncCyc": 128,
	  "Umask": "bxxxxx1xx",
     },
     "iMC.SB_OCCUPANCY.RDS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Occupancy",
	  "EvSel": 213,
	  "ExtSel": "",
	  "MaxIncCyc": 128,
	  "Umask": "bxxxxxxx1",
     },
     "iMC.SB_PREF_INSERTS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Prefetch Inserts",
	  "EvSel": 218,
	  "ExtSel": "",
     },
     "iMC.SB_PREF_INSERTS.PMM": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Prefetch Inserts",
	  "EvSel": 218,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.SB_PREF_INSERTS.DDR": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Prefetch Inserts",
	  "EvSel": 218,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.SB_PREF_INSERTS.ALL": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Prefetch Inserts",
	  "EvSel": 218,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.SB_PREF_OCCUPANCY": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Prefetch Occupancy",
	  "EvSel": 219,
	  "ExtSel": "",
     },
     "iMC.SB_PREF_OCCUPANCY.DDR": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Prefetch Occupancy",
	  "EvSel": 219,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.SB_PREF_OCCUPANCY.PMM": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Prefetch Occupancy",
	  "EvSel": 219,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.SB_PREF_OCCUPANCY.ALL": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "Desc": "Scoreboard Prefetch Occupancy",
	  "EvSel": 219,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.SB_REJECT": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE COHERENCY Events",
	  "Counters": "0-3",
	  "Desc": "Number of Scoreboard Requests Rejected",
	  "EvSel": 212,
	  "ExtSel": "",
     },
     "iMC.SB_REJECT.PATROL_SET_CNFLT": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE COHERENCY Events",
	  "Counters": "0-3",
	  "Desc": "Number of Scoreboard Requests Rejected",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.SB_REJECT.NM_SET_CNFLT": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE COHERENCY Events",
	  "Counters": "0-3",
	  "Desc": "Number of Scoreboard Requests Rejected",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.SB_REJECT.FM_ADDR_CNFLT": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE COHERENCY Events",
	  "Counters": "0-3",
	  "Desc": "Number of Scoreboard Requests Rejected",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.SB_REJECT.CANARY": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE COHERENCY Events",
	  "Counters": "0-3",
	  "Desc": "Number of Scoreboard Requests Rejected",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "iMC.SB_REJECT.DDR_EARLY_CMP": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE COHERENCY Events",
	  "Counters": "0-3",
	  "Desc": "Number of Scoreboard Requests Rejected",
	  "EvSel": 212,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "iMC.SB_STRV_ALLOC": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 215,
	  "ExtSel": "",
     },
     "iMC.SB_STRV_ALLOC.FM_RD": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.SB_STRV_ALLOC.NM_RD": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.SB_STRV_ALLOC.FM_TGR": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "iMC.SB_STRV_ALLOC.FM_WR": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "iMC.SB_STRV_ALLOC.NM_WR": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 215,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.SB_STRV_DEALLOC": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 222,
	  "ExtSel": "",
     },
     "iMC.SB_STRV_DEALLOC.FM_TGR": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 222,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "iMC.SB_STRV_DEALLOC.NM_RD": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 222,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.SB_STRV_DEALLOC.FM_RD": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 222,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.SB_STRV_DEALLOC.NM_WR": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 222,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.SB_STRV_DEALLOC.FM_WR": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 222,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "iMC.SB_STRV_OCC": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 216,
	  "ExtSel": "",
	  "MaxIncCyc": 63,
     },
     "iMC.SB_STRV_OCC.FM_TGR": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 216,
	  "ExtSel": "",
	  "MaxIncCyc": 63,
	  "Umask": "bxxx1xxxx",
     },
     "iMC.SB_STRV_OCC.NM_RD": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 216,
	  "ExtSel": "",
	  "MaxIncCyc": 63,
	  "Umask": "bxxxxxxx1",
     },
     "iMC.SB_STRV_OCC.FM_RD": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 216,
	  "ExtSel": "",
	  "MaxIncCyc": 63,
	  "Umask": "bxxxxxx1x",
     },
     "iMC.SB_STRV_OCC.NM_WR": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 216,
	  "ExtSel": "",
	  "MaxIncCyc": 63,
	  "Umask": "bxxxxx1xx",
     },
     "iMC.SB_STRV_OCC.FM_WR": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "Counters": "0-3",
	  "EvSel": 216,
	  "ExtSel": "",
	  "MaxIncCyc": 63,
	  "Umask": "bxxxx1xxx",
     },
     "iMC.SB_TAGGED": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "EvSel": 221,
	  "ExtSel": "",
     },
     "iMC.SB_TAGGED.RD_MISS": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "EvSel": 221,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.SB_TAGGED.OCC": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "EvSel": 221,
	  "ExtSel": "",
	  "Umask": "b1xxxxxxx",
     },
     "iMC.SB_TAGGED.RD_HIT": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "EvSel": 221,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.SB_TAGGED.DDR4_CMP": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "EvSel": 221,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "iMC.SB_TAGGED.PMM0_CMP": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "EvSel": 221,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "iMC.SB_TAGGED.PMM1_CMP": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "EvSel": 221,
	  "ExtSel": "",
	  "Umask": "bxx1xxxxx",
     },
     "iMC.SB_TAGGED.NEW": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "EvSel": 221,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.SB_TAGGED.PMM2_CMP": {
	  "Box": "iMC",
	  "Category": "iMC PMM MEMMODE SCOREBOARD Events",
	  "EvSel": 221,
	  "ExtSel": "",
	  "Umask": "bx1xxxxxx",
     },
     "iMC.TAGCHK": {
	  "Box": "iMC",
	  "Category": "iMC TAG CHECK Events",
	  "Counters": "0-3",
	  "Desc": "2LM Tag Check",
	  "EvSel": 211,
	  "ExtSel": "",
     },
     "iMC.TAGCHK.NM_WR_HIT": {
	  "Box": "iMC",
	  "Category": "iMC TAG CHECK Events",
	  "Counters": "0-3",
	  "Desc": "2LM Tag Check",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Umask": "bxxx1xxxx",
     },
     "iMC.TAGCHK.MISS_CLEAN": {
	  "Box": "iMC",
	  "Category": "iMC TAG CHECK Events",
	  "Counters": "0-3",
	  "Desc": "2LM Tag Check",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.TAGCHK.MISS_DIRTY": {
	  "Box": "iMC",
	  "Category": "iMC TAG CHECK Events",
	  "Counters": "0-3",
	  "Desc": "2LM Tag Check",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Umask": "bxxxxx1xx",
     },
     "iMC.TAGCHK.HIT": {
	  "Box": "iMC",
	  "Category": "iMC TAG CHECK Events",
	  "Counters": "0-3",
	  "Desc": "2LM Tag Check",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.TAGCHK.NM_RD_HIT": {
	  "Box": "iMC",
	  "Category": "iMC TAG CHECK Events",
	  "Counters": "0-3",
	  "Desc": "2LM Tag Check",
	  "EvSel": 211,
	  "ExtSel": "",
	  "Umask": "bxxxx1xxx",
     },
     "iMC.WPQ_CYCLES_FULL_PCH0": {
	  "Box": "iMC",
	  "Category": "iMC WPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the Write Pending Queue is full.  When the WPQ is full, the HA will not be able to issue any additional write requests into the iMC.  This count should be similar count in the CHA which tracks the number of cycles that the CHA has no WPQ credits, just somewhat smaller to account for the credit return overhead.",
	  "Desc": "Write Pending Queue Full Cycles",
	  "EvSel": 34,
	  "ExtSel": "",
     },
     "iMC.WPQ_CYCLES_FULL_PCH1": {
	  "Box": "iMC",
	  "Category": "iMC WPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the Write Pending Queue is full.  When the WPQ is full, the HA will not be able to issue any additional write requests into the iMC.  This count should be similar count in the CHA which tracks the number of cycles that the CHA has no WPQ credits, just somewhat smaller to account for the credit return overhead.",
	  "Desc": "Write Pending Queue Full Cycles",
	  "EvSel": 22,
	  "ExtSel": "",
     },
     "iMC.WPQ_CYCLES_NE": {
	  "Box": "iMC",
	  "Category": "iMC WPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles that the Write Pending Queue is not empty.  This can then be used to calculate the average queue occupancy (in conjunction with the WPQ Occupancy Accumulation count).  The WPQ is used to schedule write out to the memory controller and to track the writes.  Requests allocate into the WPQ soon after they enter the memory controller, and need credits for an entry in this buffer before being sent from the CHA to the iMC.  They deallocate after being issued to DRAM.  Write requests themselves are able to complete (from the perspective of the rest of the system) as soon they have \"posted\" to the iMC.  This is not to be confused with actually performing the write to DRAM.  Therefore, the average latency for this queue is actually not useful for deconstruction intermediate write latencies.",
	  "Desc": "Write Pending Queue Not Empty",
	  "EvSel": 33,
	  "ExtSel": "",
     },
     "iMC.WPQ_CYCLES_NE.PCH0": {
	  "Box": "iMC",
	  "Category": "iMC WPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles that the Write Pending Queue is not empty.  This can then be used to calculate the average queue occupancy (in conjunction with the WPQ Occupancy Accumulation count).  The WPQ is used to schedule write out to the memory controller and to track the writes.  Requests allocate into the WPQ soon after they enter the memory controller, and need credits for an entry in this buffer before being sent from the CHA to the iMC.  They deallocate after being issued to DRAM.  Write requests themselves are able to complete (from the perspective of the rest of the system) as soon they have \"posted\" to the iMC.  This is not to be confused with actually performing the write to DRAM.  Therefore, the average latency for this queue is actually not useful for deconstruction intermediate write latencies.",
	  "Desc": "Write Pending Queue Not Empty",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.WPQ_CYCLES_NE.PCH1": {
	  "Box": "iMC",
	  "Category": "iMC WPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles that the Write Pending Queue is not empty.  This can then be used to calculate the average queue occupancy (in conjunction with the WPQ Occupancy Accumulation count).  The WPQ is used to schedule write out to the memory controller and to track the writes.  Requests allocate into the WPQ soon after they enter the memory controller, and need credits for an entry in this buffer before being sent from the CHA to the iMC.  They deallocate after being issued to DRAM.  Write requests themselves are able to complete (from the perspective of the rest of the system) as soon they have \"posted\" to the iMC.  This is not to be confused with actually performing the write to DRAM.  Therefore, the average latency for this queue is actually not useful for deconstruction intermediate write latencies.",
	  "Desc": "Write Pending Queue Not Empty",
	  "EvSel": 33,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.WPQ_INSERTS": {
	  "Box": "iMC",
	  "Category": "iMC WPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the Write Pending Queue.  This can then be used to calculate the average queuing latency (in conjunction with the WPQ occupancy count).  The WPQ is used to schedule write out to the memory controller and to track the writes.  Requests allocate into the WPQ soon after they enter the memory controller, and need credits for an entry in this buffer before being sent from the CHA to the iMC.  They deallocate after being issued to DRAM.  Write requests themselves are able to complete (from the perspective of the rest of the system) as soon they have \"posted\" to the iMC.",
	  "Desc": "Write Pending Queue Allocations",
	  "EvSel": 32,
	  "ExtSel": "",
     },
     "iMC.WPQ_INSERTS.PCH1": {
	  "Box": "iMC",
	  "Category": "iMC WPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the Write Pending Queue.  This can then be used to calculate the average queuing latency (in conjunction with the WPQ occupancy count).  The WPQ is used to schedule write out to the memory controller and to track the writes.  Requests allocate into the WPQ soon after they enter the memory controller, and need credits for an entry in this buffer before being sent from the CHA to the iMC.  They deallocate after being issued to DRAM.  Write requests themselves are able to complete (from the perspective of the rest of the system) as soon they have \"posted\" to the iMC.",
	  "Desc": "Write Pending Queue Allocations",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.WPQ_INSERTS.PCH0": {
	  "Box": "iMC",
	  "Category": "iMC WPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of allocations into the Write Pending Queue.  This can then be used to calculate the average queuing latency (in conjunction with the WPQ occupancy count).  The WPQ is used to schedule write out to the memory controller and to track the writes.  Requests allocate into the WPQ soon after they enter the memory controller, and need credits for an entry in this buffer before being sent from the CHA to the iMC.  They deallocate after being issued to DRAM.  Write requests themselves are able to complete (from the perspective of the rest of the system) as soon they have \"posted\" to the iMC.",
	  "Desc": "Write Pending Queue Allocations",
	  "EvSel": 32,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.WPQ_OCCUPANCY_PCH0": {
	  "Box": "iMC",
	  "Category": "iMC WPQ Events",
	  "Counters": "0-3",
	  "Defn": "Accumulates the occupancies of the Write Pending Queue each cycle.  This can then be used to calculate both the average queue occupancy (in conjunction with the number of cycles not empty) and the average latency (in conjunction with the number of allocations).  The WPQ is used to schedule write out to the memory controller and to track the writes.  Requests allocate into the WPQ soon after they enter the memory controller, and need credits for an entry in this buffer before being sent from the HA to the iMC.  They deallocate after being issued to DRAM.  Write requests themselves are able to complete (from the perspective of the rest of the system) as soon they have \"posted\" to the iMC.  This is not to be confused with actually performing the write to DRAM.  Therefore, the average latency for this queue is actually not useful for deconstruction intermediate write latencies.  So, we provide filtering based on if the request has posted or not.  By using the \"not posted\" filter, we can track how long writes spent in the iMC before completions were sent to the HA.  The \"posted\" filter, on the other hand, provides information about how much queueing is actually happenning in the iMC for writes before they are actually issued to memory.  High average occupancies will generally coincide with high write major mode counts.",
	  "Desc": "Write Pending Queue Occupancy",
	  "EvSel": 130,
	  "ExtSel": "",
	  "MaxIncCyc": 40,
     },
     "iMC.WPQ_OCCUPANCY_PCH1": {
	  "Box": "iMC",
	  "Category": "iMC WPQ Events",
	  "Counters": "0-3",
	  "Defn": "Accumulates the occupancies of the Write Pending Queue each cycle.  This can then be used to calculate both the average queue occupancy (in conjunction with the number of cycles not empty) and the average latency (in conjunction with the number of allocations).  The WPQ is used to schedule write out to the memory controller and to track the writes.  Requests allocate into the WPQ soon after they enter the memory controller, and need credits for an entry in this buffer before being sent from the HA to the iMC.  They deallocate after being issued to DRAM.  Write requests themselves are able to complete (from the perspective of the rest of the system) as soon they have \"posted\" to the iMC.  This is not to be confused with actually performing the write to DRAM.  Therefore, the average latency for this queue is actually not useful for deconstruction intermediate write latencies.  So, we provide filtering based on if the request has posted or not.  By using the \"not posted\" filter, we can track how long writes spent in the iMC before completions were sent to the HA.  The \"posted\" filter, on the other hand, provides information about how much queueing is actually happenning in the iMC for writes before they are actually issued to memory.  High average occupancies will generally coincide with high write major mode counts.",
	  "Desc": "Write Pending Queue Occupancy",
	  "EvSel": 131,
	  "ExtSel": "",
	  "MaxIncCyc": 40,
     },
     "iMC.WPQ_READ_HIT": {
	  "Box": "iMC",
	  "Category": "iMC WPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times a request hits in the WPQ (write-pending queue).  The iMC allows writes and reads to pass up other writes to different addresses.  Before a read or a write is issued, it will first CAM the WPQ to see if there is a write pending to that address.  When reads hit, they are able to directly pull their data from the WPQ instead of going to memory.  Writes that hit will overwrite the existing data.  Partial writes that hit will not need to do underfill reads and will simply update their relevant sections.",
	  "Desc": "Write Pending Queue CAM Match",
	  "EvSel": 35,
	  "ExtSel": "",
     },
     "iMC.WPQ_READ_HIT.PCH0": {
	  "Box": "iMC",
	  "Category": "iMC WPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times a request hits in the WPQ (write-pending queue).  The iMC allows writes and reads to pass up other writes to different addresses.  Before a read or a write is issued, it will first CAM the WPQ to see if there is a write pending to that address.  When reads hit, they are able to directly pull their data from the WPQ instead of going to memory.  Writes that hit will overwrite the existing data.  Partial writes that hit will not need to do underfill reads and will simply update their relevant sections.",
	  "Desc": "Write Pending Queue CAM Match",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },
     "iMC.WPQ_READ_HIT.PCH1": {
	  "Box": "iMC",
	  "Category": "iMC WPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times a request hits in the WPQ (write-pending queue).  The iMC allows writes and reads to pass up other writes to different addresses.  Before a read or a write is issued, it will first CAM the WPQ to see if there is a write pending to that address.  When reads hit, they are able to directly pull their data from the WPQ instead of going to memory.  Writes that hit will overwrite the existing data.  Partial writes that hit will not need to do underfill reads and will simply update their relevant sections.",
	  "Desc": "Write Pending Queue CAM Match",
	  "EvSel": 35,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.WPQ_WRITE_HIT": {
	  "Box": "iMC",
	  "Category": "iMC WPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times a request hits in the WPQ (write-pending queue).  The iMC allows writes and reads to pass up other writes to different addresses.  Before a read or a write is issued, it will first CAM the WPQ to see if there is a write pending to that address.  When reads hit, they are able to directly pull their data from the WPQ instead of going to memory.  Writes that hit will overwrite the existing data.  Partial writes that hit will not need to do underfill reads and will simply update their relevant sections.",
	  "Desc": "Write Pending Queue CAM Match",
	  "EvSel": 36,
	  "ExtSel": "",
     },
     "iMC.WPQ_WRITE_HIT.PCH1": {
	  "Box": "iMC",
	  "Category": "iMC WPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times a request hits in the WPQ (write-pending queue).  The iMC allows writes and reads to pass up other writes to different addresses.  Before a read or a write is issued, it will first CAM the WPQ to see if there is a write pending to that address.  When reads hit, they are able to directly pull their data from the WPQ instead of going to memory.  Writes that hit will overwrite the existing data.  Partial writes that hit will not need to do underfill reads and will simply update their relevant sections.",
	  "Desc": "Write Pending Queue CAM Match",
	  "EvSel": 36,
	  "ExtSel": "",
	  "Umask": "bxxxxxx1x",
     },
     "iMC.WPQ_WRITE_HIT.PCH0": {
	  "Box": "iMC",
	  "Category": "iMC WPQ Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of times a request hits in the WPQ (write-pending queue).  The iMC allows writes and reads to pass up other writes to different addresses.  Before a read or a write is issued, it will first CAM the WPQ to see if there is a write pending to that address.  When reads hit, they are able to directly pull their data from the WPQ instead of going to memory.  Writes that hit will overwrite the existing data.  Partial writes that hit will not need to do underfill reads and will simply update their relevant sections.",
	  "Desc": "Write Pending Queue CAM Match",
	  "EvSel": 36,
	  "ExtSel": "",
	  "Umask": "bxxxxxxx1",
     },

# PCU:
     "PCU.CLOCKTICKS": {
	  "Box": "PCU",
	  "Category": "PCU PCLK Events",
	  "Counters": "0-3",
	  "Defn": "The PCU runs off a fixed 1 GHz clock.  This event counts the number of pclk cycles measured while the counter was enabled.  The pclk, like the Memory Controller's dclk, counts at a constant rate making it a good measure of actual wall time.",
	  "Desc": "Clockticks of the power control unit (PCU)",
	  "EvSel": 0,
	  "ExtSel": "",
     },
     "PCU.CORE_TRANSITION_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU CORE_C_STATE_TRANSITION Events",
	  "Counters": "0-3",
	  "EvSel": 96,
	  "ExtSel": "",
     },
     "PCU.DEMOTIONS": {
	  "Box": "PCU",
	  "Category": "PCU CORE_C_STATE_TRANSITION Events",
	  "Counters": "0-3",
	  "EvSel": 48,
	  "ExtSel": "",
     },
     "PCU.FIVR_PS_PS0_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU FIVR Events",
	  "Counters": "0-3",
	  "Defn": "Cycles spent in phase-shedding power state 0",
	  "Desc": "Phase Shed 0 Cycles",
	  "EvSel": 117,
	  "ExtSel": "",
     },
     "PCU.FIVR_PS_PS1_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU FIVR Events",
	  "Counters": "0-3",
	  "Defn": "Cycles spent in phase-shedding power state 1",
	  "Desc": "Phase Shed 1 Cycles",
	  "EvSel": 118,
	  "ExtSel": "",
     },
     "PCU.FIVR_PS_PS2_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU FIVR Events",
	  "Counters": "0-3",
	  "Defn": "Cycles spent in phase-shedding power state 2",
	  "Desc": "Phase Shed 2 Cycles",
	  "EvSel": 119,
	  "ExtSel": "",
     },
     "PCU.FIVR_PS_PS3_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU FIVR Events",
	  "Counters": "0-3",
	  "Defn": "Cycles spent in phase-shedding power state 3",
	  "Desc": "Phase Shed 3 Cycles",
	  "EvSel": 120,
	  "ExtSel": "",
     },
     "PCU.FREQ_CLIP_AVX256": {
	  "Box": "PCU",
	  "Category": "PCU Frequency Clipping Events",
	  "Desc": "AVX256 Frequency Clipping",
	  "EvSel": 73,
	  "ExtSel": "",
     },
     "PCU.FREQ_CLIP_AVX512": {
	  "Box": "PCU",
	  "Category": "PCU Frequency Clipping Events",
	  "Desc": "AVX512 Frequency Clipping",
	  "EvSel": 74,
	  "ExtSel": "",
     },
     "PCU.FREQ_MAX_LIMIT_THERMAL_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU FREQ_MAX_LIMIT Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles any frequency is reduced due to a thermal limit.  Count only if throttling is occurring.",
	  "Desc": "Thermal Strongest Upper Limit Cycles",
	  "EvSel": 4,
	  "ExtSel": "",
     },
     "PCU.FREQ_MAX_POWER_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU FREQ_MAX_LIMIT Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when power is the upper limit on frequency.",
	  "Desc": "Power Strongest Upper Limit Cycles",
	  "EvSel": 5,
	  "ExtSel": "",
     },
     "PCU.FREQ_MIN_IO_P_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU FREQ_MIN_LIMIT Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when IO P Limit is preventing us from dropping the frequency lower.  This algorithm monitors the needs to the IO subsystem on both local and remote sockets and will maintain a frequency high enough to maintain good IO BW.  This is necessary for when all the IA cores on a socket are idle but a user still would like to maintain high IO Bandwidth.",
	  "Desc": "IO P Limit Strongest Lower Limit Cycles",
	  "EvSel": 115,
	  "ExtSel": "",
     },
     "PCU.FREQ_TRANS_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU FREQ_TRANS Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the system is changing frequency.  This can not be filtered by thread ID.  One can also use it with the occupancy counter that monitors number of threads in C0 to estimate the performance impact that frequency transitions had on the system.",
	  "Desc": "Cycles spent changing Frequency",
	  "EvSel": 116,
	  "ExtSel": "",
     },
     "PCU.MEMORY_PHASE_SHEDDING_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU MEMORY_PHASE_SHEDDING Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles that the PCU has triggered memory phase shedding.  This is a mode that can be run in the iMC physicals that saves power at the expense of additional latency.",
	  "Desc": "Memory Phase Shedding Cycles",
	  "EvSel": 47,
	  "ExtSel": "",
	  "Notes": "Package C1",
     },
     "PCU.PKG_RESIDENCY_C0_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU PKG_C_STATE_RESIDENCY Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the package was in C0.  This event can be used in conjunction with edge detect to count C0 entrances (or exits using invert).  Residency events do not include transition times.",
	  "Desc": "Package C State Residency - C0",
	  "EvSel": 42,
	  "ExtSel": "",
     },
     "PCU.PKG_RESIDENCY_C2E_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU PKG_C_STATE_RESIDENCY Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the package was in C2E.  This event can be used in conjunction with edge detect to count C2E entrances (or exits using invert).  Residency events do not include transition times.",
	  "Desc": "Package C State Residency - C2E",
	  "EvSel": 43,
	  "ExtSel": "",
     },
     "PCU.PKG_RESIDENCY_C3_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU PKG_C_STATE_RESIDENCY Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the package was in C3.  This event can be used in conjunction with edge detect to count C3 entrances (or exits using invert).  Residency events do not include transition times.",
	  "Desc": "Package C State Residency - C3",
	  "EvSel": 44,
	  "ExtSel": "",
     },
     "PCU.PKG_RESIDENCY_C6_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU PKG_C_STATE_RESIDENCY Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles when the package was in C6.  This event can be used in conjunction with edge detect to count C6 entrances (or exits using invert).  Residency events do not include transition times.",
	  "Desc": "Package C State Residency - C6",
	  "EvSel": 45,
	  "ExtSel": "",
     },
     "PCU.PMAX_THROTTLED_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU FREQ_MAX_LIMIT Events",
	  "EvSel": 6,
	  "ExtSel": "",
     },
     "PCU.POWER_STATE_OCCUPANCY": {
	  "Box": "PCU",
	  "Category": "PCU POWER_STATE_OCC Events",
	  "Counters": "0-3",
	  "Defn": "This is an occupancy event that tracks the number of cores that are in the chosen C-State.  It can be used by itself to get the average number of cores in that C-state with threshholding to generate histograms, or with other PCU events and occupancy triggering to capture other details.",
	  "Desc": "Number of cores in C-State",
	  "EvSel": 128,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
     },
     "PCU.POWER_STATE_OCCUPANCY.CORES_C3": {
	  "Box": "PCU",
	  "Category": "PCU POWER_STATE_OCC Events",
	  "Counters": "0-3",
	  "Defn": "This is an occupancy event that tracks the number of cores that are in the chosen C-State.  It can be used by itself to get the average number of cores in that C-state with threshholding to generate histograms, or with other PCU events and occupancy triggering to capture other details.",
	  "Desc": "Number of cores in C-State",
	  "EvSel": 128,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "b10000000",
     },
     "PCU.POWER_STATE_OCCUPANCY.CORES_C6": {
	  "Box": "PCU",
	  "Category": "PCU POWER_STATE_OCC Events",
	  "Counters": "0-3",
	  "Defn": "This is an occupancy event that tracks the number of cores that are in the chosen C-State.  It can be used by itself to get the average number of cores in that C-state with threshholding to generate histograms, or with other PCU events and occupancy triggering to capture other details.",
	  "Desc": "Number of cores in C-State",
	  "EvSel": 128,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "b11000000",
     },
     "PCU.POWER_STATE_OCCUPANCY.CORES_C0": {
	  "Box": "PCU",
	  "Category": "PCU POWER_STATE_OCC Events",
	  "Counters": "0-3",
	  "Defn": "This is an occupancy event that tracks the number of cores that are in the chosen C-State.  It can be used by itself to get the average number of cores in that C-state with threshholding to generate histograms, or with other PCU events and occupancy triggering to capture other details.",
	  "Desc": "Number of cores in C-State",
	  "EvSel": 128,
	  "ExtSel": "",
	  "MaxIncCyc": 8,
	  "Umask": "b01000000",
     },
     "PCU.PROCHOT_EXTERNAL_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU PROCHOT Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles that we are in external PROCHOT mode.  This mode is triggered when a sensor off the die determines that something off-die (like DRAM) is too hot and must throttle to avoid damaging the chip.",
	  "Desc": "External Prochot",
	  "EvSel": 10,
	  "ExtSel": "",
     },
     "PCU.PROCHOT_INTERNAL_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU PROCHOT Events",
	  "Counters": "0-3",
	  "Defn": "Counts the number of cycles that we are in Interal PROCHOT mode.  This mode is triggered when a sensor on the die determines that we are too hot and must throttle to avoid damaging the chip.",
	  "Desc": "Internal Prochot",
	  "EvSel": 9,
	  "ExtSel": "",
     },
     "PCU.TOTAL_TRANSITION_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU CORE_C_STATE_TRANSITION Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles spent performing core C state transitions across all cores.",
	  "Desc": "Total Core C State Transition Cycles",
	  "EvSel": 114,
	  "ExtSel": "",
     },
     "PCU.VR_HOT_CYCLES": {
	  "Box": "PCU",
	  "Category": "PCU VR_HOT Events",
	  "Counters": "0-3",
	  "Defn": "Number of cycles that a CPU SVID VR is hot.  Does not cover DRAM VRs",
	  "Desc": "VR Hot",
	  "EvSel": 66,
	  "ExtSel": "",
     },
}
derived = {

# CHA:
     "CHA.AVG_CRD_MISS_LATENCY": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "Average Latency of Code Reads from an iA Core that miss the LLC",
	  "Desc": "Average Code Read Latency",
	  "Equation": "(TOR_OCCUPANCY.IA_MISS_CRD + TOR_OCCUPANCY.IA_MISS_CRD_PREF)  / (TOR_INSERTS.IA_MISS_CRD + TOR_INSERTS.IA_MISS_CRD_PREF)",
     },
     "CHA.AVG_DEMAND_RD_HIT_LATENCY": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "Average Latency of Data Reads that hit the LLC",
	  "Desc": "Average Data Read Hit Latency",
	  "Equation": "TOR_OCCUPANCY.IA_HIT_DRD / TOR_INSERTS.IA_HIT_DRD",
     },
     "CHA.AVG_DEMAND_RD_MISS_LOCAL_LATENCY": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "Average Latency of Data Reads from an IA Core that miss the LLC and were satsified by Local Memory",
	  "Desc": "Average Data Read Local Miss Latency",
	  "Equation": "TOR_OCCUPANCY.IA_MISS_DRD_LOCAL / TOR_INSERTS.IA_MISS_DRD_LOCAL",
     },
     "CHA.AVG_DEMAND_RD_MISS_REMOTE_LATENCY": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "Average Latency of Data Reads from an iA Core that miss the LLC and were satsified by a Remote cache or Remote Memory",
	  "Desc": "Average Data Read Remote Miss Latency",
	  "Equation": "TOR_OCCUPANCY.IA_MISS_DRD_REMOTE / TOR_INSERTS.IA_MISS_DRD_REMOTE",
     },
     "CHA.AVG_DRD_MISS_LATENCY": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "Average Latency of Data Reads or Data Read Prefetches from an IA Core that miss the LLC",
	  "Desc": "Average Data Read Miss Latency",
	  "Equation": "(TOR_OCCUPANCY.IA_MISS_DRD + TOR_OCCUPANCY.IA_MISS_DRD_PREF)  / (TOR_INSERTS.IA_MISS_DRD + TOR_INSERTS.IA_MISS_DRD_PREF)",
     },
     "CHA.AVG_IA_CRD_LLC_HIT_LATENCY": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "Average Latency of Code Reads from an iA Core that miss the LLC",
	  "Desc": "Average Code Read Latency",
	  "Equation": "TOR_OCCUPANCY.IA_HIT_CRD / TOR_INSERTS.IA_HIT_CRD",
     },
     "CHA.AVG_INGRESS_DEPTH": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Defn": "Average Depth of the Ingress Queue through the sample interval",
	  "Desc": "Average Ingress (from CMS) Depth",
	  "Equation": "RxC_OCCUPANCY.IRQ  / SAMPLE_INTERVAL",
     },
     "CHA.AVG_INGRESS_LATENCY": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Defn": "Average Latency of Requests through the Ingress Queue in Uncore Clocks",
	  "Desc": "Average Ingress (from CMS) Latency",
	  "Equation": "RxC_OCCUPANCY.IRQ / RxC_INSERTS.IRQ",
     },
     "CHA.AVG_INGRESS_LATENCY_WHEN_NE": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Defn": "Average Latency of Requests through the Ingress Queue in Uncore Clocks when Ingress Queue has at least one entry",
	  "Desc": "Average Latency in Non-Empty Ingress (from CMS)",
	  "Equation": "RxC_OCCUPANCY.IRQ / COUNTER0_OCCUPANCY{edge_det,thresh=0x1}",
     },
     "CHA.AVG_RFO_MISS_LATENCY": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "Average Latency of RFOs from an iA Core that miss the LLC",
	  "Desc": "Average RFO Latency",
	  "Equation": "(TOR_OCCUPANCY.IA_MISS_RFO + TOR_OCCUPANCY.IA_MISS_RFO_PREF)  / (TOR_INSERTS.IA_MISS_RFO + TOR_INSERTS.IA_MISS_RFO_PREF)",
     },
     "CHA.AVG_TOR_DRDS_MISS_WHEN_NE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "Average Number of Data Read Entries that Miss the LLC when the TOR is not empty.",
	  "Desc": "Average Data Read Misses in Non-Empty TOR",
	  "Equation": "TOR_OCCUPANCY.IA_MISS_DRD / COUNTER0_OCCUPANCY{edge_det,thresh=0x1}",
     },
     "CHA.AVG_TOR_DRDS_WHEN_NE": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "Average Number of Data Read Entries when the TOR is not empty.",
	  "Desc": "Average Data Reads in Non-Empty TOR",
	  "Equation": "TOR_OCCUPANCY.IA_DRD / COUNTER0_OCCUPANCY{edge_det,thresh=0x1}",
     },
     "CHA.CYC_INGRESS_BLOCKED": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Defn": "Cycles the Ingress Request Queue arbiter was Blocked",
	  "Desc": "Cycles Ingress (from CMS) Blocked",
	  "Equation": "RxC_EXT_STARVED.IRQ  / SAMPLE_INTERVAL",
     },
     "CHA.FAST_STR_LLC_HIT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "Number of ItoM (fast string) operations that reference the LLC",
	  "Desc": "Fast String operations",
	  "Equation": "TOR_INSERTS.IA_HIT_ITOM",
     },
     "CHA.FAST_STR_LLC_MISS": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "Number of ItoM (fast string) operations that miss the LLC",
	  "Desc": "Fast String misses",
	  "Equation": "TOR_INSERTS.IA_MISS_ITOM",
     },
     "CHA.INGRESS_REJ_V_INS": {
	  "Box": "CHA",
	  "Category": "CHA INGRESS Events",
	  "Defn": "Ratio of Ingress Request Entries that were rejected vs. inserted",
	  "Desc": "Ingress (from CMS) Rejects vs. Inserts",
	  "Equation": "RxC_INSERTS.IRQ_REJECTED  / RxC_INSERTS.IRQ",
     },
     "CHA.LLC_CRD_MISS_TO_LOC_MEM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "LLC Code Read and Code Prefetch misses satisfied by local memory.",
	  "Desc": "LLC Code Read Misses to Local Memory",
	  "Equation": "TOR_INSERTS.IA_MISS_CRD_PREF_LOCAL + TOR_INSERTS.IA_MISS_CRD_LOCAL",
     },
     "CHA.LLC_CRD_MISS_TO_REM_MEM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "LLC Code Read and Code Read Prefetch misses satisfied by a remote cache or remote memory.",
	  "Desc": "LLC Code Read Misses to Remote Memory",
	  "Equation": "TOR_INSERTS.IA_MISS_CRD_PREF_REMOTE + TOR_INSERTS.IA_MISS_CRD_REMOTE",
     },
     "CHA.LLC_DRD_MISS_PCT": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Desc": "LLC DRd Miss Percentage",
	  "Equation": "LLC_LOOKUP.DATA_READ_MISS / LLC_LOOKUP.DATA_READ_ALL",
     },
     "CHA.LLC_DRD_MISS_TO_LOC_MEM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "LLC Data Read and Data Prefetch misses satisfied by local memory.",
	  "Desc": "LLC Data Read Misses to Local Memory",
	  "Equation": "TOR_INSERTS.IA_MISS_DRD_LOCAL",
     },
     "CHA.LLC_DRD_MISS_TO_REM_MEM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "LLC Data Read and Data Prefetch misses satisfied by a remote cache or remote memory.",
	  "Desc": "LLC Data Read Misses to Remote Memory",
	  "Equation": "TOR_INSERTS.IA_MISS_DRD_REMOTE",
     },
     "CHA.LLC_DRD_PREFETCH_HITS": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "DRd Prefetches that Hit the LLC",
	  "Equation": "TOR_INSERTS.IA_HIT_DRD_PREF",
     },
     "CHA.LLC_DRD_PREFETCH_MISSES": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "DRd Prefetches that Missed the LLC",
	  "Equation": "TOR_INSERTS.IA_MISS_DRD_PREF",
     },
     "CHA.LLC_IA_CRD_HITS": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "LLC Code Read Misses to Local Memory",
	  "Equation": "TOR_INSERTS.IA_HIT_CRD",
     },
     "CHA.LLC_MPI": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Defn": "LLC Misses Per Instruction (code, read, RFO and prefetches)",
	  "Desc": "LLC MPI",
	  "Equation": "LLC_LOOKUP.MISS_ALL / INST_RETIRED.ALL (on Core)",
     },
     "CHA.LLC_PCIE_DATA_BYTES": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "LLC write miss (disk/network reads) bandwidth in MB",
	  "Desc": "LLC Miss Data from PCIe",
	  "Equation": "TOR_INSERTS.IO_ITOM * 64",
     },
     "CHA.LLC_RFO_MISS_PCT": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "LLC RFO Miss Ratio",
	  "Desc": "LLC RFO Miss Ratio",
	  "Equation": "TOR_INSERTS.IA_MISS_RFO / TOR_INSERTS.IA_RFO",
     },
     "CHA.LLC_RFO_MISS_TO_LOC_MEM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "LLC  RFO and RFO Prefetch misses satisfied by local memory.",
	  "Desc": "LLC RFO Misses to Local Memory",
	  "Equation": "TOR_INSERTS.IA_MISS_RFO_LOCAL",
     },
     "CHA.LLC_RFO_MISS_TO_REM_MEM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "LLC RFO and RFO Prefetch misses satisfied by a remote cache or remote memory.",
	  "Desc": "LLC RFO Misses to Remote Memory",
	  "Equation": "TOR_INSERTS.IA_MISS_RFO_REMOTE",
     },
     "CHA.LLC_RFO_PREFETCH_HITS": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "RFO Prefetches that Hit the LLC",
	  "Equation": "TOR_INSERTS.IA_HIT_RFO_PREF",
     },
     "CHA.LLC_RFO_PREFETCH_MISSES": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "RFO Prefetches that Missed the LLC",
	  "Equation": "TOR_INSERTS.IA_MISS_RFO_PREF",
     },
     "CHA.MEM_WB_BYTES": {
	  "Box": "CHA",
	  "Category": "CHA CACHE Events",
	  "Defn": "Data written back to memory in Number of Bytes",
	  "Equation": "LLC_VICTIMS.M_STATE * 64",
     },
     "CHA.MMIO_READ_BW": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "IO Read Bandwidth in MB - Disk or Network Reads",
	  "Desc": "IO Read Bandwidth",
	  "Equation": "TOR_INSERTS.IA_MISS_UCRDF * 64 / 1000000",
     },
     "CHA.MMIO_WRITE_BW": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "IO Write Bandwidth in MB - Disk or Network Writes",
	  "Desc": "IO Write Bandwidth",
	  "Equation": "TOR_INSERTS.IA_MISS_WIL* 64 / 1000000",
     },
     "CHA.PCIE_FULL_WRITES": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "Number of full PCI writes",
	  "Desc": "PCIe Data Traffic",
	  "Equation": "TOR_INSERTS.IO_ITOM",
     },
     "CHA.PCI_PARTIAL_WRITES": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "Number of partial PCI writes",
	  "Desc": "Partial PCI Writes",
	  "Equation": "TOR_INSERTS.IO_RFO",
     },
     "CHA.PCI_READS": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Defn": "Number of  PCI reads",
	  "Desc": "Partial PCI Reads",
	  "Equation": "TOR_INSERTS.IO_PCIRDCUR",
     },
     "CHA.PCT_RD_REQUESTS": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Defn": "Percentage of HA traffic that is from Read Requests",
	  "Desc": "Percent Read Requests",
	  "Equation": "REQUESTS.READS / (REQUESTS.READS + REQUESTS.WRITES)",
     },
     "CHA.PCT_WR_REQUESTS": {
	  "Box": "CHA",
	  "Category": "CHA HA REQUEST Events",
	  "Defn": "Percentage of HA traffic that is from Write Requests",
	  "Desc": "Percent Write Requests",
	  "Equation": "REQUESTS.WRITES / (REQUESTS.READS + REQUESTS.WRITES)",
     },
     "CHA.STREAMED_FULL_STORES": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "Streaming Stores (Full Line)",
	  "Equation": "TOR_INSERTS.IA_WCILF",
     },
     "CHA.STREAMED_FULL_STORES.MISS_LOCAL_TO_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "Streaming Stores (Full Line), targeting DDR, that Miss the LLC - Locally HOMed",
	  "Equation": "TOR_INSERTS.IA_MISS_LOCAL_WCILF_DDR",
     },
     "CHA.STREAMED_FULL_STORES.MISS_LOCAL_TO_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "Streaming Stores (Full Line), targeting PMM, that Miss the LLC - Locally HOMed",
	  "Equation": "TOR_INSERTS.IA_MISS_LOCAL_WCILF_PMM",
     },
     "CHA.STREAMED_FULL_STORES.MISS_REMOTE_TO_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "Streaming Stores (Full Line), targeting DDR, that Miss the LLC - Remotely HOMed",
	  "Equation": "TOR_INSERTS.IA_MISS_REMOTE_WCILF_DDR",
     },
     "CHA.STREAMED_FULL_STORES.MISS_REMOTE_TO_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "Streaming Stores (Full Line), targeting PMM, that Miss the LLC - Remotely HOMed",
	  "Equation": "TOR_INSERTS.IA_MISS_REMOTE_WCILF_PMM",
     },
     "CHA.STREAMED_FULL_STORES.MISS_TO_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "Streaming Stores (Full Line), targeting DDR, that Miss the LLC",
	  "Equation": "TOR_INSERTS.IA_MISS_WCILF_DDR",
     },
     "CHA.STREAMED_FULL_STORES.MISS_TO_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "Streaming Stores (Full Line), targeting PMM, that Miss the LLC",
	  "Equation": "TOR_INSERTS.IA_MISS_WCILF_PMM",
     },
     "CHA.STREAMED_PART_STORES": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "Streaming Stores (Partial Line)",
	  "Equation": "TOR_INSERTS.IA_WCIL",
     },
     "CHA.STREAMED_PART_STORES.MISS_LOCAL_TO_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "Streaming Stores (Partial Line), targeting DDR, that Miss the LLC - Locally HOMed",
	  "Equation": "TOR_INSERTS.IA_MISS_LOCAL_WCIL_DDR",
     },
     "CHA.STREAMED_PART_STORES.MISS_LOCAL_TO_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "Streaming Stores (Partial Line), targeting PMM, that Miss the LLC - Locally HOMed",
	  "Equation": "TOR_INSERTS.IA_MISS_LOCAL_WCIL_PMM",
     },
     "CHA.STREAMED_PART_STORES.MISS_REMOTE_TO_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "Streaming Stores (Partial Line), targeting DDR, that Miss the LLC - Remotely HOMed",
	  "Equation": "TOR_INSERTS.IA_MISS_REMOTE_WCIL_DDR",
     },
     "CHA.STREAMED_PART_STORES.MISS_REMOTE_TO_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "Streaming Stores (Partial Line), targeting PMM, that Miss the LLC - Remotely HOMed",
	  "Equation": "TOR_INSERTS.IA_MISS_REMOTE_WCIL_PMM",
     },
     "CHA.STREAMED_PART_STORES.MISS_TO_DDR": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "Streaming Stores (Partial Line), targeting DDR, that Miss the LLC",
	  "Equation": "TOR_INSERTS.IA_MISS_WCIL_DDR",
     },
     "CHA.STREAMED_PART_STORES.MISS_TO_PMM": {
	  "Box": "CHA",
	  "Category": "CHA TOR Events",
	  "Desc": "Streaming Stores (Partial Line), targeting PMM, that Miss the LLC",
	  "Equation": "TOR_INSERTS.IA_MISS_WCIL_PMM",
     },

# UPI_LL:
     "UPI_LL.DRS_E_FROM_UPI": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Defn": "DRS response in F or E states received from UPI in bytes.  To calculate the total data response for each cache line state, it's necessary to add the contribution from three flavors {DataC, DataC_FrcAckCnflt, DataC_Cmp} of data response packets for each cache line state.",
	  "Desc": "DRS Data in F or E From UPI",
	  "Equation": "RxL_BASIC_HDR_MATCH.{umask,opc}={0x1C,1}  * 64",
     },
     "UPI_LL.DRS_M_FROM_UPI": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Defn": "Data Response DataM packets received from UPI.  Expressed in bytes",
	  "Desc": "DRS Data_Ms From UPI",
	  "Equation": "RxL_BASIC_HDR_MATCH.{umask,opc}={0x0C,1}  * 64",
     },
     "UPI_LL.DRS_WB_FROM_UPI": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Defn": "DRS writeback packets received from UPI in bytes.  This is the sum of Wb{I,S,E} DRS packets",
	  "Desc": "DRS Writeback From UPI",
	  "Equation": "DRS_WbI_FROM_UPI + DRS_WbS_FROM_UPI + DRS_WbE_FROM_UPI",
     },
     "UPI_LL.DRS_WbE_FROM_UPI": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Defn": "DRS writeback 'change M to E state' packets received from UPI in bytes",
	  "Desc": "DRS WbE From UPI",
	  "Equation": "RxL_BASIC_HDR_MATCH.{umask,opc}={0x2D,1}  *64",
     },
     "UPI_LL.DRS_WbI_FROM_UPI": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Defn": "DRS writeback 'change M to I state' packets received from UPI in bytes",
	  "Desc": "DRS WbI From UPI",
	  "Equation": "RxL_BASIC_HDR_MATCH.{umask,opc}={0x0D,1}  *64",
     },
     "UPI_LL.DRS_WbS_FROM_UPI": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Defn": "DRS writeback 'change M to S state' packets received from UPI in bytes",
	  "Desc": "DRS WbSFrom UPI",
	  "Equation": "RxL_BASIC_HDR_MATCH.{umask,opc}={0x1D,1}  *64",
     },
     "UPI_LL.NCB_DATA_FROM_UPI_TO_NODEx": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL FLIT match Events",
	  "Defn": "NCB Data packets (Any - Interrupts) received from UPI sent to Node ID 'x'.  Expressed in bytes",
	  "Desc": "NCB Data From UPI To Node x",
	  "Equation": "RxL_BASIC_HDR_MATCH.{umask,endnid,dnid} = {0xE,1,x} * 64",
     },
     "UPI_LL.PCT_LINK_CRC_RETRY_CYCLES": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL CRC_ERRORS_RX Events",
	  "Defn": "Percent of Cycles the UPI link layer is in retry mode due to CRC errors",
	  "Desc": "Percent Link CRC Retry Cycles",
	  "Equation": "RxL_CRC_CYCLES_IN_LLR / CLOCKTICKS",
     },
     "UPI_LL.PCT_LINK_FULL_POWER_CYCLES": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER_RX Events",
	  "Defn": "Percent of Cycles the UPI link is at Full Power",
	  "Desc": "Percent Link Full Power Cycles",
	  "Equation": "RxL0_POWER_CYCLES / CLOCKTICKS",
     },
     "UPI_LL.PCT_LINK_HALF_DISABLED_CYCLES": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER_RX Events",
	  "Defn": "Percent of Cycles the UPI link in power mode where half of the lanes are disabled.",
	  "Desc": "Percent Link Half Disabled Cycles",
	  "Equation": "RxL0P_POWER_CYCLES / CLOCKTICKS",
     },
     "UPI_LL.PCT_LINK_SHUTDOWN_CYCLES": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL POWER Events",
	  "Defn": "Percent of Cycles the UPI link is Shutdown",
	  "Desc": "Percent Link Shutdown Cycles",
	  "Equation": "L1_POWER_CYCLES / CLOCKTICKS",
     },
     "UPI_LL.UPI_SPEED": {
	  "Box": "UPI_LL",
	  "Category": "UPI_LL CFCLK Events",
	  "Defn": "UPI Speed - In GT/s (GigaTransfers / Second) - Max  UPI Bandwidth is 2 * ROUND ( UPI Speed , 0)",
	  "Desc": "UPI Speed",
	  "Equation": "ROUND (( CLOCKTICKS / TSC ) * TSC_SPEED, 0 ) * ( 8 / 1000)",
     },

# PCU:
     "PCU.PCT_CYC_FREQ_POWER_LTD": {
	  "Box": "PCU",
	  "Category": "PCU FREQ_MAX_LIMIT Events",
	  "Defn": "Percentage of Cycles the Max Frequency is limited by power",
	  "Desc": "Percent Frequency Power Limited",
	  "Equation": "FREQ_MAX_POWER_CYCLES / CLOCKTICKS",
     },

# iMC:
     "iMC.MEM_BW_READS": {
	  "Box": "iMC",
	  "Category": "iMC CAS Events",
	  "Defn": "Memory bandwidth consumed by reads.  Expressed in bytes.",
	  "Desc": "Read Memory Bandwidth",
	  "Equation": "(CAS_COUNT.RD * 64)",
     },
     "iMC.MEM_BW_TOTAL": {
	  "Box": "iMC",
	  "Category": "iMC CAS Events",
	  "Defn": "Total memory bandwidth.  Expressed in bytes.",
	  "Desc": "Total Memory Bandwidth",
	  "Equation": "MEM_BW_READS + MEM_BW_WRITES",
     },
     "iMC.MEM_BW_WRITES": {
	  "Box": "iMC",
	  "Category": "iMC CAS Events",
	  "Defn": "Memory bandwidth consumed by writes  Expressed in bytes.",
	  "Desc": "Write Memory Bandwidth",
	  "Equation": "(CAS_COUNT.WR * 64)",
     },
     "iMC.PCT_CYCLES_CRITICAL_THROTTLE": {
	  "Box": "iMC",
	  "Category": "iMC POWER Events",
	  "Defn": "The percentage of cycles all DRAM ranks in critical thermal throttling",
	  "Desc": "Percent Cycles Critical Throttle",
	  "Equation": "POWER_CRITICAL_THROTTLE_CYCLES / MC_Chy_PCI_PMON_CTR_FIXED",
     },
     "iMC.PCT_CYCLES_DRAM_RANKx_IN_THR": {
	  "Box": "iMC",
	  "Category": "iMC POWER Events",
	  "Defn": "The percentage of cycles DRAM rank (x) spent in thermal throttling.",
	  "Desc": "Percent Cycles DRAM Rank x in CKE",
	  "Equation": "POWER_THROTTLE_CYCLES.RANKx / MC_Chy_PCI_PMON_CTR_FIXED",
     },
     "iMC.PCT_CYCLES_PPD": {
	  "Box": "iMC",
	  "Category": "iMC POWER Events",
	  "Defn": "The percentage of cycles all DRAM ranks in PPD mode",
	  "Desc": "Percent Cycles PPD",
	  "Equation": "POWER_CHANNEL_PPD / MC_Chy_PCI_PMON_CTR_FIXED",
     },
     "iMC.PCT_CYCLES_SELF_REFRESH": {
	  "Box": "iMC",
	  "Category": "iMC POWER Events",
	  "Defn": "The percentage of cycles Memory is in self refresh power mode",
	  "Desc": "Percent Cycles Self Refresh",
	  "Equation": "POWER_SELF_REFRESH / MC_Chy_PCI_PMON_CTR_FIXED",
     },
     "iMC.PCT_RD_REQUESTS": {
	  "Box": "iMC",
	  "Category": "iMC RPQ Events",
	  "Defn": "Percentage of read requests from total requests.",
	  "Desc": "Percent Read Requests",
	  "Equation": "RPQ_INSERTS / (RPQ_INSERTS + WPQ_INSERTS)",
     },
     "iMC.PCT_REQUESTS_PAGE_EMPTY": {
	  "Box": "iMC",
	  "Category": "iMC ACT Events",
	  "Defn": "Percentage of memory requests that resulted in Page Empty",
	  "Desc": "Percent Requests Page Empty",
	  "Equation": "PRE_COUNT.PGT - CAS_COUNT.ALL",
     },
     "iMC.PCT_REQUESTS_PAGE_HIT": {
	  "Box": "iMC",
	  "Category": "iMC ACT Events",
	  "Defn": "Percentage of memory requests that resulted in Page Misses - Precharge followed by Activate",
	  "Desc": "Percent Requests Page Miss",
	  "Equation": "(PRE_COUNT.RD + PRE_COUNT.WR) / CAS_COUNT.ALL",
     },
     "iMC.PCT_WR_REQUESTS": {
	  "Box": "iMC",
	  "Category": "iMC WPQ Events",
	  "Defn": "Percentage of write requests from total requests.",
	  "Desc": "Percent Write Requests",
	  "Equation": "WPQ_INSERTS / (RPQ_INSERTS + WPQ_INSERTS)",
     },
}
categories = (
     "CHA CACHE Events",
     "CHA CBO SNOOP RESPONSE Events",
     "CHA CMS Horizontal EGRESS Events",
     "CHA CMS Transgress Credit Events",
     "CHA CMS Transgress INGRESS Events",
     "CHA CMS Vertical EGRESS Events",
     "CHA DIRECT GO Events",
     "CHA External Misc Events (eg. From MS2IDI)",
     "CHA HA BYPASS Events",
     "CHA HA DIRECTORY Events",
     "CHA HA HitME Events",
     "CHA HA HitME Pipe Events",
     "CHA HA OSB Events",
     "CHA HA PM MEMMODE Events",
     "CHA HA PMM QOS Events",
     "CHA HA REQUEST Events",
     "CHA HA SNOOP RESPONSE Events",
     "CHA HA WBPUSHMTOI Events",
     "CHA Horizontal  RING Events",
     "CHA Horizontal In Use RING Events",
     "CHA INGRESS Events",
     "CHA INGRESS_RETRY Events",
     "CHA ISMQ Events",
     "CHA MC Credit and Traffic Events",
     "CHA MISC Events",
     "CHA Misc Events",
     "CHA OCCUPANCY Events",
     "CHA PIPE REJECT Events",
     "CHA TOR Events",
     "CHA UCLK Events",
     "CHA Vertical In Use RING Events",
     "CHA Vertical RING Events",
     "CHA XPT Events",
     "IIO CLOCK Events",
     "IIO Debug Events",
     "IIO IOMMU Events",
     "IIO ITC Events",
     "IIO Miscellaneous Events",
     "IIO OTC Events",
     "IIO PCIe Completion Buffer Events",
     "IIO Payload Events",
     "IIO Transaction Events",
     "IRP AK Egress Events",
     "IRP BL Egress Events",
     "IRP CLOCK Events",
     "IRP Coherency Events",
     "IRP FAF Events",
     "IRP IRP Buffer Events",
     "IRP MISC Events",
     "IRP OUTBOUND_REQUESTS Events",
     "IRP P2P Events",
     "IRP STALL_CYCLES Events",
     "IRP TRANSACTIONS Events",
     "IRP WRITE_CACHE Events",
     "M2M AD CMS/Mesh Egress Credit Events",
     "M2M AD Egress Events",
     "M2M AD Ingress Events",
     "M2M AK CMS/Mesh Egress Credit Events",
     "M2M AK Egress Events",
     "M2M BL CMS/Mesh Egress Credit Events",
     "M2M BL Egress Events",
     "M2M BL Ingress Events",
     "M2M CMS Horizontal EGRESS Events",
     "M2M CMS Transgress Credit Events",
     "M2M CMS Transgress INGRESS Events",
     "M2M CMS Vertical EGRESS Events",
     "M2M DIRECT2CORE Events",
     "M2M DIRECT2UPI Events",
     "M2M DIRECTORY Events",
     "M2M Directory State Events",
     "M2M Distress Events",
     "M2M External Misc Events (eg. From MS2IDI)",
     "M2M Horizontal  RING Events",
     "M2M Horizontal In Use RING Events",
     "M2M IMC Events",
     "M2M Mirror WriteQ EVENTS",
     "M2M Misc Events",
     "M2M OUTBOUND_TX Events",
     "M2M PACKET MATCH Events",
     "M2M Prefetch CAM Events",
     "M2M RPQ CREDIT Events",
     "M2M Scoreboard Events",
     "M2M TRACKER Events",
     "M2M Transgress Credit Events",
     "M2M UCLK Events",
     "M2M Vertical In Use RING Events",
     "M2M Vertical RING Events",
     "M2M WPQ CREDIT Events",
     "M2M WPQ EVENTS",
     "M2M Write Tracker Events",
     "M2PCIe CMS Horizontal EGRESS Events",
     "M2PCIe CMS Transgress Credit Events",
     "M2PCIe CMS Transgress INGRESS Events",
     "M2PCIe CMS Vertical EGRESS Events",
     "M2PCIe EGRESS Events",
     "M2PCIe EGRESS P2P Credit Events",
     "M2PCIe External Misc Events (eg. From MS2IDI)",
     "M2PCIe Horizontal  RING Events",
     "M2PCIe Horizontal In Use RING Events",
     "M2PCIe IIO_CREDITS Events",
     "M2PCIe INGRESS Events",
     "M2PCIe INGRESS P2P Credit Events",
     "M2PCIe Misc Events",
     "M2PCIe UCLK Events",
     "M2PCIe Vertical In Use RING Events",
     "M2PCIe Vertical RING Events",
     "M3UPI ARB Events",
     "M3UPI CMS Horizontal EGRESS Events",
     "M3UPI CMS Transgress Credit Events",
     "M3UPI CMS Transgress INGRESS Events",
     "M3UPI CMS Vertical EGRESS Events",
     "M3UPI EGRESS Credit Events",
     "M3UPI External Misc Events (eg. From MS2IDI)",
     "M3UPI FlowQ Events",
     "M3UPI Horizontal  RING Events",
     "M3UPI Horizontal In Use RING Events",
     "M3UPI INGRESS Arbitration Events",
     "M3UPI INGRESS Credit Events",
     "M3UPI INGRESS Events",
     "M3UPI INGRESS Flit Events",
     "M3UPI INGRESS Sloting Events",
     "M3UPI Link VN Credit Events",
     "M3UPI Misc Events",
     "M3UPI Special Egress Events",
     "M3UPI UCLK Events",
     "M3UPI Vertical In Use RING Events",
     "M3UPI Vertical RING Events",
     "M3UPI Writeback Events",
     "M3UPI XPT Events",
     "PCIE3 Link Cycle Events",
     "PCIE3 Misc Events",
     "PCIE3 Utilization Events",
     "PCU CORE_C_STATE_TRANSITION Events",
     "PCU FIVR Events",
     "PCU FREQ_MAX_LIMIT Events",
     "PCU FREQ_MIN_LIMIT Events",
     "PCU FREQ_TRANS Events",
     "PCU Frequency Clipping Events",
     "PCU MEMORY_PHASE_SHEDDING Events",
     "PCU PCLK Events",
     "PCU PKG_C_STATE_RESIDENCY Events",
     "PCU POWER_STATE_OCC Events",
     "PCU PROCHOT Events",
     "PCU VR_HOT Events",
     "UBOX EVENT_MSG Events",
     "UBOX LOCK Events",
     "UBOX M2U Events",
     "UBOX PHOLD Events",
     "UBOX RACU Events",
     "UPI_LL CFCLK Events",
     "UPI_LL CRC_ERRORS_RX Events",
     "UPI_LL DIRECT2CORE Events",
     "UPI_LL FLIT match Events",
     "UPI_LL Flit Events",
     "UPI_LL LL to M3 Events",
     "UPI_LL POWER Events",
     "UPI_LL POWER_RX Events",
     "UPI_LL POWER_TX Events",
     "UPI_LL RXQ Events",
     "UPI_LL RX_CREDITS_CONSUMED Events",
     "UPI_LL TXQ Events",
     "UPI_LL VNA_CREDIT_RETURN Events",
     "iMC ACT Events",
     "iMC CAS Events",
     "iMC DCLK Events",
     "iMC DRAM_PRE_ALL Events",
     "iMC DRAM_REFRESH Events",
     "iMC Debug Events",
     "iMC Error Events",
     "iMC PMM CMD Events",
     "iMC PMM MEMMODE COHERENCY Events",
     "iMC PMM MEMMODE SCOREBOARD Events",
     "iMC PMM RPQ Events",
     "iMC PMM WPQ Events",
     "iMC POWER Events",
     "iMC PRE Events",
     "iMC RDB Events",
     "iMC RPQ Events",
     "iMC TAG CHECK Events",
     "iMC WPQ Events",
);
